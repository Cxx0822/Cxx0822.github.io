{"meta":{"title":"NJTECH_Cxx","subtitle":"不要因为别人5%的负面评价而否定自己100%的努力。","description":null,"author":"Cxx","url":"http://cxx0822.github.io"},"pages":[{"title":"","date":"2022-03-18T13:16:50.911Z","updated":"2022-03-18T13:16:50.911Z","comments":true,"path":"baidu_verify_TurTrUK7im.html","permalink":"http://cxx0822.github.io/baidu_verify_TurTrUK7im.html","excerpt":"","text":"TurTrUK7im"},{"title":"文章分类","date":"2019-01-07T04:57:32.000Z","updated":"2022-03-18T13:16:50.912Z","comments":true,"path":"categories/index.html","permalink":"http://cxx0822.github.io/categories/index.html","excerpt":"","text":""},{"title":"文章热度排行","date":"2019-08-14T07:23:11.000Z","updated":"2022-03-18T13:16:50.914Z","comments":true,"path":"top/index.html","permalink":"http://cxx0822.github.io/top/index.html","excerpt":"","text":"firebase.initializeApp({ apiKey: 'AIzaSyDVo2zpHFwv7n4cwQQvhMCzvbNg4eDwiV4', //你的apiKey projectId: 'cxx0822-7221e' //你的projectId }) var title= ''; var count = 0; var url = ''; const db = firebase.firestore(); var collection = 'articles'; //主题配置文件配置的collection //'; db.collection(collection).orderBy('count', 'desc').limit(10).get().then((querySnapshot) => { querySnapshot.forEach((doc) => { // console.log(doc.id, \" => \", doc.data()); title = doc.id; count = doc.data().count; url = doc.data().url; var content=\"\"+\"\"+\"【文章热度: \"+count+\" ℃】\"+\"\" + '&emsp;&emsp;' + \""}],"posts":[{"title":"Vue3设计与实现笔记整理：编译器","slug":"Vue3设计与实现笔记整理：编译器","date":"2022-08-30T08:40:43.000Z","updated":"2022-11-23T13:25:16.586Z","comments":true,"path":"2022/08/30/vue3-she-ji-yu-shi-xian-bi-ji-zheng-li-bian-yi-qi/","link":"","permalink":"http://cxx0822.github.io/2022/08/30/vue3-she-ji-yu-shi-xian-bi-ji-zheng-li-bian-yi-qi/","excerpt":"","text":"编译器概览&emsp;&emsp;将源代码翻译为目标代码的过程称为编译，完整的编译过程通常包含以下几个步骤：&emsp;&emsp;&emsp;&emsp;对于Vue.js模板编译器，源代码就是组件的模板，而目标代码就是能够在浏览器平台上运行的JavaScript代码。&emsp;&emsp;&emsp;&emsp;Vue.js模板编译器的目标代码实际就是渲染函数。&emsp;&emsp;其具体工作流程如下：&emsp;&emsp;&emsp;&emsp;首先会对模板进行词法分析和语法分析，得到模板AST。接着，将模板AST转换成JavaScript AST。最后，根据JavaScript AST生成JavaScript代码，即渲染函数代码。&emsp;&emsp;具体而言，Vue.js将这三部分分成具体的三个功能函数执行： 用来将模板字符串解析为模板AST的解析器(parse) 用来将模板AST转换为JavaScript AST的转换器(transformer) 用来根据JavaScript AST生成渲染函数代码的生成器(generator)&emsp;&emsp;完整的流程如下：&emsp;&emsp; 模板解析器实现原理有限状态机&emsp;&emsp;解析器的参数为字符串模板，解析会逐个读取字符串模板中的字符，并根据一定的规则将整个字符串切割为一个个Token。其依据规则就是有限状态自动机。&emsp;&emsp;所谓有限状态就是有限个状态，自动机则是随着字符的输入，解析器会自动的在不同状态间迁移，例如在以下模板中： 1&lt;p&gt;Vue&lt;p&gt; &emsp;&emsp;解析器首先处于初始状态1，然后读取到字符&lt;，此时状态机会进入下一个状态，即标签开始状态2，在该状态下，会读取到字符p，此时会认为进入到标签名称状态3，接着读取到&gt;，此时状态机会从该状态迁移回初始状态1，并记录标签名称状态下产生的标签名称p。接着会循环往复，直到解析完整，得到最终的三个Token。 开始标签：&lt;p&gt; 文本节点：vue 结束标签：&lt;/p&gt;&emsp;&emsp;因此通过有限状态自动机规则，解析器会根据模板字符串的内容不断地切换当前的状态，并记录当前状态的产物，得到一系列的Token，其本质就是实现模板的标记化，方便后续处理。&emsp;&emsp;例如有以下模板： 1&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt; &emsp;&emsp;通过有限自动状态机转换后，得到如下tokens： 12345678910111213const tokens = tokenzie(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`) // 输出const tokens = [ &#123; type: \"tag\", name: \"div\" &#125;, // div 开始标签节点 &#123; type: \"tag\", name: \"p\" &#125;, // p 开始标签节点 &#123; type: \"text\", content: \"Vue\" &#125;, // 文本节点 &#123; type: \"tagEnd\", name: \"p\" &#125;, // p 结束标签节点 &#123; type: \"tag\", name: \"p\" &#125;, // p 开始标签节点 &#123; type: \"text\", content: \"Template\" &#125;, // 文本节点 &#123; type: \"tagEnd\", name: \"p\" &#125;, // p 结束标签节点 &#123; type: \"tagEnd\", name: \"div\" &#125; // div 结束标签节点] 构造AST&emsp;&emsp;Vue.js的模板本质上和HTML类似，是一种标记语言，格式非常固定，标签元素之间天然嵌套，形成父子关系。因此，可以根据模板解析后生成的Token构造一个树形结构的AST。&emsp;&emsp;构造AST的过程就是对Token列表进行扫描的过程。根据Token中的type信息进行父子关系组成，从而构成AST树。&emsp;&emsp;例如之前的示例模板，转换后的AST结构为： 1234567891011121314151617181920212223242526272829303132const ast = parse(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)// 输出const ast = &#123; type: 'Root', children: [ &#123; type: 'Element', tag: 'div', children: [ &#123; type: 'Element', tag: 'p', children: [ &#123; type: 'Text', content: 'Vue' &#125; ] &#125;, &#123; type: 'Element', tag: 'p', children: [ type: 'Text', content: 'Template' ] &#125; ] &#125; ]&#125; AST的转换&emsp;&emsp;AST转换就是对AST进行一系列操作，将其转换为新的AST的过程。因此我们可以对模板AST进行操作，将其转换为JavaScript AST，转换后的AST用于代码生成。 将模板AST转换为JavaScript AST&emsp;&emsp;例如上述模板： 1&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt; &emsp;&emsp;与这段模板等价的渲染函数是: 123456function render() &#123; return h('div', [ h('p', 'Vue'), h('p', 'Template') ])&#125; &emsp;&emsp;上述渲染函数的JavaScript代码所对应的JavaScript AST就是我们的转换目标。与模板AST是模板的描述一样，JavaScript AST就是JavaScript代码的描述，因此，本质上，我们需要设计一些数据结构来描述渲染函数的代码。&emsp;&emsp;例如，一个函数的声明语句可以由以下几部分组成： id: 函数名称 是一个标识符Identifier params: 函数参数 是一个数组 body: 函数体 函数体可以包含多个语句，也是个数组 &emsp;&emsp;因此，可以设计如下基本数据结构来描述函数声明语句： 1234567891011121314const FunctionDeclNode = &#123; type: 'FunctionDecl' id: &#123; type: 'Identifier', name: 'render' &#125;, params: [], body: [ &#123; type: 'ReturnStatement', return: null &#125; ]&#125; &emsp;&emsp;同样，我们也可以设计其他的语句，最终效果如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344const FunctionDeclNode = &#123; type: 'FunctionDecl' id: &#123; type: 'Identifier', name: 'render' &#125;, params: [], body: [ &#123; type: 'ReturnStatement', return: &#123; type: 'CallExpression', callee: &#123; type: 'Identifier', name: 'h' &#125;, arguments: [ &#123; type: 'StringLiteral', value: 'div' &#125;, &#123; type: 'ArrayExpression', elements: [ &#123; type: 'CallExpression', callee: &#123; type: 'Identifier', name: 'h' &#125;, arguments: [ &#123; type: 'StringLiteral', value: 'p' &#125;, &#123; type: 'StringLiteral', value: 'Vue' &#125;, ] &#125;, &#123; type: 'CallExpression', callee: &#123; type: 'Identifier', name: 'h' &#125;, arguments: [ &#123; type: 'StringLiteral', value: 'p' &#125;, &#123; type: 'StringLiteral', value: 'Template' &#125;, ] &#125; ] &#125; ] &#125; &#125; ]&#125; &emsp;&emsp;上述代码就是对渲染函数代码的完整描述。 代码生成&emsp;&emsp;构造完JavaScript AST后，就可以生成渲染函数的代码了，其本质就是字符串的拼接，访问JavaScript AST的每一个节点，并为其生成相应的JavaScript代码。 12345678910function compile(template) &#123; // 解析模板 生成模板AST const ast = parse(template) // 将模板AST转换为JavaScript AST transform(ast) // 生成代码 const code = generate(ast.jsNode) return code&#125; &emsp;&emsp;以FunctionDecl节点为例，使用genFunctionDecl函数为该类型节点生成对应的JavaScript代码： 1234567891011121314151617181920function genFunctionDecl(node, context) &#123; // indent deIndent 为缩进和取消缩进 const &#123; push, indent, deIndent &#125; = context push(`function $&#123;node.id.name &#125; `) push('(') // 生成函数参数 genNodeList(node.params, context) push(') ') push('&#123;') indent() // 生成函数体 node.body.forEach(n =&gt; genNode(n, context)) deIndent() push('&#125;')&#125; &emsp;&emsp;最终生成的代码为： 123function render () &#123;&#125; 总结&emsp;&emsp;Vue.js的模板编译器用于将模板编译为渲染函数，其工作流程大致分为三个步骤： 分析模板，将其解析为模板AST。 将模板AST转换为用于描述渲染函数的JavaScript AST。 根据JavaScript AST生成渲染函数代码。","categories":[{"name":"Web前端学习笔记","slug":"Web前端学习笔记","permalink":"http://cxx0822.github.io/categories/Web前端学习笔记/"}],"tags":[]},{"title":"vue3-admin-template项目说明","slug":"vue3-admin-template项目说明","date":"2022-04-01T06:13:23.000Z","updated":"2022-09-09T11:31:13.695Z","comments":true,"path":"2022/04/01/vue3-admin-template-xiang-mu-shuo-ming/","link":"","permalink":"http://cxx0822.github.io/2022/04/01/vue3-admin-template-xiang-mu-shuo-ming/","excerpt":"","text":"项目说明&emsp;&emsp;Vue3-admin-template是一个后台前端解决方案，基于最新(2022年)的前端技术构建，可以直接基于此项目进行二次开发。 技术栈 前端框架：Vue3 UI 组件库：Element Plus 路由管理：Vue Router v4 状态管理：Pinia 网络管理：axios 前端开发与构建工具：Vite v2 编程语言：TypeScript 初始化项目新建项目&emsp;&emsp;打开终端输入： 1npm create vite@latest &emsp;&emsp;依次输入项目名称、框架即可。&emsp;&emsp;这里选择vue + ts。 启动项目安装依赖包1npm install 运行1npm run dev 精简项目 index.html &emsp;&emsp;将&lt;title&gt;更改为vue3-admin-template。 src-&gt;App.vue &emsp;&emsp;删除&lt;script&gt;、&lt;template&gt;和&lt;style&gt;中的内容。 1234567891011&lt;script setup lang=\"ts\"&gt;&lt;/script&gt;&lt;template&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; src-&gt;components-&gt;HelloWorld.vue &emsp;&emsp;删除该组件。 项目实现——极简版路由配置安装1npm install vue-router@4 新建登录页面 src-&gt;views-&gt;login-&gt;index.vue 123456789&lt;template&gt; 登录&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; &emsp;&emsp;views文件夹通常存放的是页面级文件。 新建首页页面 src-&gt;views-&gt;dashbord-&gt;index.vue 123456789&lt;template&gt; 首页&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 新建全局布局系统&emsp;&emsp;新建src-&gt;layout-&gt;components文件夹。&emsp;&emsp;新建src-&gt;layout-&gt;index.vue： 12345678910&lt;template&gt; &lt;!-- 路由显示 --&gt; &lt;router-view/&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 新建路由配置文件&emsp;&emsp;新建src-&gt;router-&gt;index.ts 1234567891011121314151617181920212223242526272829303132333435363738import &#123; createRouter, createWebHashHistory, RouteRecordRaw &#125; from 'vue-router'// 导入全局布局组件import Layout from '@/layout/index.vue'export const constantRoutes: Array&lt;RouteRecordRaw&gt; | any = [ // 登录路由 &#123; path: '/login', // 引入登录页面 component: () =&gt; import('@/views/login/index.vue'), hidden: true &#125;, // 首页路由 &#123; path: '/', // 使用全局组件布局 component: Layout, redirect: '/dashboard', children: [ &#123; path: 'dashboard', // 引入首页页面 component: () =&gt; import('@/views/dashboard/index.vue'), name: 'Dashboard', meta: &#123; title: '首页', noCache: true, icon: 'dashboard', affix: true &#125; &#125; ] &#125;]const router = createRouter(&#123; history: createWebHashHistory(), scrollBehavior: () =&gt; (&#123; top: 0 &#125;), routes: constantRoutes&#125;)export default router &emsp;&emsp;这里需要设置src文件夹别名为@：&emsp;&emsp;增加tsconfig.json的compilerOptions键值对： 1234567// 设置 @ 路径\"baseUrl\": \".\",\"paths\": &#123; \"@/*\": [ \"src/*\" ]&#125; &emsp;&emsp;修改vite.config.ts 12345678910111213141516import &#123; defineConfig &#125; from 'vite'import vue from '@vitejs/plugin-vue'// 导入pathconst path = require('path');// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue()], resolve: &#123; // 配置路径别名 alias: &#123; '@': path.resolve(__dirname, './src'), &#125;, &#125;,&#125;) &emsp;&emsp;如果Vscode编译器报错，需要安装依赖包： 1npm i @types/node --D 修改App.vue12345678910&lt;template&gt; &lt;div id=\"app\"&gt; &lt;!-- 路由显示 --&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; 修改main.ts文件123456789101112131415import &#123; createApp &#125; from 'vue'// 引入Vue Appimport App from './App.vue'// 引入路由import router from './router'// 创建Vue3实例const app = createApp(App)// 使用路由app.use(router)// 挂载到根组件上app.mount('#app') &emsp;&emsp;实际效果图：&emsp;&emsp;如图所示，在地址栏输入/login和/即可切换路由。 配置初始路由为登录页&emsp;&emsp;添加src-&gt;permission.ts： 1234567import router from '@/router/index'router.beforeEach((to, from, next) =&gt; &#123; const username = localStorage.getItem('username') if (to.path !== '/login' &amp;&amp; !username) next(&#123; path: '/login' &#125;) else next()&#125;) &emsp;&emsp;当路由指向不是登录页且没有用户名信息时，将路由强制跳转至登录页，否则放行。 main.ts： 1import '@/permission' &emsp;&emsp;注：这里只是简单示例，没有添加实际的业务需求。下同。 其他配置ELement UI Plus配置&emsp;&emsp;安装 1npm install element-plus --save &emsp;&emsp;配置 main.ts 123456789101112// 引入element-ui组件import ElementPlus from 'element-plus'import 'element-plus/dist/index.css'import 'dayjs/locale/zh-cn' // 中文import locale from 'element-plus/lib/locale/lang/zh-cn' // 中文// 创建Vue3实例const app = createApp(App)// 使用Element UI Plusapp.use(ElementPlus, &#123; locale &#125;)// 挂载到根组件上app.mount('#app') scss配置&emsp;&emsp;安装 1npm i sass --save-dev ESLint配置&emsp;&emsp;安装 12npm install eslint --save-devnpm init @eslint/config &emsp;&emsp;更新rules：&emsp;&emsp;详见Github项目地址中的.eslintrc.js文件。&emsp;&emsp;在Vscode编译器中安装ESLint插件，并打开配置文件settings(ctrl+shift+p)，增加以下配置信息： 12345678910111213// eslint配置\"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"vue\", \"typescript\"],\"eslint.format.enable\": true,\"eslint.alwaysShowStatus\": true,\"editor.codeActionsOnSave\": &#123; \"source.fixAll\": true, \"eslint.autoFixOnSave\" : true,&#125; &emsp;&emsp;注：如果eslint没有运行，可以打开Vscode编译器右下角的ESlint终端查找错误。 登录页面 src-&gt;views-&gt;login-&gt;index.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;template&gt; &lt;div class=\"login-container\"&gt; &lt;!-- 登录表单 --&gt; &lt;el-form ref=\"loginFormRef\" :model=\"loginInfo.loginForm\" class=\"login-form\" &gt; &lt;!-- username表单选项 --&gt; &lt;el-form-item prop=\"username\"&gt; &lt;!-- username输入框 --&gt; &lt;el-input v-model=\"loginInfo.loginForm.username\" placeholder=\"用户名\" /&gt; &lt;/el-form-item&gt; &lt;!-- password表单选项 --&gt; &lt;el-form-item prop=\"password\"&gt; &lt;!-- password输入框 --&gt; &lt;el-input v-model=\"loginInfo.loginForm.password\" placeholder=\"密码\" /&gt; &lt;/el-form-item&gt; &lt;!-- 登录按钮 --&gt; &lt;el-button type=\"primary\" style=\"width:100%;margin-bottom:30px;font-size:18px\" @click.prevent=\"handleLogin(loginFormRef)\" &gt;登录&lt;/el-button&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import &#123; reactive, ref &#125; from 'vue'import &#123; useRouter &#125; from 'vue-router'import &#123; ElMessage &#125; from 'element-plus'import type &#123; ElForm &#125; from 'element-plus'// 表单引用 固定格式type FormInstance = InstanceType&lt;typeof ElForm&gt;const loginFormRef = ref&lt;FormInstance&gt;()const router = useRouter()// 登录页面数据const loginInfo = reactive(&#123; loginForm: &#123; username: '', password: '' &#125;&#125;)// 处理登录事件// 这里需要传入表单的refconst handleLogin = (formEl: FormInstance | undefined) =&gt; &#123; if (!formEl) return formEl.validate((valid) =&gt; &#123; if (valid) &#123; if (loginInfo.loginForm.username.trim() !== '' &amp;&amp; loginInfo.loginForm.password.trim() !== '') &#123; localStorage.setItem('username', loginInfo.loginForm.username) // 跳转至首页 router.push(&#123; path: '/dashboard' || '/' &#125;) ElMessage.success('登录成功') &#125; else &#123; ElMessage.error('请输入正确的用户名和密码') &#125; &#125; else &#123; ElMessage.error('请输入正确的用户名和密码') return false &#125; &#125;)&#125;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;.login-container &#123; min-height: 100%; width: 100%; overflow: hidden; background-color: white; .login-form &#123; // 表单靠右居中 position: absolute; right: 10%; top: 35%; width: 400px; max-width: 100%; padding: 20px 20px 0; margin: 0 auto; overflow: hidden; // 添加外边框 border-radius: 10px; border: 2px solid #008B93; &#125;&#125;&lt;/style&gt; &emsp;&emsp;这里只做了简单的表单验证，如果成功则跳转至首页，并在浏览器中记录用户名信息。 全局布局组件系统&emsp;&emsp;全局布局文件整体分为侧边栏、导航栏、页面主体区域和状态栏四个部分。具体位置见上图所示。&emsp;&emsp;在src目录下新建layout文件夹，用于存放全局布局文件。然后在layout文件夹下，新建components文件夹和index.vue文件。其中components文件夹存放各个区域的布局文件，index.vue为出口文件。&emsp;&emsp;在components文件夹下，分别新建侧边栏布局文件夹Sidebar文件夹(并在文件夹内新建出口文件index.vue)，主体区域布局文件AppMain.vue、导航栏布局文件Narvar.vue和状态栏布局文件Footerbar.vue。 &emsp;&emsp;layout的出口文件src-&gt;layout-&gt;index.vue： 12345678910111213141516171819202122&lt;template&gt; &lt;!-- 全局布局组件 --&gt; &lt;div :class=\"classObj\" class=\"app-wrapper\"&gt; &lt;!-- 侧边栏组件 --&gt; &lt;Sidebar class=\"sidebar-container\"/&gt; &lt;!-- 主体区域 --&gt; &lt;div class=\"main-container\"&gt; &lt;div&gt; &lt;!-- 导航栏 --&gt; &lt;navbar class=\"navbar-container\"/&gt; &lt;/div&gt; &lt;!-- 页面主体区域 --&gt; &lt;app-main /&gt; &lt;div class=\"footerbar-container\"&gt; &lt;Footerbar /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 1234import AppMain from './components/AppMain.vue'import Navbar from './components/Navbar.vue'import Sidebar from './components/Sidebar/index.vue'import Footerbar from './components/Footerbar.vue' &emsp;&emsp;这里只显示布局文件和脚本文件，样式文件详见Github项目地址。下同。 主体区域布局文件 src-&gt;layout-&gt;components-&gt;AppMain.vue： 123456&lt;template&gt; &lt;section class=\"app-main\"&gt; &lt;!-- 路由显示 --&gt; &lt;router-view/&gt; &lt;/section&gt;&lt;/template&gt; &emsp;&emsp;这里存放路由配置文件中的具体路由显示。 状态栏布局文件 src-&gt;layout-&gt;components-&gt;Footerbar.vue： 123456789&lt;template&gt; &lt;!-- 状态栏组件 --&gt; &lt;div class=\"footerbar\"&gt; &lt;!-- 右下角状态栏 --&gt; &lt;div class=\"right-menu\"&gt; &lt;span class=\"right-menu-item hover-effect\"&gt;状态栏&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &emsp;&emsp;这里只做了简单的显示，可根据实际需求添加相应功能。 导航栏布局文件 src-&gt;layout-&gt;components-&gt;Narbar.vue： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=\"navbar\"&gt; &lt;!-- 右上角菜单栏 --&gt; &lt;div class=\"right-menu\"&gt; &lt;span class=\"right-menu-item\"&gt;欢迎你 &#123;&#123; loginInfo.username &#125;&#125;&lt;/span&gt; &lt;!-- 下拉框组件 --&gt; &lt;el-dropdown class=\"avatar-container right-menu-item hover-effect\"&gt; &lt;span class=\"avatar-wrapper\"&gt; &lt;img src=\"@/assets/user.png\" class=\"user-avatar\"&gt; &lt;el-icon class=\"el-icon--right\"&gt; &lt;arrow-down /&gt; &lt;/el-icon&gt; &lt;/span&gt; &lt;!-- 下拉框菜单 --&gt; &lt;template #dropdown&gt; &lt;el-dropdown-menu&gt; &lt;el-dropdown-item divided @click=\"logout\"&gt; &lt;span style=\"display:block;\"&gt;退出登录&lt;/span&gt; &lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/template&gt; &lt;/el-dropdown&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314import &#123; ArrowDown &#125; from '@element-plus/icons-vue'import &#123; reactive &#125; from 'vue'import &#123; useRouter &#125; from 'vue-router'const router = useRouter()const loginInfo = reactive(&#123; username: window.localStorage.getItem('username')&#125;)const logout = () =&gt; &#123; window.localStorage.removeItem('username') router.push('/login')&#125; &emsp;&emsp;这里只做了简单的信息显示和退出登录功能。 菜单栏组件系统&emsp;&emsp;菜单栏组件主要分为两部分，上面为项目图标和项目名称，下面为各个菜单组成的滚动条。 图标组件&emsp;&emsp;在Sidebar文件夹下新建Logo.vue文件： src-&gt;layout-&gt;components-&gt;Sidebar-&gt;Logo.vue： 12345678910&lt;template&gt; &lt;div class=\"sidebar-logo-container\"&gt; &lt;!-- 跳转到首页 --&gt; &lt;router-link key=\"collapse\" class=\"sidebar-logo-link\" to=\"/\"&gt; &lt;!-- 图标 + 标题 --&gt; &lt;img v-if=\"logoInfo.logo\" :src=\"logoInfo.logo\" class=\"sidebar-logo\"&gt; &lt;h1 class=\"sidebar-title\"&gt;&#123;&#123; logoInfo.title &#125;&#125; &lt;/h1&gt; &lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; &emsp;&emsp;这里使用&lt;router-link&gt;进行包裹区域，可以实现点击图标/标题跳转至首页。 12345678910&lt;script setup lang=\"ts\"&gt;import &#123; reactive &#125; from 'vue'const logoInfo = reactive(&#123; title: 'vue3 admin template', // vite获取静态资源路径 logo: new URL('../../../assets/logo.png', import.meta.url).href&#125;)&lt;/script&gt; &emsp;&emsp;注意vite获取静态资源文件的方式。 菜单路由组件系统&emsp;&emsp;在Sidebar文件夹下，新建菜单项组件：SidebarItem.vue，菜单内容组件Item.vue和判断菜单类型组件Link.vue。&emsp;&emsp;本项目主要包含3种路由类型：单级路由，多级路由和外部链接路由。因此，首选更改之前的路由配置文件： src-&gt;router-&gt;index.ts： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import &#123; createRouter, createWebHashHistory, RouteRecordRaw &#125; from 'vue-router'// 导入全局布局组件import Layout from '@/layout/index.vue'export const constantRoutes: Array&lt;RouteRecordRaw&gt; | any = [ // 登录路由 &#123; path: '/login', // 引入登录页面 component: () =&gt; import('@/views/login/index.vue'), hidden: true &#125;, // 首页路由 &#123; path: '/', // 使用全局组件布局 component: Layout, redirect: '/dashboard', children: [ &#123; path: 'dashboard', // 引入首页页面 component: () =&gt; import('@/views/dashboard/index.vue'), name: 'Dashboard', meta: &#123; title: '首页', noCache: true, icon: 'dashboard', affix: true &#125; &#125; ] &#125;, // 嵌套路由 &#123; path: '/nested', component: Layout, redirect: '/nested/menu1/menu1-1', name: 'Nested', meta: &#123; title: '嵌套路由', icon: 'nested' &#125;, children: [ &#123; path: 'menu1', component: () =&gt; import('@/views/nested/menu1/index.vue'), // Parent router-view name: 'Menu1', meta: &#123; title: 'Menu 1' &#125;, redirect: '/nested/menu1/menu1-1', children: [ &#123; path: 'menu1-1', component: () =&gt; import('@/views/nested/menu1/menu1-1/index.vue'), name: 'Menu1-1', meta: &#123; title: 'Menu 1-1' &#125; &#125;, &#123; path: 'menu1-2', component: () =&gt; import('@/views/nested/menu1/menu1-2/index.vue'), name: 'Menu1-2', redirect: '/nested/menu1/menu1-2/menu1-2-1', meta: &#123; title: 'Menu 1-2' &#125;, children: [ &#123; path: 'menu1-2-1', component: () =&gt; import('@/views/nested/menu1/menu1-2/menu1-2-1/index.vue'), name: 'Menu1-2-1', meta: &#123; title: 'Menu 1-2-1' &#125; &#125;, &#123; path: 'menu1-2-2', component: () =&gt; import('@/views/nested/menu1/menu1-2/menu1-2-2/index.vue'), name: 'Menu1-2-2', meta: &#123; title: 'Menu 1-2-2' &#125; &#125; ] &#125;, &#123; path: 'menu1-3', component: () =&gt; import('@/views/nested/menu1/menu1-3/index.vue'), name: 'Menu1-3', meta: &#123; title: 'Menu 1-3' &#125; &#125; ] &#125;, &#123; path: 'menu2', name: 'Menu2', component: () =&gt; import('@/views/nested/menu2/index.vue'), meta: &#123; title: 'Menu 2' &#125; &#125; ] &#125;, // 外部链接 &#123; path: '/github-link', component: Layout, children: [ &#123; path: 'https://github.com/Cxx0822/vue3-admin-template', meta: &#123; title: 'github', icon: 'github' &#125; &#125; ] &#125;]const router = createRouter(&#123; history: createWebHashHistory(), scrollBehavior: () =&gt; (&#123; top: 0 &#125;), routes: constantRoutes&#125;)export default router src-&gt;layout-&gt;components-&gt;Sidebar-&gt;index.vue： 123456789101112131415161718192021&lt;template&gt; &lt;div class=\"sidebar-container\"&gt; &lt;!-- 左上角图标 --&gt; &lt;logo /&gt; &lt;!-- 菜单滚动条区域 --&gt; &lt;el-scrollbar wrap-class=\"scrollbar-wrapper\"&gt; &lt;!-- 菜单栏 --&gt; &lt;el-menu :background-color=\"variables.menuBg\" :text-color=\"variables.menuText\" :unique-opened=\"false\" :active-text-color=\"variables.menuActiveText\" :collapse-transition=\"false\" mode=\"vertical\" &gt; &lt;!-- 菜单项 --&gt; &lt;sidebar-item v-for=\"route in constantRoutes\" :key=\"route.path\" :item=\"route\" :base-path=\"route.path\" /&gt; &lt;/el-menu&gt; &lt;/el-scrollbar&gt; &lt;/div&gt;&lt;/template&gt; 12345678&lt;script setup lang=\"ts\"&gt;import Logo from './Logo.vue'import SidebarItem from './SidebarItem.vue'import variables from '@/styles/variables.module.scss'import &#123; constantRoutes &#125; from '@/router/index'&lt;/script&gt; &emsp;&emsp;菜单路由部分首先使用el-scrollbar滚动条组件包裹所有的el-menu组件，然后使用v-for指令添加路由配置文件的所有路由。 src-&gt;layout-&gt;components-&gt;Sidebar-&gt;SidebarItem.vue： 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div v-if=\"!item.hidden\"&gt; &lt;!-- 只有单个child --&gt; &lt;template v-if=\"hasOneShowingChild(item.children,item) &amp;&amp; (!sidebarInfo.onlyOneChild.children || sidebarInfo.onlyOneChild.noShowingChildren) &amp;&amp; !item.alwaysShow\"&gt; &lt;!-- 判断是路由还是链接 --&gt; &lt;app-link v-if=\"sidebarInfo.onlyOneChild.meta\" :to=\"resolvePath(sidebarInfo.onlyOneChild.path)\"&gt; &lt;!-- el-menu菜单项 --&gt; &lt;el-menu-item :index=\"resolvePath(sidebarInfo.onlyOneChild.path)\" :class=\"&#123;'submenu-title-noDropdown':!props.isNest&#125;\"&gt; &lt;!-- 菜单内容 --&gt; &lt;item :icon=\"sidebarInfo.onlyOneChild.meta.icon || (item.meta &amp;&amp; item.meta.icon)\" :title=\"sidebarInfo.onlyOneChild.meta.title\" /&gt; &lt;/el-menu-item&gt; &lt;/app-link&gt; &lt;/template&gt; &lt;!-- 有多个children --&gt; &lt;el-sub-menu v-else ref=\"subMenu\" :index=\"resolvePath(item.path)\" popper-append-to-body&gt; &lt;template v-slot:title&gt; &lt;item v-if=\"item.meta\" :icon=\"item.meta &amp;&amp; item.meta.icon\" :title=\"item.meta.title\" /&gt; &lt;/template&gt; &lt;!-- 循环生成组件 --&gt; &lt;sidebar-item v-for=\"child in item.children\" :key=\"child.path\" :is-nest=\"true\" :item=\"child\" :base-path=\"resolvePath(child.path)\" class=\"nest-menu\" /&gt; &lt;/el-sub-menu&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;script setup lang=\"ts\"&gt;// vite 源码中设定了不允许在客户端代码中访问内置模块代码// 使用 path-browserify 代替 path 模块import path from 'path-browserify'import Item from './Item.vue'import AppLink from './Link.vue'import &#123; defineProps, reactive &#125; from 'vue'const props = defineProps(&#123; // route object item: &#123; type: Object, required: true &#125;, isNest: &#123; type: Boolean, default: false &#125;, basePath: &#123; type: String, default: '' &#125;&#125;)const sidebarInfo = reactive(&#123; onlyOneChild: null as any&#125;)const hasOneShowingChild = (children:Array&lt;any&gt; = [], parent:any) =&gt; &#123; const showingChildren = children.filter(item =&gt; &#123; if (item.hidden) &#123; return false &#125; else &#123; // Temp set(will be used if only has one showing child) sidebarInfo.onlyOneChild = item return true &#125; &#125;) // When there is only one child router, the child router is displayed by default if (showingChildren.length === 1) &#123; return true &#125; // Show parent if there are no child router to display if (showingChildren.length === 0) &#123; sidebarInfo.onlyOneChild = &#123; ...parent, path: '', noShowingChildren: true &#125; return true &#125; return false&#125;/** * @param &#123;string&#125; path * @returns &#123;Boolean&#125; */const isExternal = (path:string):boolean =&gt; &#123; return /^(https?:|mailto:|tel:)/.test(path)&#125;const resolvePath = (routePath:string) =&gt; &#123; if (isExternal(routePath)) &#123; return routePath &#125; if (isExternal(props.basePath)) &#123; return props.basePath &#125; return path.resolve(props.basePath, routePath)&#125;&lt;/script&gt; &emsp;&emsp;在菜单项组件中，首先判断路由是否包含子路由，如果包含，则会循环遍历所有的子路由，否则会根据路由的性质判断是否是外部链接。 src-&gt;layout-&gt;components-&gt;Sidebar-&gt;Link.vue： 123456&lt;template&gt; &lt;!-- 动态组件 is的值是哪个组件的名称就显示哪个组件 --&gt; &lt;component :is=\"type\" v-bind=\"linkProps(props.to)\"&gt; &lt;slot /&gt; &lt;/component&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script setup lang=\"ts\"&gt;import &#123; computed, defineProps &#125; from 'vue'const props = defineProps(&#123; to: &#123; type: String, required: true &#125;&#125;)/** * @param &#123;string&#125; path * @returns &#123;Boolean&#125; */// 判断是否是外部链接const isExternal = (path:string):boolean =&gt; &#123; return /^(https?:|mailto:|tel:)/.test(path)&#125;const isExternalValue = computed(() =&gt; isExternal(props.to))// 决定组件类型const type = computed(() =&gt; &#123; if (isExternalValue.value) &#123; return 'a' &#125; return 'router-link'&#125;)const linkProps = (to:string) =&gt; &#123; if (isExternalValue.value) &#123; return &#123; href: to, target: '_blank', rel: 'noopener' &#125; &#125; return &#123; to: to &#125;&#125;&lt;/script&gt; src-&gt;layout-&gt;components-&gt;Sidebar-&gt;Item.vue： 1234567&lt;template&gt; &lt;div class=\"item-div\"&gt; &lt;!-- 图标/图片 + 标题 --&gt; &lt;img v-if=\"props.icon\" :src=\"getImageUrl(props.icon)\"&gt; &lt;span&gt;&#123;&#123; props.title &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314151617181920&lt;script setup lang=\"ts\"&gt;import &#123; defineProps &#125; from 'vue'const props = defineProps(&#123; icon: &#123; type: String, default: '' &#125;, title: &#123; type: String, default: '' &#125;&#125;)// 获取图片路径const getImageUrl = (icon:string):string =&gt; &#123; return '../../src/assets/' + icon + '.png'&#125;&lt;/script&gt; &emsp;&emsp;最后每个菜单内容由图标+标题组成。 项目实现——标准版&emsp;&emsp;在标准版中，会增加以下功能： 由于Element UI Plus系统本身提供的图标并不多，而且png图片会存在一定的失真，因此本项目使用svg管理所有的图标系统。 目前一些状态信息是存放在浏览器的localStorage中，安全性较低，本项目使用pinia管理项目中所有的信息系统。 优化全局布局组件系统，扩展功能。 全局图标系统安装1npm install svg-sprite-loader -D Svg图标组件&emsp;&emsp;在src文件夹下新建icons文件夹，用来处理全局图标系统。然后新建index.vue文件和svg文件夹，其中svg文件夹下存放所有的.svg图标文件。 src-&gt;icons-&gt;index.vue： 12345&lt;template&gt; &lt;svg :class=\"svgClass\" aria-hidden=\"true\"&gt; &lt;use :xlink:href=\"iconName\" /&gt; &lt;/svg&gt;&lt;/template&gt; 1234567891011121314151617181920212223&lt;script setup lang=\"ts\"&gt;import &#123; computed, defineProps &#125; from 'vue'const props = defineProps(&#123; iconClass: &#123; type: String, required: true &#125;, className: &#123; type: String, default: '' &#125;&#125;)const iconName = computed(() =&gt; `#icon-$&#123;props.iconClass&#125;`)const svgClass = computed(() =&gt; &#123; if (props.className) &#123; return 'svg-icon ' + props.className &#125; else &#123; return 'svg-icon' &#125;&#125;)&lt;/script&gt; 12345678910111213141516&lt;style lang=\"scss\" scoped&gt;.svg-icon &#123; /* 调整大小 */ width: 1.3em; height: 1.3em; vertical-align: -0.3em; fill: currentColor; overflow: hidden;&#125;.svg-external-icon &#123; background-color: currentColor; mask-size: cover!important; display: inline-block;&#125;&lt;/style&gt; vite配置&emsp;&emsp;在src文件夹下新建plugins，用于存放项目中的插件系统，然后新建svgBuilder.ts： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import &#123; Plugin &#125; from 'vite'import &#123; readFileSync, readdirSync, PathLike &#125; from 'fs'// 参考：https://github.com/JetBrains/svg-sprite-loader/issues/434let idPerfix = ''const svgTitle = /&lt;svg([^&gt;+].*?)&gt;/const clearHeightWidth = /(width|height)=\"([^&gt;+].*?)\"/gconst hasViewBox = /(viewBox=\"[^&gt;+].*?\")/gconst clearReturn = /(\\r)|(\\n)/gfunction findSvgFile(dir:PathLike): string[] &#123; const svgRes = [] const dirents = readdirSync(dir, &#123; withFileTypes: true &#125;) for (const dirent of dirents) &#123; if (dirent.isDirectory()) &#123; svgRes.push(...findSvgFile(dir + dirent.name + '/')) &#125; else &#123; const svg = readFileSync(dir + dirent.name) .toString() .replace(clearReturn, '') .replace(svgTitle, ($1, $2) =&gt; &#123; // console.log(++i) // console.log(dirent.name) let width = 0 let height = 0 let content = $2.replace( clearHeightWidth, (s1:unknown, s2:string, s3:number) =&gt; &#123; if (s2 === 'width') &#123; width = s3 &#125; else if (s2 === 'height') &#123; height = s3 &#125; return '' &#125; ) if (!hasViewBox.test($2)) &#123; content += `viewBox=\"0 0 $&#123;width&#125; $&#123;height&#125;\"` &#125; return `&lt;symbol id=\"$&#123;idPerfix&#125;-$&#123;dirent.name.replace( '.svg', '' )&#125;\" $&#123;content&#125;&gt;` &#125;) .replace('&lt;/svg&gt;', '&lt;/symbol&gt;') svgRes.push(svg) &#125; &#125; return svgRes&#125;export const svgBuilder = ( path: string, perfix = 'icon'): Plugin | null =&gt; &#123; if (path === '') return null idPerfix = perfix const res = findSvgFile(path) // console.log(res.length) // const res = [] return &#123; name: 'svg-transform', transformIndexHtml(html): string &#123; return html.replace( '&lt;body&gt;', ` &lt;body&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"position: absolute; width: 0; height: 0\"&gt; $&#123;res.join('')&#125; &lt;/svg&gt; ` ) &#125; &#125;&#125; &emsp;&emsp;并在vite.config.ts中配置： 123456// 引入svgBuilder插件import &#123; svgBuilder &#125; from './src/plugins/svgBuilder'export default defineConfig(&#123; plugins: [svgBuilder('./src/icons/svg/')], // 一次性添加所有的svg 无需在单独导入&#125;) &emsp;&emsp;这里如果提示不能找到该ts文件，需要在tsconfig.node.json中添加该文件： 1\"include\": [\"vite.config.ts\", \"./src/plugins/svgBuilder.ts\"] main.ts配置&emsp;&emsp;最后将其配置到main.ts中，注册组件： 1234// 引入svgimport svgIcon from '@/icons/index.vue'// 注册svg组件app.component('svg-icon', svgIcon) 使用&emsp;&emsp;例如，在全局布局组件系统中的菜单栏组件所有的图标改成svg的形式： src-&gt;layout-&gt;components-&gt;sidebar-&gt;item.vue： 12345678&lt;template&gt; &lt;div class=\"item-div\"&gt; &lt;!-- 图标/图片 + 标题 --&gt; &lt;i v-if=\"(props.icon).includes('el-icon')\" class=\"sub-el-icon\"&gt;&lt;/i&gt; &lt;svg-icon v-else :icon-class=\"props.icon\"&gt;&lt;/svg-icon&gt; &lt;span&gt;&#123;&#123; props.title &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; &emsp;&emsp;这里主要通过路由配置文件中每个路由的icon参数来选择相应的图标。(默认已经将svg图标放在src-&gt;icons-&gt;svg中。)&emsp;&emsp;注1：如果不能看到效果，需要重启项目。&emsp;&emsp;注2：iconfont图标库 全局状态系统安装1npm install pinia main.ts配置123import &#123; createPinia &#125; from 'pinia'// 使用Piniaapp.use(createPinia()) 使用&emsp;&emsp;在src目录下新建store文件夹，存放所有的状态管理文件。&emsp;&emsp;pinia样例文件： src-&gt;store-&gt;example.ts： 12345678910111213141516171819202122import &#123; defineStore &#125; from 'pinia'// 规范写法：use[name]Storeexport const useExampleStore = defineStore(&#123; // store id: 'example', state: () =&gt; (&#123; key: 'value' as string, &#125;), // getters getters: &#123; newKey() &#123; this.key = newValue &#125; &#125;, // actions actions: &#123; functionName(newValue:string) &#123; this.key = newValue &#125; &#125;&#125;) 全局布局组件系统优化增加菜单栏显示/隐藏功能&emsp;&emsp;该功能主要是实现点击切换按钮时，菜单栏会只显示图标部分，隐藏所有的文字部分，再次点击时，会恢复初始状态，且菜单栏宽度保持自适应状态。 状态管理设置&emsp;&emsp;首先在src-&gt;store文件夹中，新建app.ts，用于存放当前设备的状态。 src-&gt;store-&gt;app.ts： 1234567891011121314151617181920212223242526272829import &#123; defineStore &#125; from 'pinia'// npm install js-cookie --saveimport Cookies from 'js-cookie'export const useAppStore = defineStore(&#123; id: 'app', state: () =&gt; (&#123; sidebar: &#123; // !!:转为布尔值 // 保存当前菜单栏显示和隐藏的状态 opened: Cookies.get('sidebarStatus') ? !!Cookies.get('sidebarStatus') : true as boolean, withoutAnimation: false as boolean &#125;, device: 'desktop' as string &#125;), actions: &#123; // 控制菜单栏显示和隐藏的切换 toggleSideBar() &#123; this.sidebar.opened = !this.sidebar.opened this.sidebar.withoutAnimation = false if (this.sidebar.opened) &#123; Cookies.set('sidebarStatus', 1) &#125; else &#123; Cookies.set('sidebarStatus', 0) &#125; &#125; &#125;&#125;) 切换组件实现&emsp;&emsp;然后在src文件夹中新建components文件夹，该文件夹主要存放非页面级的组件。&emsp;&emsp;在该文件夹下新建控制菜单栏显示切换的图标组件： src-&gt;components-&gt;Hamburger-&gt;index.vue： 123456789101112131415&lt;template&gt; &lt;div style=\"padding: 0 15px;\" @click=\"toggleClick\"&gt; &lt;!-- svg图标 --&gt; &lt;svg :class=\"&#123;'is-active':props.isActive&#125;\" class=\"hamburger\" viewBox=\"0 0 1024 1024\" xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"64\" &gt; &lt;path d=\"M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM142.4 642.1L298.7 519a8.84 8.84 0 0 0 0-13.9L142.4 381.9c-5.8-4.6-14.4-.5-14.4 6.9v246.3a8.9 8.9 0 0 0 14.4 7z\" /&gt; &lt;/svg&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819&lt;script setup lang=\"ts\"&gt;import &#123; defineProps, defineEmits &#125; from 'vue'const props = defineProps(&#123; isActive: &#123; type: Boolean, default: false &#125;&#125;)// 获取父组件函数const emit = defineEmits(['toggleClick'])// 切换按钮const toggleClick = () =&gt; &#123; emit('toggleClick')&#125;&lt;/script&gt; 导航栏组件调整&emsp;&emsp;Hamburger组件主要是存放在导航栏组件的左侧，菜单栏组件的右侧，因此在父组件导航栏组件中，引入该图标组件： src-&gt;layout-&gt;components-&gt;Narbar.vue： 123456&lt;!-- 控制菜单栏的显示 --&gt;&lt;hamburger id=\"hamburger-container\" :is-active=\"sidebar.opened\" class=\"hamburger-container\" @toggleClick=\"toggleSideBar\" /&gt; 1234567891011121314import Hamburger from '@/components/Hamburger/index.vue'import &#123; computed, reactive &#125; from 'vue'import &#123; useAppStore &#125; from '@/store/app'const appStore = useAppStore()const sidebar = computed(() =&gt; appStore.sidebar)// 侧边栏控制const toggleSideBar = () =&gt; &#123; appStore.toggleSideBar()&#125; &emsp;&emsp;注：这里只显示和之前代码有变化的部分，下同。 菜单栏组件调整&emsp;&emsp;首先将Logo.vue组件设置为根据collapse状态控制是否显示标题： src-&gt;layout-&gt;components-&gt;Sidebar-&gt;Logo.vue： 12345678910111213141516&lt;template&gt; &lt;div class=\"sidebar-logo-container\" :class=\"&#123;'collapse':collapse&#125;\"&gt; &lt;!-- 跳转到首页 --&gt; &lt;transition name=\"sidebarLogoFade\"&gt; &lt;!-- 根据collapse控制Logo组件，即是否显示标题 --&gt; &lt;router-link v-if=\"collapse\" key=\"collapse\" class=\"sidebar-logo-link\" to=\"/\"&gt; &lt;img v-if=\"logoInfo.logo\" :src=\"logoInfo.logo\" class=\"sidebar-logo\"&gt; &lt;h1 v-else class=\"sidebar-title\"&gt;&#123;&#123; logoInfo.title &#125;&#125; &lt;/h1&gt; &lt;/router-link&gt; &lt;router-link v-else key=\"expand\" class=\"sidebar-logo-link\" to=\"/\"&gt; &lt;img v-if=\"logoInfo.logo\" :src=\"logoInfo.logo\" class=\"sidebar-logo\"&gt; &lt;h1 class=\"sidebar-title\"&gt;&#123;&#123; logoInfo.title &#125;&#125; &lt;/h1&gt; &lt;/router-link&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt; 12345678import &#123; defineProps, reactive &#125; from 'vue'defineProps(&#123; collapse: &#123; type: Boolean, require: true &#125;&#125;) &emsp;&emsp;使用v-if和v-else指令，结合传入的collapse状态值，实时切换是否显示标题文字。&emsp;&emsp;然后修改Logo.vue的父组件index.vue，将状态管理中的sidebar值实时传递给Logo.vue组件： 12&lt;!-- 左上角图标 --&gt;&lt;logo :collapse=\"isCollapse\"/&gt; 1234567import &#123; computed &#125; from 'vue'import &#123; useAppStore &#125; from '@/store/app'const appStore = useAppStore()const isCollapse = computed(() =&gt; !appStore.sidebar.opened) &emsp;&emsp;菜单选项组件的显示和隐藏主要通过样式来控制(src-&gt;style-&gt;sidebar.module.scss)。 增加导航栏面包屑功能&emsp;&emsp;该功能主要实现在导航栏上实时显示当前路由的地址，如果是嵌套路由则会根据嵌套规则显示完整的路由地址，并且点击相应的路由标题时，会切换到相应的界面。 面包屑组件实现&emsp;&emsp;在src-&gt;compnents目录下新建Hamburger-&gt;index.vue组件，实现面包屑功能： 1234567891011121314&lt;template&gt; &lt;el-breadcrumb class=\"app-breadcrumb\" separator=\"/\"&gt; &lt;transition-group name=\"breadcrumb\"&gt; &lt;!-- 面包屑组件 --&gt; &lt;el-breadcrumb-item v-for=\"(item,index) in breadcrumbInfo.levelList\" :key=\"item.path\"&gt; &lt;span v-if=\"item.redirect==='noRedirect'||index==breadcrumbInfo.levelList.length-1\" class=\"no-redirect\"&gt; &#123;&#123; item.meta.title &#125;&#125;&lt;/span&gt; &lt;a v-else @click.prevent=\"handleLink(item)\"&gt;&#123;&#123; item.meta.title &#125;&#125;&lt;/a&gt; &lt;/el-breadcrumb-item&gt; &lt;/transition-group&gt; &lt;/el-breadcrumb&gt;&lt;/template&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;script setup lang=\"ts\"&gt;// npm install path-to-regexpimport * as pathToRegexp from 'path-to-regexp'import &#123; reactive, watch &#125; from 'vue'import &#123; useRoute, useRouter, RouteRecordRaw &#125; from 'vue-router'const route = useRoute()const router = useRouter()const breadcrumbInfo = reactive(&#123; levelList: [] as Array&lt;RouteRecordRaw&gt; | any&#125;)// 监测当前的路由变化watch(route, () =&gt; &#123; // if you go to the redirect page, do not update the breadcrumbs if (route.path.startsWith('/redirect/')) &#123; return &#125; // 更新面包屑路由 getBreadcrumb()&#125;)const getBreadcrumb = () =&gt; &#123; // 只显示含有 meta.title 属性的路由 let matched:Array&lt;any&gt; = route.matched.filter(item =&gt; item.meta &amp;&amp; item.meta.title) const first = matched[0] // 如果不是首页，则加上首页的面包屑 if (!isDashboard(first)) &#123; matched = [&#123; path: '/dashboard', meta: &#123; title: '首页' &#125;&#125;].concat(matched) &#125; // 再次过滤 满足指定条件 breadcrumbInfo.levelList = matched.filter(item =&gt; item.meta &amp;&amp; item.meta.title &amp;&amp; item.meta.breadcrumb !== false)&#125;// 判断是否是首页路由const isDashboard = (route:RouteRecordRaw) =&gt; &#123; const name = route &amp;&amp; route.name as string if (!name) &#123; return false &#125; return name.trim().toLocaleLowerCase() === 'Dashboard'.toLocaleLowerCase()&#125;// 点击面包屑跳转路由const handleLink = (item:RouteRecordRaw) =&gt; &#123; const &#123; redirect, path &#125; = item // 如果存在 redirect 属性(此时是嵌套路由) 则直接跳转至该路由 if (redirect) &#123; router.push(redirect as string) return &#125; // 跳转至编译后的路由 router.push(pathCompile(path))&#125;// 编译路由const pathCompile = (path:string) =&gt; &#123; // 解决带有参数的路由跳转问题 // To solve this problem https://github.com/PanJiaChen/vue-element-admin/issues/561 const &#123; params &#125; = route const toPath = pathToRegexp.compile(path) return toPath(params)&#125;// 初始化刷新路由getBreadcrumb()&lt;/script&gt; &emsp;&emsp;其主要原理就是实时监测当前路由的变化，并根据当前路由的参数遍历生成面包屑路由，并将首页路由添加至面包屑开始位置，通过点击面包屑中显示的路由标题，实现路由的切换。 导航栏组件调整&emsp;&emsp;最后将其添加至父组件导航栏组件中： src-&gt;components-&gt;Narbar.vue： 1&lt;breadcrumb id=\"breadcrumb-container\" class=\"breadcrumb-container\" /&gt; 1import Breadcrumb from '@/components/Breadcrumb/index.vue' 增加标签栏导航功能&emsp;&emsp;该功能主要实现在导航栏上保存已经访问过的路由，点击相应标签即可切换至相应路由，并且可以实现关闭其他、全部关闭路由等功能。 路由标签状态管理&emsp;&emsp;首先在src-&gt;store文件夹中，新建tagsViews.ts，用于存放已访问的路由和缓存的路由，并实现添加路由、删除路由等功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import &#123; defineStore &#125; from 'pinia'import &#123; RouteRecordRaw, RouteRecordName, RouteLocationNormalizedLoaded &#125; from 'vue-router'interface TagsViewsIF extends RouteLocationNormalizedLoaded &#123; title?: string meta: &#123; title?: string, noCache?: boolean, affix?: boolean &#125;&#125;interface AllViewsTF &#123; visitedViews: Array&lt;TagsViewsIF&gt;, cachedViews: Array&lt;RouteRecordName | null | undefined&gt;&#125;// 标签栏导航export const useTagsViewStore = defineStore(&#123; id: 'tagsView', state: () =&gt; (&#123; // 定义数据类型 // 用户访问过的页面 visitedViews: [] as Array&lt;TagsViewsIF&gt;, // 实际keep-alive的路由 cachedViews: [] as Array&lt;RouteRecordName | null | undefined&gt; &#125;), actions: &#123; // 增加导航路由 addView(view:TagsViewsIF) &#123; this.addVisitedView(view) this.addCachedView(view) &#125;, addVisitedView(view:TagsViewsIF) &#123; if (this.visitedViews.some(v =&gt; v.path === view.path)) return this.visitedViews.push( Object.assign(&#123;&#125;, view, &#123; title: view.meta.title || 'no-name' &#125;) ) &#125;, addCachedView(view:TagsViewsIF) &#123; if (this.cachedViews.includes(view.name)) return if (!view.meta.noCache) &#123; this.cachedViews.push(view.name) &#125; &#125;, // 删除导航路由 delView(view: TagsViewsIF) &#123; return new Promise&lt;AllViewsTF&gt;(resolve =&gt; &#123; this.delVisitedView(view) this.delCachedView(view) resolve(&#123; visitedViews: [...this.visitedViews], cachedViews: [...this.cachedViews] &#125;) &#125;) &#125;, delVisitedView(view: TagsViewsIF) &#123; return new Promise&lt;Array&lt;TagsViewsIF&gt;&gt;(resolve =&gt; &#123; for (const [i, v] of this.visitedViews.entries()) &#123; if (v.path === view.path) &#123; this.visitedViews.splice(i, 1) break &#125; &#125; resolve([...this.visitedViews]) &#125;) &#125;, delCachedView(view: TagsViewsIF) &#123; return new Promise&lt;Array&lt;RouteRecordName | null | undefined&gt;&gt;(resolve =&gt; &#123; const index = this.cachedViews.indexOf(view.name) index &gt; -1 &amp;&amp; this.cachedViews.splice(index, 1) resolve([...this.cachedViews]) &#125;) &#125;, delOthersViews(view: TagsViewsIF) &#123; return new Promise&lt;AllViewsTF&gt;(resolve =&gt; &#123; this.delOthersVisitedViews(view) this.delOthersCachedViews(view) resolve(&#123; visitedViews: [...this.visitedViews], cachedViews: [...this.cachedViews] &#125;) &#125;) &#125;, delOthersVisitedViews(view: TagsViewsIF) &#123; return new Promise&lt;Array&lt;TagsViewsIF&gt;&gt;(resolve =&gt; &#123; this.visitedViews = this.visitedViews.filter((v:any) =&gt; &#123; return v.meta.affix || v.path === view.path &#125;) resolve([...this.visitedViews]) &#125;) &#125;, delOthersCachedViews(view: TagsViewsIF) &#123; return new Promise&lt;Array&lt;RouteRecordName | null | undefined&gt;&gt;(resolve =&gt; &#123; const index = this.cachedViews.indexOf(view.name) if (index &gt; -1) &#123; this.cachedViews = this.cachedViews.slice(index, index + 1) &#125; else &#123; // if index = -1, there is no cached tags this.cachedViews = [] &#125; resolve([...this.cachedViews]) &#125;) &#125;, // 删除所有 delAllViews() &#123; return new Promise&lt;AllViewsTF&gt;(resolve =&gt; &#123; this.delAllVisitedViews() this.delAllCachedViews() resolve(&#123; visitedViews: [...this.visitedViews], cachedViews: [...this.cachedViews] &#125;) &#125;) &#125;, delAllVisitedViews() &#123; return new Promise&lt;Array&lt;TagsViewsIF&gt;&gt;(resolve =&gt; &#123; const affixTags = this.visitedViews.filter((tag:any) =&gt; tag.meta.affix) this.visitedViews = affixTags resolve([...this.visitedViews]) &#125;) &#125;, delAllCachedViews() &#123; return new Promise&lt;Array&lt;RouteRecordName | null | undefined&gt;&gt;(resolve =&gt; &#123; this.cachedViews = [] resolve([...this.cachedViews]) &#125;) &#125;, // 更新导航视图 updateVisitedView(view: TagsViewsIF) &#123; for (let v of this.visitedViews) &#123; if (v.path === view.path) &#123; v = Object.assign(v, view) break &#125; &#125; &#125; &#125;&#125;) 标签组件实现&emsp;&emsp;在src-&gt;layout-&gt;components下新建TagsView文件夹，并在该文件夹下新建index.vue和ScrollPane.vue。 src-&gt;layout-&gt;components-&gt;TagsView-&gt;ScrollPane.vue： 123456789&lt;template&gt; &lt;el-scrollbar ref=\"scrollContainerRef\" :vertical=\"false\" class=\"scroll-container\" @wheel.native.prevent=\"handleScroll\"&gt; &lt;slot /&gt; &lt;/el-scrollbar&gt;&lt;/template&gt; 123456789101112131415161718&lt;script setup lang=\"ts\"&gt;import &#123; computed &#125; from '@vue/reactivity'import &#123; ref &#125; from 'vue'import type &#123; ElScrollbar &#125; from 'element-plus'const scrollContainerRef:any = ref&lt;InstanceType&lt;typeof ElScrollbar&gt;&gt;()const scrollWrapper = computed(() =&gt; &#123; return scrollContainerRef.value.$refs.wrap$&#125;)// 处理鼠标滚动事件const handleScroll = (e:any) =&gt; &#123; // 超出范围时 滚动向左向右平移 const eventDelta = e.wheelDelta || -e.deltaY * 40 scrollWrapper.value.scrollLeft -= eventDelta / 4&#125;&lt;/script&gt; src-&gt;layout-&gt;components-&gt;TagsView-&gt;index.vue： 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div id=\"tags-view-container\" class=\"tags-view-container\"&gt; &lt;scroll-pane ref=\"scrollPaneRef\" class=\"tags-view-wrapper\" @scroll=\"handleScroll\"&gt; &lt;!-- :to: 点击会跳转至相应路由 --&gt; &lt;!-- click.middle.native: 按下鼠标中键关闭标签导航 --&gt; &lt;router-link v-for=\"tag in visitedViews\" ref=\"routerLinkRef\" :key=\"tag.path\" :class=\"isActive(tag) ? 'active' : '' \" :to=\"&#123; path: tag.path, query: tag.query, fullPath: tag.fullPath &#125;\" tag=\"span\" class=\"tags-view-item\" @click.middle.native=\"!isAffix(tag) ? closeSelectedTag(tag) : '' \" @contextmenu.prevent.native=\"openMenu(tag, $event)\" &gt; &#123;&#123; tag.title &#125;&#125; &lt;span v-if=\"!isAffix(tag)\" class=\"el-icon-close\" @click.prevent.stop=\"closeSelectedTag(tag)\" /&gt; &lt;/router-link&gt; &lt;/scroll-pane&gt; &lt;!-- 下拉选择框 --&gt; &lt;ul v-show=\"tagsViewInfo.visible\" :style=\"&#123; left: tagsViewInfo.left + 'px',top: tagsViewInfo.top + 'px' &#125;\" class=\"contextmenu\"&gt; &lt;li @click=\"refreshSelectedTag(tagsViewInfo.selectedTag)\"&gt;刷新&lt;/li&gt; &lt;li v-if=\"!isAffix(tagsViewInfo.selectedTag)\" @click=\"closeSelectedTag(tagsViewInfo.selectedTag)\"&gt;关闭&lt;/li&gt; &lt;li @click=\"closeOthersTags\"&gt;关闭其他&lt;/li&gt; &lt;li @click=\"closeAllTags(tagsViewInfo.selectedTag)\"&gt;关闭所有&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213&lt;script setup lang=\"ts\"&gt;import ScrollPane from './ScrollPane.vue'import &#123; nextTick, onMounted, reactive, ref, watch, getCurrentInstance, ComponentInternalInstance &#125; from 'vue'import &#123; computed &#125; from '@vue/reactivity'import &#123; useRoute, useRouter, RouteRecordRaw, RouteRecordName, RouteLocationNormalizedLoaded &#125; from 'vue-router'import &#123; useTagsViewStore &#125; from '@/store/tagsViews'import &#123; constantRoutes &#125; from '@/router/index'// 使用 path-browserify 代替 path 模块import path from 'path-browserify'const route = useRoute()const router = useRouter()const tagsViewStore = useTagsViewStore()const routerLinkRef = ref&lt;any&gt;([])const scrollPaneRef = ref()// 获取当前实例// setup执行时 组件还没有创建 无法直接获取实例const &#123; proxy &#125; = getCurrentInstance() as ComponentInternalInstanceinterface TagsViewsIF extends RouteLocationNormalizedLoaded &#123; title?: string meta: &#123; title?: string, noCache?: boolean, affix?: boolean &#125;&#125;const tagsViewInfo = reactive(&#123; visible: false, top: 0, left: 0, selectedTag: &#123;&#125; as TagsViewsIF, affixTags: [] as Array&lt;TagsViewsIF&gt;&#125;)// 访问过的路由const visitedViews = computed(() =&gt; &#123; return tagsViewStore.visitedViews&#125;)const routes = computed(() =&gt; &#123; return constantRoutes&#125;)// 监视路由变化watch(route, () =&gt; &#123; addTags()&#125;)// 监视 tagsViewInfo 对象的 visible 值watch(() =&gt; tagsViewInfo.visible, (newValue) =&gt; &#123; if (newValue) &#123; document.body.addEventListener('click', closeMenu) &#125; else &#123; document.body.removeEventListener('click', closeMenu) &#125;&#125;)// 初始化onMounted(() =&gt; &#123; initTags() addTags()&#125;)// 初始化标签const initTags = () =&gt; &#123; // 获取需要展示在标签导航中的路由(meta 的 affix 属性值为 true) const affixTags = tagsViewInfo.affixTags = filterAffixTags(routes.value) for (const tag of affixTags) &#123; // Must have tag name if (tag.name) &#123; // 存储初始化的标签 tagsViewStore.addVisitedView(tag) &#125; &#125;&#125;// 将当前路由存储至标签中const addTags = () =&gt; &#123; const &#123; name &#125; = route if (name) &#123; tagsViewStore.addView(route) &#125; return false&#125;// 判断当前路由是否处于激活状态const isActive = (currentRoute:TagsViewsIF) =&gt; &#123; return currentRoute.path === route.path&#125;// 判断标签是否固定const isAffix = (tag:TagsViewsIF) =&gt; &#123; return tag.meta &amp;&amp; tag.meta.affix&#125;// 过滤路由中含有 meta.affix 属性值的const filterAffixTags = (routes:RouteRecordRaw[], basePath = '/') =&gt; &#123; let tags:Array&lt;any&gt; = [] routes.forEach(route =&gt; &#123; // 如果路由有 meta 属性值，且 meta 的 affix 属性值为 true if (route.meta &amp;&amp; route.meta.affix) &#123; const tagPath = path.resolve(basePath, route.path) // 添加至 标签数组 中 tags.push(&#123; fullPath: tagPath, path: tagPath, name: route.name as string, meta: &#123; ...route.meta &#125; &#125;) &#125; // 如果路由有子路由 if (route.children) &#123; const tempTags = filterAffixTags(route.children, route.path) if (tempTags.length &gt;= 1) &#123; tags = [...tags, ...tempTags] &#125; &#125; &#125;) return tags&#125;// 刷新当前路由const refreshSelectedTag = (view: TagsViewsIF) =&gt; &#123; tagsViewStore.delCachedView(view).then(() =&gt; &#123; const &#123; fullPath &#125; = view nextTick(() =&gt; &#123; router.replace(&#123; path: fullPath &#125;) &#125;) &#125;)&#125;// 关闭当前路由const closeSelectedTag = (view: TagsViewsIF) =&gt; &#123; tagsViewStore.delView(view).then((&#123; visitedViews &#125;) =&gt; &#123; if (isActive(view)) &#123; toLastView(visitedViews, view) &#125; &#125;)&#125;// 关闭其他路由const closeOthersTags = () =&gt; &#123; router.push(tagsViewInfo.selectedTag) tagsViewStore.delOthersViews(tagsViewInfo.selectedTag)&#125;// 关闭所有路由const closeAllTags = (view: TagsViewsIF) =&gt; &#123; tagsViewStore.delAllViews().then((&#123; visitedViews &#125;) =&gt; &#123; if (tagsViewInfo.affixTags.some(tag =&gt; tag.path === view.path)) &#123; return &#125; toLastView(visitedViews, view) &#125;)&#125;// 定位最后一次访问的路由const toLastView = (visitedViews:Array&lt;TagsViewsIF&gt;, view: TagsViewsIF) =&gt; &#123; const latestView = visitedViews.slice(-1)[0] if (latestView) &#123; router.push(latestView.fullPath) &#125; else &#123; // now the default is to redirect to the home page if there is no tags-view, // you can adjust it according to your needs. if (view.name === 'Dashboard') &#123; // to reload home page router.replace(&#123; path: '/redirect' + view.fullPath &#125;) &#125; else &#123; router.push('/') &#125; &#125;&#125;// 右击打开标签菜单const openMenu = (tag:RouteLocationNormalizedLoaded, e:PointerEvent) =&gt; &#123; const menuMinWidth = 105 const offsetLeft = (proxy as any).$el.getBoundingClientRect().left // container margin left const offsetWidth = (proxy as any).$el.offsetWidth // container width const maxLeft = offsetWidth - menuMinWidth // left boundary const left = e.clientX - offsetLeft + 15 // 15: margin right if (left &gt; maxLeft) &#123; tagsViewInfo.left = maxLeft &#125; else &#123; tagsViewInfo.left = left &#125; tagsViewInfo.top = e.clientY tagsViewInfo.visible = true tagsViewInfo.selectedTag = tag&#125;// 关闭下拉菜单const closeMenu = () =&gt; &#123; tagsViewInfo.visible = false&#125;// 处理滚动事件const handleScroll = () =&gt; &#123; // 鼠标滚动时 关闭下拉菜单显示 closeMenu()&#125;&lt;/script&gt; &emsp;&emsp;其主要原理就是首先将访问过的路由依次显示在滚动条组件中，然后通过鼠标右击事件弹出功能菜单，并通过定义在tagsViewStore里面的功能实现相应的功能。 全局布局组件调整&emsp;&emsp;最后将其添加至父组件全局布局组件中： src-&gt;layout-&gt;index.vue： 12345&lt;div&gt; &lt;!-- 导航栏 --&gt; &lt;navbar /&gt; &lt;tags-view/&gt;&lt;/div&gt; 1import TagsView from './components/TagsView/index.vue' 项目实现——完整版参考资料 Vite + Vue3 初体验 —— Vite 篇","categories":[{"name":"Web前端开发与应用","slug":"Web前端开发与应用","permalink":"http://cxx0822.github.io/categories/Web前端开发与应用/"}],"tags":[]},{"title":"TypeScript知识点整理","slug":"TypeScript知识点整理","date":"2022-03-24T02:04:50.000Z","updated":"2022-03-30T00:57:14.239Z","comments":true,"path":"2022/03/24/typescript-zhi-shi-dian-zheng-li/","link":"","permalink":"http://cxx0822.github.io/2022/03/24/typescript-zhi-shi-dian-zheng-li/","excerpt":"","text":"","categories":[{"name":"Web前端学习笔记","slug":"Web前端学习笔记","permalink":"http://cxx0822.github.io/categories/Web前端学习笔记/"}],"tags":[]},{"title":"电脑常见问题及解决方法整理","slug":"电脑常见问题及解决方法整理","date":"2022-03-23T01:53:11.000Z","updated":"2022-03-30T00:53:43.115Z","comments":true,"path":"2022/03/23/dian-nao-chang-jian-wen-ti-ji-jie-jue-fang-fa-zheng-li/","link":"","permalink":"http://cxx0822.github.io/2022/03/23/dian-nao-chang-jian-wen-ti-ji-jie-jue-fang-fa-zheng-li/","excerpt":"","text":"Mysql无法启动 解决方法：输入mysqld --user=mysql --console查看错误日志。","categories":[{"name":"杂项","slug":"杂项","permalink":"http://cxx0822.github.io/categories/杂项/"}],"tags":[]},{"title":"学习资料网站整理","slug":"学习资料和网站整理","date":"2022-03-19T01:33:20.000Z","updated":"2022-11-23T13:25:16.591Z","comments":true,"path":"2022/03/19/xue-xi-zi-liao-he-wang-zhan-zheng-li/","link":"","permalink":"http://cxx0822.github.io/2022/03/19/xue-xi-zi-liao-he-wang-zhan-zheng-li/","excerpt":"","text":"Web前端Vue.js Vue3官网 Vue3官方学习文档 Vue3GitHub Vue3中文社区 Vue源码系列-Vue中文社区 Vue Mastery tutorials视频 Github JavaScript ECMAScript6入门 阮一峰 JavaScript教程 廖雪峰 JavaScript教程 JavaScript在线运行 30-Days-Of-JavaScript JavaScript 高级 深入理解JavaScript系列 TypeScript TypeScript入门教程 TypeScript中文手册 JS/TS在线编译 UI组件 Element UI Plus Naive UI Font Awesome iconfont JavaScript库 Thress.js中文网 Xterm.js 工具 RGB颜色表 在线ps CSS网格布局 零代码工具箱 Animate.css Web后端Java JavaGuide Spring Boot MyBatis-Plus Sa-Token redis Node.js Node.js Nest.js ROS Robot Web Tools ROS2 古月居 Git Learn Git Branching 综合网站 GitHub中文社区 印记中文——Web前端 综合整理 Road To Coding free-programming-books GitHubDaily 编程练习网站 免费学习编程 面试 web前端面试 - 面试官系列 其他 中国程序员容易发音错误的单词","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://cxx0822.github.io/categories/学习笔记/"}],"tags":[]},{"title":"JavaScript知识点整理","slug":"JavaScript知识点整理","date":"2022-03-18T15:15:06.000Z","updated":"2022-09-07T13:05:55.306Z","comments":true,"path":"2022/03/18/javascript-zhi-shi-dian-zheng-li/","link":"","permalink":"http://cxx0822.github.io/2022/03/18/javascript-zhi-shi-dian-zheng-li/","excerpt":"","text":"JavaScript简介JavaScript 实现&emsp;&emsp;完整的JavaScript实现包含以下几个部分： 核心(ECMAScript) 文档对象模型(DOM) 浏览器对象模型(BOM) &emsp;&emsp;ECMAScript只是一个语言规范的标准，而JavaScript实现了这一标准。&emsp;&emsp;文档对象模型DOM(Document Object Model)是一个应用编程接口，用于在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。&emsp;&emsp;浏览器对象模型用于支持访问和操作浏览器的窗口。 语言基础变量var let const let声明的范围是块作用域，var声明的范围是函数作用域。块作用域是函数作用域的子集。 &emsp;&emsp;var与let的区别：&emsp;&emsp;var：函数作用域；存在变量提升；可重复定义；声明的变量会作为window的属性。&emsp;&emsp;let：块级作用域；不存在变量提升（有暂时性死区）；不可重复定义；声明的变量不会作为window的属性。&emsp;&emsp;块级作用域：即在{}花括号内的域，由{ }包括，比如if{}块、for(){}块。&emsp;&emsp;函数作用域：变量在声明它们的函数体以及这个函数体嵌套的任意函数体都是有定义的。&emsp;&emsp;暂时性死区：在代码块中，在声明变量之前，该变量是不可用的。 const的行为与let基本相同，唯一的重要区别为声明变量的同时必须初始化变量。 定义和声明变量时，const优先，let次之。 数据类型&emsp;&emsp;ECMAScript变量包含两种类型的数据：原始值和引用值。&emsp;&emsp;原始值就是简单的数据类型，引用值则是由多个值构成的对象。保存原始值的变量是按值访问的，实际操作的就是存储在变量中的实际值。而引用值是保存在内存中的对象，JavaScript不允许直接访问内存位置，因此操作对象(引用值)时，实际操作的是对该对象的引用，因此保存引用值的变量是按引用访问的。 原始值&emsp;&emsp;原始值一共有6种，即Undefined、Null、Boolean、Number、String和Symbol。 引用类型集合引用类型Object 对象字面量表达式中，属性名可以是字符串或数值，数值属性会自动转换为字符串。 使用中括号可以通过变量访问属性，也可以在属性名中包括可能会导致语法错误的字符。 123456let person = &#123; 'total name': 'Cxx', 5: true&#125;console.log(person['total name']) Array from()用于将类数组结构转换为数组实例，of用于将一组参数转换为数组实例。 1234567891011console.log(Array.from('Cxx'))const a = [1, 2, 3, 4]console.log(Array.from(a, x =&gt; x ** 2))console.log(Array.of(1, 2, 3, 4, 'c', 'x', 'x'))// 输出// &gt; [\"C\",\"x\",\"x\"]// &gt; [1,4,9,16]// &gt; [1,2,3,4,\"c\",\"x\",\"x\"] 如果把一个值设置给超过数组最大索引的索引，则数组长度会自动扩展到该索引值+1。通过修改length属性，可以从数组末尾删除或添加元素。 检测一个值是否为数组：Array.isArray()。 keys()返回数组索引的迭代器，values()返回数组元素的迭代器，entries()返回索引/值对的迭代器。 12345678910const a = ['foo', 'bar']// 对象解构for (const [idx, element] of a.entries()) &#123; console.log(idx, element)&#125;// 输出// &gt; 0,foo// &gt; 1,bar 数组方法基本方法 栈方法： 12345// 接收任意数量的参数，并将其添加至数组末尾，返回数组的最新长度arrayLength = array.push(...item)// 删除数组的最后一项，并减少数组的length值，返回被删除的项deleteItem = array.pop() 队列方法： 12345// 删除数组的第一项并返回它，然后数组长度-1deleteItem = array.shift()// 在数组开头添加任意多个值，然后返回新的数组长度arrayLength = array.unshift(...item) 排序方法： 1234567891011121314151617181920212223242526// 将数组元素反向排列array = array.reverse()// 按照升序重新排列数组元素// 会先对每一项调用 String() 转换为字符串，再进行排序array = array.sort([compareFunction])// 示例const a = [0, 1, 5, 10, 15]function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1 &#125; else if (value1 &gt; value2) &#123; return 1 &#125; else &#123; return 0 &#125;&#125;console.log(a.sort())console.log(a.sort(compare))// 输出// &gt; [0,1,10,15,5]// &gt; [0,1,5,10,15] 操作方法 concat() 12345678910111213141516// 将其参数添加至副本末尾 然后返回这个新数组newArray = array.concat(item/array)// 示例const colors1 = ['red', 'green']const colors2 = ['black', 'white']console.log(colors1.concat(colors2))// 是否打平数组colors2[Symbol.isConcatSpreadable] = falseconsole.log(colors1.concat(colors2))// 输出// &gt; [\"red\",\"green\",\"black\",\"white\"]// &gt; [\"red\",\"green\",[\"black\",\"white\"]] slice()：切片 123456789101112131415// 参数：返回元素的开始索引和结束索引 返回值：对应索引的元素newArray = array.slice(startIndex, [endIndex])// 示例const colors = ['red', 'green', 'black', 'white']console.log(colors.slice(2))// 不改变原数组console.log(colors)console.log(colors.slice(1, 3))// 输出// &gt; [\"black\",\"white\"]// &gt; [\"red\",\"green\",\"black\",\"white\"]// &gt; [\"green\",\"black\"] splice()：拼接 1234567891011121314151617181920212223242526272829303132// 参数：索引值 需要删除的个数(可以为0) 需要插入的元素(可以为0)// 返回值：从数组中删除的元素deleteArray = array.splice(index, deleteNum, [insertItem])const colors = ['red', 'green', 'black', 'white']// 删除元素const deleteArray = colors.splice(0, 1)console.log(deleteArray)console.log(colors)console.log('**********')// 插入元素const insertArray = colors.splice(1, 0, 'yellow')console.log(insertArray)console.log(colors)console.log('**********')// 替换元素const replaceArray = colors.splice(1, 1, 'orange')console.log(replaceArray)console.log(colors)// 输出// &gt; [\"red\"]// &gt; [\"green\",\"black\",\"white\"]// &gt; **********// &gt; []// &gt; [\"green\",\"yellow\",\"black\",\"white\"]// &gt; **********// &gt; [\"yellow\"]// &gt; [\"green\",\"orange\",\"black\",\"white\"] 搜索方法&emsp;&emsp;indexOf()、lastIndexOf()和includes()123456789// 参数：要查找的元素，搜索位置 返回值：查找元素在数组的位置// 从第一项向后搜索index = indexOf(searchItem, [searchInedex])// 从最后一项向前搜索index = lastIndexOf(searchItem, [searchInedex])// 参数：同上 返回值：是否找到一个与指定元素匹配的项isInclude = includes(searchItem, [searchInedex]) &emsp;&emsp;自定义搜索：find()和findIndex()123456789101112131415161718192021222324// 参数：断言函数(元素、索引和数组本身) 返回值：匹配项item = array.find((element, index, array) =&gt; &#123; ... &#125;)// 参数：同上 返回值：匹配项的索引itemIndex = array.findIndex((element, index, array) =&gt; &#123; ... &#125;)// 示例const people = [ &#123; name: 'Cxx', age: 27 &#125;, &#123; name: 'Pjm', age: 25 &#125;]console.log(people.find((element, index, array) =&gt; element.age &gt; 26))console.log(people.findIndex((element, index, array) =&gt; element.age &gt; 26))// 输出// &gt; &#123;\"name\":\"Cxx\",\"age\":27&#125;// &gt; 0 迭代方法&emsp;&emsp;every()、filter()、forEarch()、map()和some()。每个方法都接收一个以每一项为参数运行的函数。该函数接收3个参数：数组元素、元素索引和数组本身。 every()：如果每一项返回true，则返回true some()：如果某一项返回true，则返回true 12345678let numbers = [1, 2, 3, 4, 5]console.log(numbers.every((item, index, array) =&gt; item &gt; 3))console.log(numbers.some((item, index, array) =&gt; item &gt; 3))// 输出// &gt; false// &gt; true filter()：返回每次函数调用的结果为true的项组成的数组 map()：返回每次函数调用的结果组成的数组 1234let numbers = [1, 2, 3, 4, 5]console.log(numbers.filter((item, index, array) =&gt; item &gt; 3))console.log(numbers.map((item, index, array) =&gt; item * 3)) forEach()：循环遍历，不返回结果123456789101112let numbers = [1, 2, 3, 4, 5]numbers.forEach((item, index, array) =&gt; &#123; console.log(index, item)&#125;)// 输出// &gt; 0,1// &gt; 1,2// &gt; 2,3// &gt; 3,4// &gt; 4,5 Map基本API&emsp;&emsp;使用new和Map构造函数就可以创建一个空映射，也可以给Map构造函数传入一个可迭代对象进行实例化。&emsp;&emsp;Map可以使用任何JavaScript数据类型作为键。&emsp;&emsp;映射实例可以提供一个迭代器，并且会维护键值对的插入顺序。1234567891011121314151617181920212223242526272829303132333435363738// 创建空映射const m = new Map()// 使用数组初始化映射const m1 = new Map([['key1', 'value1'], ['key2', 'value2']])// 使用迭代器初始化映射const m2 = new Map(&#123; [Symbol.iterator]: function* () &#123; yield ['key1', 'value1'] yield ['key2', 'value2'] &#125;&#125;)// 常用APIconsole.log(m1.has('key1')) // 查询console.log(m1.get('key3')) // 查询m1.delete('key1') // 删除某个键console.log(m1.get('key'))m1.set('key3', 'value3') // 增加某个键console.log(m1.get('key3'))m1.clear()console.log(m1.size) // 获取键值对数量console.log('**********')// Map迭代 API同迭代器for (const pair of m2.entries()) &#123; console.log(pair)&#125;// 输出// &gt; true// &gt; undefined// &gt; undefined// &gt; value3// &gt; 0// &gt; **********// &gt; [\"key1\",\"value1\"]// &gt; [\"key2\",\"value2\"] Object与Map区别 Object Map 内存占用 多 少 插入性能 差 强 查询速度 快 慢 删除性能 差 强 WeakMap 弱映射键只能是Object或者继承自Object的类型。 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的，不能遍历。 Set基本API123456789101112131415161718192021222324252627282930313233343536// 创建空映射const s = new Set()// 使用数组初始化映射const s1 = new Set(['value1', 'value2'])// 使用迭代器初始化映射const s2 = new Set(&#123; [Symbol.iterator]: function* () &#123; yield 'value1' yield 'value2' &#125;&#125;)// 常用APIconsole.log(s1.has('value1')) // 查询s1.delete('value1') // 删除某个值console.log(s1.has('value1'))s1.add('value3') // 增加某个值console.log(s1.has('value3'))s1.clear()console.log(s1.size) // 获取元素数量console.log('**********')// Set迭代 API同迭代器for (const value of s2.values()) &#123; console.log(value)&#125;// 输出// &gt; true// &gt; false// &gt; true// &gt; 0// &gt; **********// &gt; value1// &gt; value2 WeakSet 成员只能是Object或者继承自Object的类型。 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏。 不能遍历。 总结&emsp;&emsp;Map是键-值对，Set是值-值对。 迭代器与生成器迭代器迭代器概念&emsp;&emsp;可迭代对象：实现了正式的Iterable接口，而且可以通过迭代器Iterator消费。&emsp;&emsp;实现Iterable接口：需要同时具备支持迭代的自我识别能力和创建实现Iterator接口的对象的能力。(也即必须暴露一个Symbol.iterator属性作为默认迭代器)&emsp;&emsp;迭代器：是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现Iterable接口的对象都有一个Symbol.iterator属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器工厂，也是一个函数，调用之后就会产生一个实现Iterator接口的对象。&emsp;&emsp;迭代器是按需创建的一次性对象，每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的API。&emsp;&emsp;实现Symbol.iterator方法的对象就是可迭代对象，该方法返回一个迭代器。实现了next方法的对象就是迭代器。可迭代对象和迭代器可以合并为一个对象，即同时实现Symbol.iterator和next方法。&emsp;&emsp;可迭代对象是按一定规则建立好的对象(函数或者其他)，迭代器则是需要的时候实例化即可，每个迭代器都拥有一定的API。 迭代器使用&emsp;&emsp;接收可迭代对象的原生语言特性：&emsp;&emsp;1.for-of循环 2.数组解构 3.扩展操作符 4.Array.from() 5.创建集合 6.创建映射 7.yield*操作符，在生成器中使用。&emsp;&emsp;迭代器API使用next()在可迭代对象中遍历数据，返回done(true/false)和value值。&emsp;&emsp;只要迭代器到达done:true状态，后续调用next()就一直返回同样的值。不同迭代器的实例相互之间没有联系，只会独立遍历可迭代对象。如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化。 原生可迭代对象类型的迭代器123456let arr = ['foo', 'bar']// arr[Symbol.iterator] 是迭代器工厂函数// 调用该函数即可生成 迭代器let iter = arr[Symbol.iterator]()console.log(iter.next()) &emsp;&emsp;实现Iterable接口的内置类型：&emsp;&emsp;1.字符串 2.数组 3.映射 4.集合 5.arguments对象 6.NodeList等DOM集合类型 自定义迭代器&emsp;&emsp;在函数/对象中实现next()接口即可构成迭代器，但此时只能调用迭代器API，无法使用可迭代对象的特性，如for-of循环。12345678910111213141516171819202122232425262728293031323334353637383940414243function makeRangeIterator(start = 0, end = Infinity, step = 1) &#123; let nextIndex = start; let iterationCount = 0; const rangeIterator = &#123; // 实现 next 方法 next: function() &#123; let result; if (nextIndex &lt; end) &#123; result = &#123; value: nextIndex, done: false &#125; nextIndex += step; iterationCount++; // 必须返回 value done 结构的对象 return result; &#125; return &#123; value: iterationCount, done: true &#125; &#125; &#125;; return rangeIterator;&#125;// 调用迭代器函数let iterator = makeRangeIterator(1, 10, 2);// 可以使用迭代器APIlet result = iterator.next();while (!result.done) &#123; console.log(result.value); result = iterator.next();&#125;// 无法使用可迭代对象的特性for (let it of iterator) &#123; console.log(it)&#125;// 输出// 1// 3// 5// 7// 9// Uncaught TypeError: iterator is not iterable 自定义可迭代对象&emsp;&emsp;如果需要使用可迭代对象的特性，则需将其改为对象模式，并实现Symbol.iterator属性。可以使用class构造，也可以使用对象字面量的形式：12345678910111213141516171819202122232425262728293031323334353637class Counter &#123; constructor(limit) &#123; this.limit = limit &#125; // 实现 Symbol.iterator 属性 [Symbol.iterator]() &#123; let count = 1, limit = this.limit // 需要在该属性中返回一个迭代器 // 也即需要实现 next 方法 return &#123; // 实现 next 方法 next() &#123; if (count &lt;= limit) &#123; // 返回 done 和 value 属性值 return &#123; done: false, value: count++ &#125; &#125; else &#123; return &#123; done: true &#125; &#125; &#125; &#125; &#125;&#125;let counter1 = new Counter(5)for (let i of counter1) &#123; console.log(i)&#125;// 输出// &gt; 1// &gt; 2// &gt; 3// &gt; 4// &gt; 5 &emsp;&emsp;这里使用闭包(将next()方法放在了return语句中，并且在实例化时，仍然可以访问count变量)保存了count变量，使得可以同时创建多个迭代器。 123456789101112131415161718192021222324252627282930313233let makeRangeIterator = &#123; [Symbol.iterator]() &#123; start = 1, end = 10, step = 2 let nextIndex = start; let iterationCount = 0; const rangeIterator = &#123; next: function() &#123; let result; if (nextIndex &lt; end) &#123; result = &#123; value: nextIndex, done: false &#125; nextIndex += step; iterationCount++; return result; &#125; return &#123; value: iterationCount, done: true &#125; &#125; &#125;; return rangeIterator; &#125;&#125;for (let it of makeRangeIterator) &#123; console.log(it)&#125;// 输出// 1// 3// 5// 7// 9 生成器生成器概念&emsp;&emsp;在函数名称前面加上星号(*)表示它是一个生成器(箭头函数不能用来定义生成器函数)，调用生成器函数会产生一个生成器对象。&emsp;&emsp;生成器对象内部实现了Iterator接口，一开始处于暂停执行状态，调用next()方法可以让生成器开始或恢复执行。&emsp;&emsp;next()方法中的value属性是生成器函数的返回值，生成器函数只会在初次调用next()方法后开始执行。&emsp;&emsp;使用生成器可以快速的构造迭代器，只需要在内部编写逻辑即可：&emsp;&emsp;例如将之前的示例改为使用生成器构造：123456789101112131415161718192021function* makeRangeIterator(start = 0, end = Infinity, step = 1) &#123; for (let i = start; i &lt; end; i += step) &#123; yield i; &#125;&#125;let iterator = makeRangeIterator(1, 10, 2)// 可以使用迭代器APIconsole.log(iterator.next())// 可以使用可迭代对象的特性for (let it of iterator) &#123; console.log(it)&#125;// 输出// &#123;value: 1, done: false&#125;// 3// 5// 7// 9 yield关键字&emsp;&emsp;yield关键字可以让生成器停止和开始执行。生成器函数在遇到yield关键字之前会正常执行，遇到之后会停止，函数作用域会保留，调用next()后会恢复执行。通过yiel关键字退出的生成器函数会处在done:false状态，通过return关键字退出的生成器会处在done:true状态。&emsp;&emsp;yield关键字必须只能位于生成器函数中定义。12345678910111213141516function* generatorFn() &#123; yield 'foo' yield 'bar' return 'baz'&#125;let generatorObject = generatorFn()console.log(generatorObject.next())console.log(generatorObject.next())console.log(generatorObject.next())// 输出// &gt; &#123;\"value\":\"foo\",\"done\":false&#125;// &gt; &#123;\"value\":\"bar\",\"done\":false&#125;// &gt; &#123;\"value\":\"baz\",\"done\":true&#125; 生成器应用1234567891011121314151617181920212223242526272829303132333435363738394041// 生成器对象作为可迭代对象function* generatorFn1() &#123; yield 1 yield 2 yield 3&#125;// 使用星号增强yieldfunction* generatorFn2() &#123; yield* [1, 2, 3]&#125;// 生成器作为默认迭代器class Foo &#123; constructor() &#123; this.values = [1, 2, 3] &#125; // 定义为生成器函数 *[Symbol.iterator] () &#123; yield* this.values &#125;&#125;for (const x of generatorFn1()) &#123; console.log(x)&#125;for (const x of generatorFn2()) &#123; console.log(x)&#125;const f = new Foo()for (const x of f) &#123; console.log(x)&#125;// 输出值均相同// &gt; 1// &gt; 2// &gt; 3 总结&emsp;&emsp;实现[Symbol.iterator]属性的对象就是可迭代对象，可迭代对象就可以使用for-of等原生的语言特性，实现next()方法的就是迭代器，就可以使用相应的API。在函数名称前加上*就是生成器，生成器内部实现了迭代器的接口，因此也可以使用迭代器的API，但同时也具有yield等特殊特性。&emsp;&emsp;创建迭代器的方法有以下几种： 使用原生具体可迭代对象性质的数据类型，如: 123const str = 'abc'const strIterator = str[Symbol.iterator]()console.log(strIterator.next()) 自定义具有[Symbol.iterator]属性和next()方法的对象/函数。 使用生成器 &emsp;&emsp;本质上相对于可以自定义数据类型，创建具有类似于数组功能的数据结构，使用更改灵活。 参考资料 ES6中的迭代器(Iterator)和生成器(Generator) 对象、类&emsp;&emsp;对象为一组属性的无序集合，可以将其想象为一张散列表，其中内容就是一组名/值对，值可以是数据或者函数。 对象属性&emsp;&emsp;为对象的数据添加一些额外的属性效果，可以使用Object.defineProperty(Object, keyName, options)定义，也可以同时定义多个(使用Object.definePropertys(Object, options))。&emsp;&emsp;使用Object.getOwnPropertyDescriptor(Object, keyName)可以查看指定属性的描述符，也可以使用Object.getOwnPropertyDescriptors(Object)查看所有的属性描述符。123456789101112131415161718192021222324252627282930// 定义对象，包含一个直接定义在对象上的属性let book = &#123;year_: 2017&#125;// 添加对象属性Object.defineProperties(book, &#123; edition: &#123; // 数据属性 value: 1 &#125;, year: &#123; // 访问器属性 // 获取函数 在读取属性时调用 get() &#123; return this.year_ &#125;, // 设置函数 在写入属性时调用 set(newValue) &#123; if (newValue &gt; 2017) &#123; this.year_ = newValue &#125; &#125; &#125;&#125;)// 打印对象属性信息console.log(Object.getOwnPropertyDescriptors(book))const descriptor = Object.getOwnPropertyDescriptor(book, \"year\")// 打印访问器属性，注意这里是属性，不能使用函数调用()console.log(typeof descriptor.get) &emsp;&emsp;输出结果：12345678910111213141516171819202122232425&#123; \"year_\": &#123; // 直接定义在对象上的属性特性默认为true // 属性实际值 \"value\": 2017, // 属性的值是否可以被修改 \"writable\": true, // 属性的值是否可以被枚举，即可以通过 for-in 返回 \"enumerable\": true, // 属性的值是否可以被配置 \"configurable\": true &#125;, \"edition\": &#123; \"value\": 1, \"writable\": false, \"enumerable\": false, \"configurable\": false &#125;, \"year\": &#123; \"enumerable\": false, \"configurable\": false &#125;&#125; \"function\" ES6增强的对象语法1234567891011121314151617181920212223242526272829let name = 'cxx'const ageKey = 'age'let person = &#123; // 属性值简写 相当于 name:name name, // 可计算属性 []表示对象的属性键将其作为表达式运算 [ageKey]: 18, job: 'engineer', // 方法名简写 相当于 sayName: function()&#123;&#125; sayName() &#123; console.log(name) &#125;, get name() &#123; return `My name is $&#123;name&#125;` &#125;&#125;console.log(person.name)person.sayName()// 对象解构let &#123; job &#125; = personconsole.log(job)// 输出&gt; My name is cxx&gt; cxx&gt; engineer 创建对象Object构造函数12345678let person = new Object()person.name = 'Cxx'person.age = 18person.job = 'Software Engineer'person.sayName = function() &#123; console.log(this.name)&#125; 对象字面量12345678let person = &#123; name: 'Cxx', age: 18, job: 'Software Engineer', sayName() &#123; console.log(this.name) &#125;&#125; &emsp;&emsp;以上两种方式创建对象比较方便，但是无法创建具有同样接口的多个对象。 工厂模式123456789101112131415function createPerson(name, age, job) &#123; let o = new Object() o.name = name o.age = age o.job = job o.sayName = function() &#123; console.log(this.name) &#125; return o&#125;let person1 = createPerson('cxx1', 18, \"Student\")let person2 = createPerson('cxx2', 17, \"Student\") &emsp;&emsp;可以解决创建多个类似对象的问题，但是无法确定新创建对象的类型。 构造函数模式1234567891011121314151617181920212223242526272829function Person(name, age, job) &#123; this.name = name this.age = age this.job = job this.sayName = function() &#123; console.log(this.name) &#125;&#125;let person1 = new Person('cxx1', 18, \"Student\")let person2 = new Person('cxx2', 17, \"Student\")console.log(person1.constructor)console.log(person1.__proto__)console.log(person1.prototype)console.log('----------------')console.log(Person.constructor)console.log(Person.__proto__)console.log(Person.prototype)// 输出&gt; function Person(name, age, job) &#123; this.name = name this.age = age this.job = job this.sayName = function() &#123; console.log(this.name) &#125; &#125;&gt; &#123;&#125;&gt; undefined&gt; ----------------&gt; function Function() &#123; [native code] &#125;&gt; function () &#123; [native code] &#125;&gt; &#123;&#125; &emsp;&emsp;这里使用了构造函数(Person())来代替之前的工厂函数。&emsp;&emsp;同时使用new操作符来创建Person的实例，以这种方式创建时，会执行以下步骤： 在内存重创建一个新实例对象。(即person1和person2) 在新实例对象内部的[[Prototype]](也即__proto__属性)特性被赋值为构造函数的prototype属性。(即函数的prototype属性等于实例对象的__proto__属性：Person.prototype === person1.__proto__) 构造函数内部的this被赋值为这个新的实例对象。(this指向新对象，即运行时赋值，this.name即新实例对象的name) 执行构造函数内部的代码。(给新的实例对象添加属性和方法) 如果构造函数返回非空对象，则返回改对象，否则，返回刚创建的对象。 &emsp;&emsp;这里需要记住2点：①__proto__和constructor属性是对象所独有的；②prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。&emsp;&emsp;constructor属性是用来标识对象类型的，始终指向创建当前对象的构造函数。&emsp;&emsp;任何函数只要使用new操作符调用就是构造函数。&emsp;&emsp;然而使用构造函数创建对象仍然存在问题，因为在JavaScript中，函数也是对象。因此在创建sayName()函数时，本质上相当于：1234567891011121314function Person(name, age, job) &#123; this.name = name this.age = age this.job = job this.sayName = new Function(console.log(this.name))&#125;let person1 = new Person('cxx1', 18, \"Student\")let person2 = new Person('cxx2', 17, \"Student\")console.log(person1.sayName === person2.sayName)// 输出&gt; false &emsp;&emsp;因为此时每个Person实例都会有自己的Function实例，所以这2个同名函数实际上并不相等。 原型模式&emsp;&emsp;每个函数都会创建一个prototype属性，该属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法，这个对象也是通过调用构造函数创建的对象的原型。1234567891011121314151617function Person() &#123;&#125;Person.prototype.name = 'Cxx'Person.prototype.age = 18Person.prototype.job = 'Software Engineer'Person.prototype.sayName = function() &#123; console.log(this.name)&#125;let person1 = new Person()let person2 = new Person()console.log(person1.sayName === person2.sayName)// 输出&gt; true &emsp;&emsp;所有的属性和方法都直接添加到Person的prototype属性上了，使用这种原型模式定义的属性和方法是由所有的实例对象共享的。 深入理解原型&emsp;&emsp;在JavaScript中，只要创建了一个函数，就会按照特定的规则为这个函数创建一个prototype属性(指向原型对象)。所有的原型对象自动获得一个名为constructor的属性，指回与之关联的构造函数。&emsp;&emsp;在自定义构造函数时，原型对象默认只会获得constructor属性，其他的所有方法都继承自Object(本例中的其他方法是在后面自定义的)。每次调用构造函数会创建一个新实例对象，这个实例对象的内部[[Prototype]]指针就会被赋值为构造函数的原型对象(大部分浏览器将这个指针定义为实例对象上的__proto__属性)。通过这个属性就可以访问对象的原型。&emsp;&emsp;因此，实例对象通过__proto__可以链接到原型对象，它实际上指向隐藏特性[[Prototype]]，构造函数通过Prototype属性链接到原型对象。实例对象与构造函数原型之间有直接的联系，但实例对象与构造函数之间没有关系。&emsp;&emsp;在通过对象访问属性时，如果没有找到这个属性，则搜索会沿着指针进入原型对象。只要给对象实例添加一个属性，这个属性就会遮蔽原型对象上的同名属性。&emsp;&emsp;只要通过对象可以访问属性或方法，in操作符就返回true(例&#39;name&#39; in person1)，而hasOwnProperty()只有属性存在于实例上才返回true。 &emsp;&emsp;附：参考资料： 帮你彻底搞懂JS中的prototype、proto与constructor（图解） JS中prototype介绍 对象迭代&emsp;&emsp;Object.values()返回对象值的数组，Object.entries()返回键值对的数组。 注意事项1234567891011121314151617181920212223242526272829303132333435363738394041424344function Person() &#123;&#125;Person.prototype = &#123; name: 'Cxx', age: 18, job: 'Software Engineer', sayName() &#123; console.log(this.name) &#125; &#125;// 以字面量形式定义原型对象时，需要恢复 constructor 属性// 且将其设置为不可枚举Object.defineProperty(Person.prototype, 'constructor', &#123; enumerable: false, value: Person&#125;)let friend = new Person()// 可以在原型对象上添加属性和方法// 但不推荐在原生的原型对象上添加// 可以创建一个自定义类 使其继承原生类型Person.prototype.sayHi = function() &#123; console.log('hi')&#125;friend.sayHi()// 输出// &gt; hi// 重写整个原型会切断最初原型与构造函数的联系// 但实例对象引用的仍然是最初的原型// 因此下面的`sayHello()`调用会报错Person.prototype = &#123; sayHello() &#123; console.log('hello') &#125; &#125;friend.sayHello()// 输出// &gt; Uncaught TypeError: friend.sayHello is not a function &emsp;&emsp;通过原型模式创建对象也存在问题： 弱化了向构造函数传递初始化参数的能力 所有实例对象可以共享原型对象的属性和方法 继承&emsp;&emsp;构造函数、原型对象和实例对象之间的关系：每个构造函数都有一个原型对象，原型对象有一个属性指回构造函数，而实例有一个内部指针指向原型对象。&emsp;&emsp;原型链：通过将原型对象赋值为另一个类型的实例。123456789101112131415161718192021222324function SuperType() &#123; this.property = true&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property&#125;function SubType() &#123; this.subproperty = false&#125;// 继承 SuperType// 将原型对象赋值为另一个类型的实例SubType.prototype = new SuperType()SubType.prototype.getSubValue = function() &#123; return this.subproperty&#125;let instance = new SubType()// 访问继承的方法console.log(instance.getSuperValue()) &emsp;&emsp;通过继承，SubType的实例不仅能从SuperType的实例中继承属性和方法，而且还与SuperType的原型挂钩，同时也可以扩展原型搜索机制，搜索原型的原型。&emsp;&emsp;所有的引用类型都继承自Object，任何函数的默认原型都是一个Object的实例对象。&emsp;&emsp;子类需要覆盖或者添加父类的方法时，必须在原型赋值之后再添加到原型上。&emsp;&emsp;以对象字面量形式创建原型方法会破坏之前的原型链，相当于重写了原型链。 类&emsp;&emsp;类是ES6新的基础性语法糖结构，本质上仍是原型和构造函数的概念。 基础知识1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 表达式声明const Animal = class &#123;&#125;// 类就是一种特殊函数console.log(typeof Animal)console.log('----------')// 输出// &gt; function// 类声明class Person1 &#123; constructor(name) &#123; console.log(arguments.length) &#125;&#125;// 如果不需要参数，类名后面的括号可以省略let p1 = new Person1console.log(p1.name)console.log('----------')// 输出// &gt; 0// &gt; undefinedclass Person2 &#123; constructor(override) &#123; this.foo = 'foo' if (override) &#123; // 默认返回 this 对象 // 也可以返回其他对象 return &#123; bar: 'bar' &#125; &#125; &#125;&#125;let p2 = new Person2(true)console.log(p2)console.log('----------')// 输出// &gt; &#123;\"bar\":\"bar\"&#125;class Person3 &#123; constructor() &#123; // 添加到 this 的所有内容都会存在于不同的实例上 this.locate = () =&gt; &#123; console.log('instance') &#125; &#125; // 定义在类的原型对象上 locate() &#123; console.log('prototype') &#125; // 定义在类本身上 static locate() &#123; console.log('class') &#125;&#125;let p3 = new Person3()p3.locate()Person3.prototype.locate()Person3.locate()// 输出// &gt; instance// &gt; prototype// &gt; class &emsp;&emsp;类可以包括构造函数方法、实例方法、获取函数、设置函数和静态类方法。&emsp;&emsp;constructor关键字用于在类定义块内部创建类的构造函数，在使用new操作符创建类的实例时，会调用该函数。&emsp;&emsp;在JavaScript中，类就是一种特殊的函数，因此类也有prototype属性，该原型对象也有一个constructor属性指向类本身。&emsp;&emsp;类是JavaScript的一等公民，也可以像其他对象或函数引用一样把类作为参数传递。&emsp;&emsp;每个实例都对应一个唯一的成员对象，所有成员都不会在原型上共享。 继承&emsp;&emsp;ES6类支持单继承，使用extends关键字。类和原型上定义的方法都会被带到派生类。 Super关键字12345678910111213141516171819202122232425262728293031323334353637class Vehicle &#123; constructor() &#123; this.hasEngine = true &#125; print() &#123; console.log(this.hasEngine) &#125; static identify() &#123; console.log('vehicle') &#125;&#125;// extends 继承class Bus extends Vehicle &#123; constructor() &#123; // 调用父类构造函数 // super 作为函数调用 super() // 调用父类原型对象上的方法 // super 作为对象调用 super.print() &#125; static identify() &#123; // 调用父类的静态方法 指向父类 super.identify() &#125;&#125;const bus = new Bus()Bus.identify()// 输出// &gt; true// &gt; vehicle &emsp;&emsp;super既可以当函数使用，也可以当对象使用。子类的构造函数必须执行一次super函数。&emsp;&emsp;不能单独引用super关键字，不能在调用super()之前引用this。 函数&emsp;&emsp;函数实际上也是对象，每个函数都是Function类型(属于引用类型)的实例。Function也有属性和方法。&emsp;&emsp;JavaScript引擎在任何代码执行前，会先读取函数的声明。 箭头函数&emsp;&emsp;箭头函数不能使用arguments、super和new.target，也不能用作构造函数，箭头函数也没有prototype属性。 函数名&emsp;&emsp;函数名就是指向函数的指针，一个函数可以拥有多个名称。使用不带括号的函数名会访问函数指针，而不会执行函数。&emsp;&emsp;ES6中所有的函数对象都会暴露一个只读的name属性，包含函数的信息。 函数参数12345678910111213141516171819202122// 扩展运算符收集参数function doAdd(num = 5, ...nums) &#123; if (arguments.length === 1) &#123; console.log(num) &#125; else if (arguments.length === 2) &#123; // 此时 num 默认值会被覆盖 console.log(num) console.log(arguments[0]) // 其他参数被收集到 nums 中 console.log(nums) &#125;&#125;let values = [1, 2]// 扩展运算符传值doAdd(...values)// 输出// &gt; 1// &gt; 1// &gt; [2] &emsp;&emsp;在JavaScript中，函数参数只是为了方便写出来，并不是必须写出来，并没有验证命名参数的机制，因此传递任意数量的参数都是可以的。&emsp;&emsp;arguments对象是一个类数组对象，存放着函数的参数信息。ES6中可以显示定义默认参数。函数的默认参数只有在函数调用时才会求值，不会在函数定义时求值。&emsp;&emsp;使用扩展运算符在收集参数时，只能把它作为最后一个参数。 函数内部this&emsp;&emsp;在标准函数中，this引用的是把函数当成方法调用的上下文对象，在箭头函数中，this引用的是定义箭头函数的上下文。12345678910111213141516171819function King () &#123; this.royaltyName = 'Henry', console.log(this.royaltyName) setTimeout(() =&gt; &#123; console.log(this.royaltyName) &#125;, 1000) setTimeout(function() &#123; console.log(this.royaltyName) &#125;, 1000)&#125;new King()// 输出// &gt; Henry// &gt; Henry// &gt; undefined &emsp;&emsp;在利用函数创建类时，如果使用普通函数，则无法访问到内部的this值(此时作用域位于Window)。 函数方法&emsp;&emsp;函数除了可以使用函数名+()的形式调用，也可以使用apply()和call()方法调用，这2个方法的第一个参数均可以指定函数内部的this，调用apply()方法时，传入的参数需要为一个数组，而调用call()方法时，需要将参数一一列出。12345678910111213141516171819202122232425262728293031323334353637window.color = 'red'let o = &#123; color: 'blue'&#125;function sayColor(a, b) &#123; console.log(a, b) console.log(this.color)&#125;// 正常调用的 this 为 Window对象sayColor(1, 2)console.log('**********')// 第2个参数为数组形式sayColor.apply(window, [1, 2])sayColor.apply(o, [1, 2])console.log('**********')// 需要将参数一一列出sayColor.call(window, 1, 2)sayColor.call(o, 1, 2)// 输出// &gt; 1,2// &gt; red// &gt; **********// &gt; 1,2// &gt; red// &gt; 1,2// &gt; blue// &gt; **********// &gt; 1,2// &gt; red// &gt; 1,2// &gt; blue 函数作为值&emsp;&emsp;可以把函数作为参数传给另一个函数，也可以在一个函数中返回另一个函数。(实际上就是把函数名当指针使用) 闭包&emsp;&emsp;闭包指的是引用了另一个函数作用域变量的函数，通常是在嵌套函数中实现的。123456789101112// 正常函数function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1 &#125; else if (value1 &gt; value2) &#123; return 1 &#125; else &#123; return 0 &#125;&#125;let result = compare(5, 10) &emsp;&emsp;如图所示，compare()函数是在全局上下文中调用的，第一次调用时，会为它创建一个包含arguments、value1和value2的活动对象，该对象是其作用域链上的第一个对象，而全局上下文的变量对象则是compare()作用域链上的第二个对象，包含this、result和compare。&emsp;&emsp;全局上下文会在代码执行期间始终存在，而函数局部上下文只在函数执行期间存在。&emsp;&emsp;在定义compare()函数时，会为其创建作用域链，预装载全局变量对象，并保存在内部的[[Scope]]中。在调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[Scope]]来创建其作用域链，接着会创建函数的活动对象并将其推入作用域链的前端。&emsp;&emsp;函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中只剩下全局作用域。&emsp;&emsp;然而，闭包中就不一样了。123456789101112131415161718// 闭包函数function createComparisonFunction(propertyName) &#123; return function(object1, object2) &#123; let value1 = object1[propertyName] let value2 = object2[propertyName] if (value1 &lt; value2) &#123; return -1 &#125; else if (value1 &gt; value2) &#123; return 1 &#125; else &#123; return 0 &#125; &#125;&#125;let compare = createComparisonFunction('name')let result = compare(&#123;'name': 'Cxx'&#125;, &#123;'name': 'Pjm'&#125;) &emsp;&emsp;在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。&emsp;&emsp;在createComparisonFunction()返回匿名函数后，其作用域链会被初始化为包含createComparisonFunction()的活动对象和全局变量对象，这样匿名函数就可以访问到createComparisonFunction()可以访问到的所有变量。&emsp;&emsp;而当createComparisonFunction()执行完毕后，匿名函数仍然有它的引用，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中，直到匿名函数被销毁后才会被销毁。 闭包的作用&emsp;&emsp;闭包常常用来间接访问一个变量，或者隐藏一个变量。(使用全局变量也可以满足，但是会导致变量变为公有，不能起到一定的保护作用。) 附：关于闭包的形式解释&emsp;&emsp;这里有一个小故事，可以更好的理解函数闭包的含义：公主的故事&emsp;&emsp;有一个公主…1function princess() &#123; &emsp;&emsp;她生活在一个充满冒险的奇妙世界。她遇到了她的白马王子，骑着独角兽环游世界，与龙搏斗，遇到会说话的动物，以及许多其他奇幻事物。123456789var adventures = [];function princeCharming() &#123; /* ... */ &#125;var unicorn = &#123; /* ... */ &#125;, dragons = [ /* ... */ ], squirrel = \"Hello!\";/* ... */ &emsp;&emsp;但她总是不得不回到她枯燥的家务和成年人的世界。 1return &#123; &emsp;&emsp;她经常告诉他们她作为公主的最新惊人冒险。12345 story: function() &#123; return adventures[adventures.length - 1]; &#125; &#125;;&#125; &emsp;&emsp;但他们看到的只是一个小女孩……1var littleGirl = princess(); &emsp;&emsp;…讲述关于魔法和幻想的故事。1littleGirl.story(); &emsp;&emsp;即使大人们知道真正的公主，他们也永远不会相信独角兽或龙，因为他们永远看不到它们。大人们说，他们只存在于小女孩的想象中。&emsp;&emsp;但我们知道真相；那个带着公主的小女孩……&emsp;&emsp;……真是个公主，里面有一个小女孩。 &emsp;&emsp;Princess()函数是一个包含私有数据的复杂作用域。在函数之外，不能看到或访问私有数据。公主把独角兽、龙、冒险等都留在了她的想象中（私人数据），大人自己看不到。但是公主的想象力被story()函数的闭包捕捉到了，这是littleGirl实例暴露给魔法世界的唯一接口。 参考资料 闭包MDN JS 中的闭包是什么？ 关于闭包 代理与反射&emsp;&emsp;代理用于定义基本操作的自定义行为，本质属于元编程(meta programming)，可以修改程序的默认形为，就形同于在编程语言层面上做修改。&emsp;&emsp;元编程，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。&emsp;&emsp;代理是目标对象的抽象，可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。 代理基础1234567891011121314151617181920212223242526272829303132333435363738394041const target = &#123; foo: 'bar'&#125;const handler = &#123; // 捕获器键值为函数 // 接收三个参数 目标对象 要查询的属性 代理对象 get: function(trapTarget, property, receiver) &#123; console.log('trapTarget:', trapTarget) console.log('property:', property) console.log('receiver:', receiver) return trapTarget[property] + ' get handler' &#125;, // ES6 对象方法简写 set() &#123; console.log('set handler') // 反射API Reflect.set &#125;&#125;// 接收两个参数 目标对象 处理程序对象 // 注：这里是对象 不是方法const proxy = new Proxy(target, handler)console.log(target.foo)target.foo = 'foo'console.log('**********')// 需要对 Proxy 对象进行操作 才会触发代理console.log(proxy.foo)proxy.foo = 'foo'// 输出// bar// **********// trapTarget: &#123;foo: \"foo\"&#125;// property: foo// receiver: Proxy &#123;foo: \"foo\"&#125;// foo get handler// set handler 代理使用Proxy构造函数创建，该函数接收两个参数：目标对象和处理程序对象。 在代理对象上执行的任何操作实际上都会应用到目标对象，每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。 只有在代理对象上执行这些操作才会触发捕获器，在目标对象上执行这些操作仍然会产生正常的行为。 捕获器 API Object API handler.getPrototypeOf() Object.getPrototypeOf() handler.setPrototypeOf() Object.setPrototypeOf() handler.isExtensible() Object.isExtensible() handler.preventExtensions() Object.preventExtensions() handler.getOwnPropertyDescriptor() Object.getOwnPropertyDescriptor() handler.defineProperty() Object.defineProperty() handler.has() in 操作符 handler.get() 属性读取操作 handler.set() 属性设置操作 handler.deleteProperty() delete 操作符 handler.ownKeys() Object.getOwnPropertyNames()和Object.getOwnPropertySymbols() handler.apply() 函数调用操作 handler.construct() new 操作符 &emsp;&emsp;handler 对象的方法 1234567891011121314151617181920const target = &#123; foo: 'bar'&#125;const handler = &#123; get(trapTarget, property, receiver) &#123; // 通过反射API简化代码 return Reflect.get(...arguments) &#125;&#125;// 对象解构const &#123; proxy, revoke &#125; = Proxy.revocable(target, handler)console.log(proxy.foo)// 撤销代理revoke()console.log(proxy.foo)// 输出// bar// Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked &emsp;&emsp;处理程序对象中所有可以捕获的方法都有对应的反射API方法，可以通过调用反射API实现简化代码。 Reflect API Object API 功能/作用 Reflect.apply(target, thisArgument, argumentsList) Function.prototype.apply() 对一个函数进行调用操作，同时可以传入一个数组作为调用参数 Reflect.construct(target, argumentsList[, newTarget]) new target(…args) 对构造函数进行 new 操作 Reflect.defineProperty(target, propertyKey, attributes) Object.defineProperty() 如果设置成功就会返回 true Reflect.deleteProperty(target, propertyKey) delete target[name] 作为函数的delete操作符 Reflect.get(target, propertyKey[, receiver]) target[name] 获取对象身上某个属性的值 Reflect.getOwnPropertyDescriptor(target, propertyKey) Object.getOwnPropertyDescriptor() 如果对象中存在该属性，则返回对应的属性描述符, 否则返回 undefined Reflect.getPrototypeOf(target) Object.getOwnPropertyDescriptor() Reflect.has(target, propertyKey) in 运算符 判断一个对象是否存在某个属性 Reflect.isExtensible(target) Object.isExtensible() Reflect.ownKeys(target) Object.keys() 返回一个包含所有自身属性（不包含继承属性）的数组 Reflect.preventExtensions(target) Object.preventExtensions() 返回一个Boolean Reflect.set(target, propertyKey, value[, receiver]) 将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true Reflect.setPrototypeOf(target, prototype) 设置对象原型的函数. 返回一个 Boolean， 如果更新成功，则返回true &emsp;&emsp;Reflect静态方法 典型应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const user = &#123; name: 'Cxx', age: 18&#125;const proxy = new Proxy(user, &#123; get(target, property, receiver) &#123; // 跟踪属性访问 console.log(`get $&#123;property&#125;`) return Reflect.get(...arguments) &#125;, set(target, property, value, receiver) &#123; // 跟踪属性访问 console.log(`set $&#123;property&#125;`) return Reflect.set(...arguments) &#125;&#125;)proxy.nameproxy.age = 19console.log('**********')const hiddenProperties = ['name']const proxy2 = new Proxy(user, &#123; get(target, property, receiver) &#123; // 隐藏属性 if (hiddenProperties.includes(property)) &#123; return undefined &#125; else &#123; return Reflect.get(...arguments) &#125; &#125;, has(target, property) &#123; // 隐藏属性 if (hiddenProperties.includes(property)) &#123; return undefined &#125; else &#123; return Reflect.has(...arguments) &#125; &#125;&#125;)console.log(proxy2.name)console.log('name' in proxy2)console.log('**********')const proxy3 = new Proxy(user, &#123; set(target, property, value, receiver) &#123; // 属性验证 if (property === 'age' &amp;&amp; typeof value !== 'number') &#123; return false &#125; else &#123; return Reflect.set(...arguments) &#125; &#125;&#125;)proxy3.age = '20'// 更改无效console.log(proxy3.age)proxy3.age = 20console.log(proxy3.age)console.log('**********')// 输出// get name// set age// **********// undefined// false// **********// 19// 20// ********** Promise与异步函数&emsp;&emsp;JavaScript是一种单线程时间循环模型。 Promise基础&emsp;&emsp;Promise(期约或者承诺)是ES6新增的引用类型，可以通过new操作符进行实例化。创建Promise时需要传入执行器函数作为参数，该函数接收2个可以改变Promise状态的函数，一般命名为resolve和reject。1234567891011121314151617181920212223242526272829303132let p1 = new Promise((resolve, reject) =&gt; &#123; console.log('p1 executor') resolve('p1')&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(reject, 1000, 'p2 executor')&#125;)let p3 = new Promise(() =&gt; &#123;&#125;)// p1 的状态为 fulfilledconsole.log('p1:', p1)// 此时 p2 的状态为 pendingconsole.log('p2:', p2)// p3 的状态为 pendingconsole.log('p3:', p3)setTimeout(() =&gt; &#123; // p1 的状态为 fulfilled console.log('p1:', p1) // 此时 p2 的状态为 reject console.log('p2:', p2) // p3 的状态为 pending console.log('p3:', p3)&#125;, 1000); &emsp;&emsp;Promise一共有3种状态：待定pending、兑现fulfilled(或者称为解决resolved)和拒绝rejected。无论何时，Promise有且只可能是其中一种状态，且不可逆。待定是Promise的最初始状态，也是默认状态，当在Promise内部调用控制Promise状态的函数时，则会进行相应的状态切换，否则一致保持待定状态。&emsp;&emsp;在p1中，立即调用resolve()函数将其状态转为解决，而在p2中，通过延迟1秒再将其状态转为拒绝，而p3会一直保持默认状态。&emsp;&emsp;因此，p1的状态会一直保持解决状态，并带有解决的返回值。p2的状态一开始为待定，1秒后会变成拒绝状态，也带有拒绝的返回值，并且控制台会提示错误信息。p3则会一直处于待定状态，并没有返回值。 Promise实例方法12345678910111213141516171819202122232425262728293031323334let p1 = new Promise((resolve, reject) =&gt; &#123; console.log('p1 executor') setTimeout(resolve, 1000)&#125;)// then 只会在 Promise 进入 解决或者拒绝 状态时执行p1.then(() =&gt; new Promise((resolve, reject) =&gt; &#123; console.log('p2 executor') setTimeout(resolve, 1000, 'p2 value')&#125;)).catch(() =&gt; &#123; console.log('p1 catch')&#125;).finally(() =&gt; &#123; console.log('p1 finally')// then 仍然返回 Promise 可以继续链式调用// 将解决/拒绝的值作为参数进行向下传递 &#125;).then((value) =&gt; new Promise((resolve, reject) =&gt; &#123; console.log(value) console.log('p3 executor') setTimeout(reject, 1000)// 也可以将 catch 写在 then 中 即作为第二个参数 &#125;)).then(() =&gt; &#123; console.log('p3 resolve')&#125;, () =&gt; &#123; console.log('p3 reject')&#125;)// 输出// p1 executor// p2 executor// p1 finally// p2 value// p3 executor// p3 reject &emsp;&emsp;then()实例方法接收2个参数，第一个为处理解决状态的函数，第二个为处理拒绝状态的函数，并且可以将解决/拒绝状态的返回值作为函数的参数进行传递。Promise状态只能为其中一个，因此也只能进入其中一个函数。&emsp;&emsp;catch()实例方法实际为then()方法的语法糖，表示处理拒绝状态的函数。finally()实例方法表示无论转换为解决还是拒绝状态都是执行的函数。&emsp;&emsp;如果Promise状态一直为待定状态，则不会进入这些实例方法。 Promise连锁1234567891011121314151617181920212223242526272829303132let p = Promise.all([ // p1 也可以直接调用实例方法创建 Promise Promise.resolve('p1 executor'), // p2 new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('p2 executor') &#125;, 1000); &#125;), // p3 Promise.reject('p3 executor')])// 此时 p 的状态为 pendingconsole.log(p)// 此时 p 的状态为 rejectedsetTimeout(console.log, 1000, p)// 只会进入 catch 实例方法p.then((resolve) =&gt; &#123; console.log(resolve)&#125;).catch((reject) =&gt; &#123; console.log(reject)&#125;)// 输出// Promise &#123;&lt;pending&gt;&#125;// p3 executor// Promise &#123;&lt;rejected&gt;: \"p3 executor\"&#125; &emsp;&emsp;Promise.all()接收一个可迭代对象，会依次处理每个Promise的状态。如果至少有一个Promise的状态为待定/拒绝，则合成的Promise的状态为待定/拒绝，且此时返回的拒绝值为第一个拒绝的值。如果所有的Promise的状态为解决，则合成的Promise的状态为解决，且返回的解决值为所有解决值的数组。 123456789101112131415161718192021222324252627let p = Promise.race([ // p1 Promise.resolve('p1 executor'), // p2 new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('p2 executor') &#125;, 1000); &#125;), // p3 Promise.reject('p3 executor')])// 此时 p 的状态为 pendingconsole.log(p)// 此时 p 的状态为 fulfilledsetTimeout(console.log, 1000, p)// 只会进入 then 方法p.then((resolve) =&gt; &#123; console.log(resolve)&#125;).catch((reject) =&gt; &#123; console.log(reject)&#125;) &emsp;&emsp;Promise.race()和Promise.all()类似，但只会处理最先解决/拒绝的Promise。只要有一个Promise已经解决/处理，则不会再进行后续操作。 异步函数&emsp;&emsp;async关键字用于声明异步函数，异步函数始终返回期约对象，await关键字会暂停执行异步函数后面的代码，让出JavaScript运行时的执行线程，await关键字必须在异步函数中使用。123456789101112131415161718192021222324async function foo() &#123; console.log('foo start') // 碰到 await 会暂停执行 直到 await 右边的状态确定 const result = await Promise.resolve('p1') console.log('result:', result) console.log('foo end')&#125;function bar() &#123; setTimeout(() =&gt; &#123; console.log('bar setTimeout') &#125;, 1000); console.log('bar start')&#125;foo()bar()// 输出// foo start// bar start// result: p1// foo end// bar setTimeout &emsp;&emsp;JavaScript运行时在碰到await关键字时，会记录在哪里暂停执行，等到await右边的值可用了，JavaScript运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。 参考资料 JavaScript高级程序设计 第四版 ES6标准入门 阮一峰","categories":[{"name":"Web前端学习笔记","slug":"Web前端学习笔记","permalink":"http://cxx0822.github.io/categories/Web前端学习笔记/"}],"tags":[]},{"title":"Vue3设计与实现笔记整理","slug":"Vue3设计与实现笔记整理","date":"2022-03-18T15:14:37.000Z","updated":"2022-09-07T13:05:55.316Z","comments":true,"path":"2022/03/18/vue3-she-ji-yu-shi-xian-bi-ji-zheng-li/","link":"","permalink":"http://cxx0822.github.io/2022/03/18/vue3-she-ji-yu-shi-xian-bi-ji-zheng-li/","excerpt":"","text":"框架设计概览命令式和声明式&emsp;&emsp;命令式：123const div = document.querySelector('#app')div.innerText = 'hello world'div.addEventListener('click', () =&gt; &#123; alert('ok')&#125;) &emsp;&emsp;声明式：1&lt;div @click=\"() =&gt; alert('ok')\"&gt;hello world&lt;/div&gt; &emsp;&emsp;命令式关注过程，声明式关注结果。&emsp;&emsp;在Vue.js的内部实现是命令式的，而暴露给用户的是声明式。 虚拟DOM&emsp;&emsp;声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗。&emsp;&emsp;虚拟DOM的目的：最小化找出差异的性能消耗。&emsp;&emsp;纯JavaScript层面的操作要比DOM操作快得多。&emsp;&emsp;虚拟DOM和模板语法在创建页面时的性能： 虚拟DOM 模板语法 纯JavaScript运算 创建JavaScript对象(VNode) 渲染HTML字符串 DOM运算 新建所有的DOM元素 新建所有的DOM元素 &emsp;&emsp;虚拟DOM和模板语法在更新页面时的性能： 虚拟DOM 模板语法 纯JavaScript运算 创建JavaScript对象 + Diff 渲染HTML字符串 DOM运算 必要的DOM更新 销毁所有旧的DOM + 新建所有新的DOM &emsp;&emsp;注：虚拟DOM的出现是为了解决Vue在选择声明式视图框架时，所带来的性能消耗问题。因为通过原生的JavaScript来更新视图层是性能消耗最小的，但同时也是最难维护的(可读性较差)，而选择通过模板语法在创建页面时的性能消耗和虚拟DOM差不多，但是在更新页面时，模板语法带来的DOM运算要远大于虚拟DOM，因为纯JavaScript运算要远比DOM运算更快。&emsp;&emsp;虚拟DOM主要包括创建VNode和比较DOM差异的Diff算法。 Tree-Shaking&emsp;&emsp;Tree-Shaking指的是消除永远不会被执行的代码。 渲染器&emsp;&emsp;虚拟DOM：用JavaScript对象来描述真实的DOM结构。&emsp;&emsp;虚拟DOM——&gt;渲染器——&gt;真实DOM&emsp;&emsp;虚拟DOM：12345678910const vnode = &#123; // 标签名称 如&lt;div&gt;标签 tag: 'div', // 标签的属性、事件等 props: &#123; onClick: () =&gt; alert('hello') &#125;, // 标签的子节点 children: 'click me'&#125; &emsp;&emsp;渲染器：12345678910111213141516171819202122232425262728293031323334// 渲染器函数 参数：虚拟DOM 挂载的真实DOM元素function renderer(vnode, container) &#123; // 创建DOM元素 const el = document.createElement(vnode.tag) // 遍历虚拟DOM的属性、事件 并添加到DOM元素中 for (const key in vnode.props) &#123; // test()：检测一个字符串是否匹配某个模式 // 检测是否以 On 开头 if (/^on/.test(key)) &#123; el.addEventListener( // 去掉标识符 On key.substr(2).toLowerCase(), // 事件处理函数 vnode.props[key] ) &#125; &#125; // 处理children if (typeof vnode.children === 'string') &#123; // 如果是字符串 则创建文本子节点 el.appendChild(document.createTextNode(vnode.children)) &#125; else if (Array.isArray(vnode.children)) &#123; // 否则递归调用 renderer函数 vnode.children.forEach(child =&gt; renderer(child.el)) &#125; // 将元素添加到挂载点下 container.appendChild(el)&#125;// 调用渲染器renderer(vnode, document.body) &emsp;&emsp;渲染器整体分为三步：创建元素——&gt;添加属性和事件——&gt;处理children 组件&emsp;&emsp;组件就是一组DOM元素的封装，本质上也是虚拟DOM。 模板与编译器&emsp;&emsp;编译器的作用就是将模板编译为渲染函数。&emsp;&emsp;模板：123456789101112&lt;template&gt; &lt;div @click=\"handler\"&gt; click me &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123;&#125;, methods: &#123;&#125;,&#125;&lt;script&gt; &emsp;&emsp;经过编译器编译后：1234567export default &#123; data() &#123;&#125;, methods: &#123;&#125;, render() &#123; return h('div', &#123; onClick: handler &#125;, 'click me') &#125;&#125; &emsp;&emsp;无论是模板还是手写渲染函数，对于一个组件来说，它要渲染的内容最终都是通过渲染函数产生的，然后渲染器再把渲染函数返回的虚拟DOM渲染为真实DOM。这就是模板的工作原理，也就是Vue渲染页面的流程。&emsp;&emsp;编译器和渲染器是Vue.js的核心组成部分。 响应系统基本的响应系统12345678910111213141516171819202122232425262728293031323334353637383940// 存储副作用函数的桶const bucket = new Set()// 原始数据const data = &#123; text: 'hello world' &#125;// 对原始数据的代理const obj = new Proxy(data, &#123; // 拦截读取操作 get(target, key) &#123; // 将副作用函数 effect 添加到存储副作用函数的桶中 bucket.add(effect) // 返回属性值 return target[key] &#125;, // 拦截设置操作 set(target, key, newVal) &#123; // 设置属性值 target[key] = newVal // 把副作用函数从桶里取出并执行 bucket.forEach(fn =&gt; fn()) // 返回 true 表示操作成功 return true &#125;&#125;)// 副作用函数function effect() &#123; // DOM操作 document.body.innerText = obj.text&#125;// 执行副作用函数 触发读取操作effect()// 1s后修改响应式数据setTimeout(() =&gt; &#123; // 触发设置操作 obj.text = 'hello vue3'&#125;, 1000) &emsp;&emsp;当读取属性时，将副作用函数添加到桶里，然后返回属性值。当设置属性值时，会先更新数据，然后将副作用函数从桶里取出并重新执行。&emsp;&emsp;注1：副作用函数也就是可以操作DOM元素的函数，因此当修改响应式数据时，此时会触发桶里的副作用函数，也就是修改DOM元素，也相当于更新了页面数据。&emsp;&emsp;注2：所谓响应式数据，也就是当修改原始数据时，DOM页面元素中的数据也会相应的修改。Vue利用Proxy()代理函数实现对数据的拦截操作，并将操作DOM元素的函数隐藏到副作用函数中，并通过适当的储存操作，在适当的时机调用副作用函数，实现隐藏修改DOM元素。 完善的响应系统12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 用一个全局变量存储被注册的副作用函数let activeEffect// 存储副作用函数的桶const bucket = new WeakMap()// 原始数据const data = &#123; text: 'hello world' &#125;// effect函数用于注册副作用函数function effect(fn) &#123; // 当调用 effect 注册副作用函数时 // 将副作用函数 fn 赋值给 activeEffect activeEffect = fn // 执行副作用函数 fn()&#125;// 对原始数据的代理const obj = new Proxy(data, &#123; // 拦截读取操作 get(target, key) &#123; // 将副作用函数 activeEffect 添加到存储副作用函数的桶中 track(target, key) // 返回属性值 return target[key] &#125;, // 拦截设置操作 set(target, key, newVal) &#123; // 设置属性值 target[key] = newVal // 把副作用函数从桶里取出并执行 trigger(target, key) &#125;&#125;)function track(target, key) &#123; // 没有 activeEffect 直接 return if (!activeEffect) return // 根据 target 从桶中取得 depsMap let depsMap = bucket.get(target) // 如果不存在 则新建 if (!depsMap) &#123; // 建立 target 和 Map 的联系 bucket.set(target, (depsMap = new Map())) &#125; // 根据 key 从 depsMap 中取得 deps let deps = depsMap.get(key) // 如果不存在 则新建 if (!deps) &#123; // 建立 key 和 Set 联系 depsMap.set(key, (deps = new Set())) &#125; // 将当前激活的副作用函数添加到桶中 deps.add(activeEffect)&#125;function trigger(target, key) &#123; // 根据 target 从桶中取得 depsMap const depsMap = bucket.get(target) if (!depsMap) return // 根据 key 取得所有副作用函数 effects const effects = depsMap.get(key) // 执行 effects effects &amp;&amp; effects.forEach(fn =&gt; fn())&#125;// 调用副作用函数effect( // 传入一个匿名函数参数 () =&gt; &#123; // DOM元素操作 document.body.innerText = obj.text &#125;)// 1s后修改响应式数据setTimeout(() =&gt; &#123; // 触发设置操作 obj.text = 'hello vue3'&#125;, 1000) &emsp;&emsp;解决问题1：将副作用函数匿名化，并用一个全局变量存储被注册的副作用函数。&emsp;&emsp;解决问题2：建立副作用函数与被操作的目标字段的联系。&emsp;&emsp;&emsp;&emsp;由图可知，WeakMap是由target --&gt; Map构成，存放的是原始对象的关联信息。而Map又是由key --&gt; Set构成，Set里面存放的是具体的副作用函数，因此Map存放的是原始对象key值和副作用函数的联系。&emsp;&emsp;因此每个对象的每个key值均和对应的副作用函数实现了相互关联。&emsp;&emsp;附1：WeakMap对key是弱引用，不影响垃圾回收期的工作。因此一旦key被垃圾回收器回收，则对应的键和值就不能访问了，如果使用Map来存储，则会一定程度上导致内存溢出。 响应系统的其他细节分支切换与cleanup 问题现象：12345const data = &#123; ok: true, text: 'hello world' &#125; const obj = new Proxy(data, &#123;&#125;)effect(() =&gt; &#123; document.body.innerText = obj.ok ? obj.text : 'not'&#125;) &emsp;&emsp;当obj.ok的初始值为true时，会依次执行obj.ok的和obj.text这两个属性的读写操作，但是当将obj.ok的值修改为false后，此时正常的逻辑应为只会触发obj.ok的读取操作，不会触发obj.text的操作，但实际上，当修改obj.text的值时，仍然会导致副作用函数执行。 问题分析：&emsp;&emsp;出现该问题的主要原因是因为在第一次操作obj.ok和obj.text时，已经在内存中建立了对应的联系，而当将obj.ok的值修改为false时，虽然从三元表达式中不会执行obj.text，但是关于obj.text的联系已经建立在内存中，因此，当修改obj.text(即只要触发对象的读写操作)，仍然会重新执行之前建立好的联系。 问题解决：&emsp;&emsp;在每次副作用函数执行前，将其从相关联的依赖集合中移除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081let activeEffectconst bucket = new WeakMap()const data = &#123; ok: true, text: 'hello world' &#125;function effect(fn) &#123; const effectFn = () =&gt; &#123; // 调用 cleanup 函数完成清除工作 cleanup(effectFn) // 当 effectFn 执行时 将其设置为当前激活的副作用函数 activeEffect = effectFn fn() &#125; // activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合 effectFn.deps = [] effectFn()&#125;function cleanup(effectFn) &#123; // 遍历数组 for (let i = 0; i &lt; effectFn.deps.length; i++) &#123; // deps 是依赖集合 const deps = effectFn.deps[i] // 将 effectFn 从依赖集合中移除 deps.delete(effectFn) &#125; // 重置 effectFn.deps 数组 effectFn.deps.length = 0&#125;const obj = new Proxy(data, &#123; get(target, key) &#123; track(target, key) return target[key] &#125;, set(target, key, newVal) &#123; target[key] = newVal trigger(target, key) &#125;&#125;)function track(target, key) &#123; if (!activeEffect) return let depsMap = bucket.get(target) if (!depsMap) &#123; bucket.set(target, (depsMap = new Map())) &#125; let deps = depsMap.get(key) if (!deps) &#123; depsMap.set(key, (deps = new Set())) &#125; deps.add(activeEffect) // 将其添加到 activeEffect.deps 数组中 activeEffect.deps.push(deps)&#125;function trigger(target, key) &#123; const depsMap = bucket.get(target) if (!depsMap) return const effects = depsMap.get(key) // 重新构造另外一个Set集合 防止出现无限循环的bug const effectsToRun = new Set(effects) effectsToRun.forEach(effectFn =&gt; effectFn())&#125;effect( () =&gt; &#123; document.body.innerText = obj.ok ? obj.text : 'not' &#125;)setTimeout(() =&gt; &#123; obj.text = 'hello vue3'&#125;, 1000) &emsp;&emsp;在执行副作用函数前，会先调用cleanup()函数将其相关联的依赖清除。此时，修改obj.ok的值为false后，在执行obj.text操作是不会导致副作用函数的执行。 嵌套的effect 问题现象1234567891011121314151617181920212223const data = &#123; foo: true, bar: true &#125;const obj = new Proxy(data, &#123;&#125;)// 设置全局变量let temp1 = temp2// 定义2个effect函数effect(function effectFn1() &#123; console.log('effectFn1 执行') effect(function effectFn2() &#123; console.log('effectFn2 执行') temp2 = obj.bar &#125;) temp1 = obj.foo &#125;)// 修改 obj.foo 的值// 正确的应该会显示 'effectFn1 执行' 因为 foo 关联的是 effectFn 函数// 但实际显示的是 'effectFn2 执行'obj.foo = false &emsp;&emsp;在effectFn1内部嵌套了effectFn2，并在effectFn1和effectFn2内部分别读取了foo和bar的值，从而建立了副作用函数和属性之间的关联。&emsp;&emsp;但是在修改obj.foo的值时(obj.foo = false)，正确应该会显示相关联的effectFn1函数，但实际上显示的effectFn2函数。&emsp;&emsp;Vue中实际的场景：12345678910111213141516171819// Bar组件const Bar = &#123; render() &#123;&#125;&#125;// Foo组件渲染了Bar组件const Foo = &#123; render() &#123; return &lt;Bar /&gt; &#125;&#125;// 上述模板解析后：effect(() =&gt; &#123; Foo.render() effect(() =&gt; &#123; Bar.render() &#125;)&#125;) 问题分析&emsp;&emsp;在使用activeEffect = effectFn存储副作用函数时，此时的副作用函数只能有一个，当副作用函数发生嵌套时，内层的副作用函数的执行会覆盖activeEffect的值，并且永远不会恢复。 问题解决&emsp;&emsp;建立一个副作用函数栈effectStack，副作用函数执行时，将其压入栈中，执行后将其弹出。使得响应式数据只会收直接读取其值的副作用函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let activeEffect// effect 函数栈const effectStack = []const bucket = new WeakMap()const data = &#123; foo: true, bar: true &#125;function effect(fn) &#123; const effectFn = () =&gt; &#123; cleanup(effectFn) activeEffect = effectFn // 在调用副作用函数之前将其压入栈中 effectStack.push(effectFn) fn() // 调用之后将其弹出 并还原为之前的值 effectStack.pop() activeEffect = effectStack[effectStack.length - 1] &#125; effectFn.deps = [] effectFn()&#125;function cleanup(effectFn) &#123; // 不变&#125;const obj = new Proxy(data, &#123; // 不变&#125;)function track(target, key) &#123; // 不变&#125;function trigger(target, key) &#123; // 不变&#125;let temp1, temp2effect(function effectFn1() &#123; console.log('effectFn1 执行') effect(function effectFn2() &#123; console.log('effectFn2 执行') temp2 = obj.bar &#125;) temp1 = obj.foo &#125;)obj.foo = false 无限递归循环 问题现象 1234const data = &#123; foo: 1 &#125;const obj = new Proxy(data, &#123;&#125;)effect(() =&gt; obj.foo++) &emsp;&emsp;此时控制台会出现错误：Uncaught RangeError: Maximum call stack size exceeded，即栈溢出错误。 问题分析&emsp;&emsp;自增操作(obj.foo++)既会读取属性值也会设置属性值，这就会导致副作用函数在执行时，还没有执行完毕就要开始下一次的执行，从而造成了无限递归调用自己。 问题解决&emsp;&emsp;将读取和设置的副作用函数分开处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445let activeEffectconst effectStack = []const bucket = new WeakMap()const data = &#123; foo: 1 &#125;function effect(fn) &#123;const effectFn = () =&gt; &#123; // 不变&#125;function cleanup(effectFn) &#123; // 不变&#125;const obj = new Proxy(data, &#123; // 不变&#125;)function track(target, key) &#123; // 不变&#125;function trigger(target, key) &#123; const depsMap = bucket.get(target) if (!depsMap) return const effects = depsMap.get(key) const effectsToRun = new Set() effects &amp;&amp; effects.forEach(effectFn =&gt; &#123; // 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同 // 则不触发执行 if (effectFn !== activeEffect) &#123; effectsToRun.add(effectFn) &#125; &#125;) effectsToRun.forEach(effectFn =&gt; effectFn())&#125;effect(() =&gt; &#123; obj.foo++&#125;) &emsp;&emsp;增加判断条件，避免重复调用。 调度执行&emsp;&emsp;可调度，指的是当trigger动作触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数以及方式。也即为副作用函数增加一些附属功能。 问题现象 123456789101112131415161718const data = &#123; foo: 1 &#125;const obj = new Proxy(data, &#123;&#125;)effect(() =&gt; &#123; console.log(obj.foo)&#125;)// 只要对 对象进行 set 操作 就会进入 trigger() 中// 从而执行之前保存的副作用函数，即传入 effect() 中的函数参数// 本例中也就是 console.log(obj.foo)obj.foo++console.log('结束了')// 输出// 1// 2// 结束了 &emsp;&emsp;如果现在有个需求，想改变输出的顺序为：1 结束了 2，并且是在不调整代码的情况下实现。 问题解决 &emsp;&emsp;这时候就需要为响应系统设计一个可调度系统：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576let activeEffectconst effectStack = []const bucket = new WeakMap()const data = &#123; foo: 1 &#125;function effect(fn, options = []) &#123; const effectFn = () =&gt; &#123; cleanup(effectFn) activeEffect = effectFn effectStack.push(effectFn) fn() effectStack.pop() activeEffect = effectStack[effectStack.length - 1] &#125; // 将 options 挂载到 effectFn 上 effectFn.options = options effectFn.deps = [] effectFn()&#125;function cleanup(effectFn) &#123; // 不变&#125;const obj = new Proxy(data, &#123; // 不变&#125;)function track(target, key) &#123; // 不变&#125;function trigger(target, key) &#123; const depsMap = bucket.get(target) if (!depsMap) return const effects = depsMap.get(key) const effectsToRun = new Set() effects &amp;&amp; effects.forEach(effectFn =&gt; &#123; if (effectFn !== activeEffect) &#123; effectsToRun.add(effectFn) &#125; &#125;) effectsToRun.forEach(effectFn =&gt; &#123; // 如果一个副作用函数存在调度器 则调用该调度器 // 并将副作用函数作为参数传递 if (effectFn.options.scheduler) &#123; effectFn.options.scheduler(effectFn) &#125; else &#123; effectFn() &#125; &#125;)&#125;effect(() =&gt; &#123; console.log(obj.foo)&#125;,// options&#123; // 调度器 scheduler 是一个函数 scheduler(fn) &#123; // 将副作用函数放到宏任务队列中执行 // 这里会延迟执行 setTimeout(fn, 1000) &#125;&#125;)obj.foo++console.log('结束了') &emsp;&emsp;此时控制台会先输出1 结束了，并延迟1秒后在输出2。 计算属性computed&emsp;&emsp;结合之前的响应系统和调度器就可以实现计算属性。&emsp;&emsp;计算属性的特点：1.响应式 2.不会立即执行，触发读取/设置操作时才会执行 3.有缓存。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101let activeEffectconst effectStack = []const bucket = new WeakMap()const data = &#123; foo: 1, bar: 2 &#125;function effect(fn, options = []) &#123; const effectFn = () =&gt; &#123; console.log('effectFn 执行') cleanup(effectFn) activeEffect = effectFn effectStack.push(effectFn) // 将 fn 的执行结果存储到 res 中 const res = fn() effectStack.pop() activeEffect = effectStack[effectStack.length - 1] // 返回执行结果 return res &#125; effectFn.options = options effectFn.deps = [] // 只有非 lazy 的时候才执行 if (!options.lazy) &#123; effectFn() &#125; // 将副作用函数作为返回值返回 return effectFn&#125;function cleanup(effectFn) &#123; // 不变&#125;const obj = new Proxy(data, &#123; // 不变&#125;)function track(target, key) &#123; // 不变&#125;function trigger(target, key) &#123; // 不变&#125;// 定义计算属性函数function computed(getter) &#123; // 缓存上一次计算的值 let value // 用来表示是否需要重新计算值 let dirty = true const effectFn = effect(getter, &#123; // 设置为懒执行 lazy: true, // 添加调度器 将 dirty 重置为 true // 保证下次在重新设置计算属性值时 会重新计算 scheduler() &#123; dirty = true &#125; &#125;) const obj = &#123; // 当读取 obj 的 value 属性时 才会执行 effectFn get value() &#123; // 只有需要重新计算时 才将得到的值缓存到 value 中 if (dirty) &#123; value = effectFn() // 设置为 false 下次访问直接使用缓存的值 dirty = false &#125; return value &#125; &#125; // 计算属性返回对象 // 对象中的 value 属性才是存放的计算值 return obj&#125;const sunRes = computed(() =&gt; obj.foo + obj.bar)console.log(sunRes.value)console.log(sunRes.value)obj.foo++console.log(sunRes.value)// 输出// effectFn 执行// 3// 3// effectFn 执行// 4 &emsp;&emsp;计算属性返回的是一个对象，对象中的value值才是存放实际计算的结果。由输出结果可知，多次调用计算属性不会重复执行副作用函数，而在对原始对象重新执行赋值操作时，会恢复执行副作用函数。 参考资料 《Vue.js设计与实现》霍春阳 2022.1","categories":[{"name":"Web前端学习笔记","slug":"Web前端学习笔记","permalink":"http://cxx0822.github.io/categories/Web前端学习笔记/"}],"tags":[]},{"title":"vue3知识点整理","slug":"vue3知识点整理","date":"2022-03-18T15:09:34.000Z","updated":"2022-03-31T07:19:58.067Z","comments":true,"path":"2022/03/18/vue3-zhi-shi-dian-zheng-li/","link":"","permalink":"http://cxx0822.github.io/2022/03/18/vue3-zhi-shi-dian-zheng-li/","excerpt":"","text":"Vue3简介Vue3基础知识Vue3组件系统全局状态管理——Pinia简介&emsp;&emsp;Pinia是一个Vue的存储库, 它能让你跨组件/页面共享状态。 官方文档 中文文档 安装配置1npm install pinia &emsp;&emsp;main.ts：12import &#123; createPinia &#125; from 'pinia'app.use(createPinia()) 简单使用定义&emsp;&emsp;src/store/example.ts：12345678910111213141516171819202122import &#123; defineStore &#125; from 'pinia' // 规范写法：use[name]Storeexport const useExampleStore = defineStore(&#123; // store id: 'example', state: () =&gt; (&#123; key: 'value' as string, &#125;), // getters getters: &#123; newKey() &#123; this.key = newValue &#125; &#125;, // actions actions: &#123; functionName(newValue:string) &#123; this.key = newValue &#125; &#125;&#125;) &emsp;&emsp;这里id为store实例的唯一标识，state为属性值，getters为state的计算值，actions为store中的方法，支持同步和异步方法。&emsp;&emsp;在getters和actions中均可以使用this关键字访问到整个store实例。&emsp;&emsp;如需定义多个store实例，可以新建多个ts文件，依次实例化store即可。 使用&emsp;&emsp;src/components/example.vue：123456789import &#123; useExampleStore &#125; from '@/store/example'const exampleStore = useExampleStore()const newKey = computed(() =&gt; exampleStore.newKey)const functionName = (newValue:string) =&gt; &#123; exampleStore.functionName(newValue)&#125; &emsp;&emsp;首先导入具体的store并实例化，然后使用点运算符调用属性或方法即可。 注意事项 在非Vue文件中使用store实例时，需要在函数内部实例化，否则无法正确使用store实例。官方说明 全局路由管理——Router简介&emsp;&emsp;Vue Router是Vue.js的官方路由。它与Vue.js核心深度集成，让用Vue.js构建单页应用变得轻而易举。 Vue Router GitHub Vue Router 中文文档 安装配置封装路由拦截器全局网络请求——Axios简介&emsp;&emsp;Axios是一个基于promise的网络请求库，可以用于浏览器和node.js。 Axios GitHub Axios 官方文档 Axios 中文文档 安装配置1npm install axios 使用点运算符形式1234567891011121314151617181920212223242526const axios = require('axios');// 向给定ID的用户发起请求axios.get('/user?ID=12345') .then(function (response) &#123; // 处理成功情况 console.log(response); &#125;) .catch(function (error) &#123; // 处理错误情况 console.log(error); &#125;) .then(function () &#123; // 总是会执行 &#125;);axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone'&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 配置项形式123456789101112131415// 发起一个post请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 封装拦截器&emsp;&emsp;src/utils/request.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import axios, &#123; AxiosResponse &#125; from 'axios'import &#123; ElMessage, ElMessageBox &#125; from 'element-plus'import &#123; getToken &#125; from '@/utils/auth'import &#123; useUserStore &#125; from '@/store/user'const service = axios.create(&#123; // URL地址 baseURL: process.env.VUE_APP_BASE_API, // 连接时间 timeout: 5000&#125;)// 请求拦截器service.interceptors.request.use( // 这里要将原来的类型AxiosRequestConfig设置为类型为any 否则会编译不过 (config: any) =&gt; &#123; const userStore = useUserStore() // 如果有token 则加上token值 if (userStore.token) &#123; config.headers['X-Token'] = getToken() &#125; return config &#125;, (error) =&gt; &#123; return Promise.reject(error) &#125;)// 响应拦截器service.interceptors.response.use( (response: AxiosResponse) =&gt; &#123; const res = response.data // 如果状态码不是20000 // 根据实际的后端接口确定状态码 if (res.code !== 20000) &#123; ElMessage(&#123; message: res.message || 'Error', type: 'error', duration: 5 * 1000 &#125;) if (res.code === 50008 || res.code === 50012 || res.code === 50014) &#123; ElMessageBox.confirm( '你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', &#123; confirmButtonText: '重新登录', cancelButtonText: '取消', type: 'warning' &#125; ).then(() =&gt; &#123; const userStore = useUserStore() // 重置token userStore.resetToken().then(() =&gt; &#123; location.reload() &#125;) &#125;) &#125; return Promise.reject(new Error(res.message || 'Error')) &#125; else &#123; // 正确则返回数据 return res &#125; &#125;, (error) =&gt; &#123; ElMessage(&#123; message: error.message, type: 'error', duration: 5 * 1000 &#125;) return Promise.reject(error) &#125;)export default service &emsp;&emsp;这里添加了部分业务逻辑，可根据实际需求修改。&emsp;&emsp;src/api/example.ts：123456789101112131415161718192021222324import request from '@/utils/request'// getexport const functionName1 = ():any =&gt; request(&#123; url: '/example', method: 'get', &#125;)// postexport const functionName2 = (param:paramTF):any =&gt; request(&#123; url: '/example', method: 'post', params: &#123; param &#125; &#125;)// postexport const functionName3 = (param: paramTF):any =&gt; request(&#123; url: '/example', method: 'post', data: param &#125;) 原理简介 一步一步解析Axios源码，从入门到原理 全局图标管理——Svg简介&emsp;&emsp;SVG(Scalable Vector Graphics)是一种图形文件格式，意为可缩放的矢量图形。SVG是一种用XML定义的语言，用来描述二维矢量及矢量/栅格图形。&emsp;&emsp;SVG sprite loader 安装配置&emsp;&emsp;安装1npm install svg-sprite-loader -D &emsp;&emsp;引入 main.ts12345678// 引入svgimport svgIcon from '@/icons/index.vue'import '@/icons/index'// 创建Vue3实例const app = createApp(App)// 注册svg组件app.component('svg-icon', svgIcon) &emsp;&emsp;新建src/icons文件夹，并新建svg文件夹，存放svg图标，index.ts和index.vue文件。 index.ts：123const req = require.context('./svg', false, /\\.svg$/)const requireAll = (requireContext:any) =&gt; requireContext.keys().map(requireContext)requireAll(req) index.vue：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;svg :class=\"svgClass\" aria-hidden=\"true\"&gt; &lt;use :xlink:href=\"iconName\" /&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script setup lang=\"ts\"&gt;import &#123; computed, defineProps &#125; from 'vue'const props = defineProps(&#123; iconClass: &#123; type: String, required: true &#125;, className: &#123; type: String, default: '' &#125;&#125;)const iconName = computed(() =&gt; `#icon-$&#123;props.iconClass&#125;`)const svgClass = computed(() =&gt; &#123; if (props.className) &#123; return 'svg-icon ' + props.className &#125; else &#123; return 'svg-icon' &#125;&#125;)&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;.svg-icon &#123; /* 调整大小 */ width: 1.3em; height: 1.3em; vertical-align: -0.3em; fill: currentColor; overflow: hidden;&#125;.svg-external-icon &#123; background-color: currentColor; mask-size: cover!important; display: inline-block;&#125;&lt;/style&gt; &emsp;&emsp;修改vue.config.js：123456789101112131415161718192021222324252627'use strict'const path = require('path')function resolve(dir) &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; chainWebpack: config =&gt; &#123; // set svg-sprite-loader config.module .rule('svg') .exclude.add(resolve('src/icons')) .end() config.module .rule('icons') .test(/\\.svg$/) .include.add(resolve('src/icons')) .end() .use('svg-sprite-loader') .loader('svg-sprite-loader') .options(&#123; symbolId: 'icon-[name]' &#125;) .end() &#125;&#125; 使用1&lt;svg-icon icon-class=\"iconName\" /&gt; &emsp;&emsp;其中iconName为icon-&gt;svg文件夹中的图标名。 Vue3常见警告/错误处理","categories":[{"name":"Web前端学习笔记","slug":"Web前端学习笔记","permalink":"http://cxx0822.github.io/categories/Web前端学习笔记/"}],"tags":[]},{"title":"Git学习笔记整理","slug":"Git学习笔记整理","date":"2022-01-09T11:31:26.000Z","updated":"2022-09-07T13:05:55.302Z","comments":true,"path":"2022/01/09/git-xue-xi-bi-ji-zheng-li/","link":"","permalink":"http://cxx0822.github.io/2022/01/09/git-xue-xi-bi-ji-zheng-li/","excerpt":"","text":"Git命令清单 、 Git常用命令整理初始化工程1git init 本地仓库提交文件 添加文件到暂存区： 123git add [file] // 添加单个文件git add [dir] // 添加指定文件夹 git add . // 添加当前目录所有文件 将暂存区内容添加到本地仓库中： 12git commit [file] -m [message] // 提交暂存区的指定文件git commit -m [message] // 提交暂存区的所有文件 版本回退 查看历史提交记录： 12git loggit log --pretty=oneline // 单行显示 回退到某个版本： 1git reset --hard [HEAD] &emsp;&emsp;这里的HEAD参数为git log --pretty=oneline命令输出的每一行最开始的一长串字符串，即每次commit的HEAD(版本)值。&emsp;&emsp;实际输入时，可以只取前5-8个字符。 撤销修改 查看状态： 1git status 没有git add，撤销某个文件的修改： 1git checkout -- [file] 已经git add： 12git reset HEAD [file]git checkout -- [file] // 依次执行2条命令 已经git commit： 1git reset --hard [HEAD] // 回退到之前的版本 远程仓库添加远程仓库 添加远程版本库：1git remote add [shortname] [url] &emsp;&emsp;shortname参数一般用origin来表示，即远程版本库。 将本地分支版本上传至远程并合并：1git push -u origin master &emsp;&emsp; 将本地代码推送到远程的master分支。第一次推送时，需要加上-u，后续推送时，可不加此参数。 分支管理查看分支：1git branch 创建分支：1git branch [name] 切换分支：12git checkout [name]git switch [name] // 需要git版本2.23 创建+切换分支：12345678910111213141516171819git checkout -b [name]git switch -c [name] // 需要git版本2.23 ``` ### 合并某分支到当前分支：```cmdgit merge [name] ``` ### 删除分支：```cmdgit branch -d [name] ``` ## 标签管理### 创建标签1. 给当前`commit`添加标签：```cmdgit tag -a [tagname] -m [message] 给某一次commit添加标签。HEAD为commit的ID值： 1git tag -a [tagname] -m [message] [HEAD] 查看所有标签： 1git tag 操作标签 推送一个本地标签：1234567891011121314151617181920212223242526272829303132git push origin [tagname] ``` 2. 推送全部未推送过的本地标签：```cmdgit push origin --tags ``` 3. 删除一个本地标签：```cmdgit tag -d [tagname] ``` 4. 删除一个远程标签：```cmdgit push origin :refs/tags/[tagname] ``` # Git常见问题整理1. 解决合并代码的冲突问题 * 问题现象 &amp;emsp;&amp;emsp;当本地代码与远程代码不同步时，如果此时`git push`进行提交，则会出现代码冲突问题。* 解决办法 ```cmdgit stash // 保存代码git pull // 拉取代码git stash pop stash@&#123;0&#125; // 还原刚才保存的代码git stash clear // 清空所有刚才保存的代码 其他Git指令 统计项目文件的所有文件列表、及行数： 1git ls-files | xargs wc -l 参考资料 廖雪峰git官方文档 Learn Git Branching学习网站","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://cxx0822.github.io/categories/学习笔记/"}],"tags":[]},{"title":"Web前后端数据交互基础与应用","slug":"Web前后端数据交互基础与应用","date":"2021-12-01T08:56:30.000Z","updated":"2022-03-30T00:57:35.424Z","comments":true,"path":"2021/12/01/web-qian-hou-duan-shu-ju-jiao-hu-ji-chu-yu-ying-yong/","link":"","permalink":"http://cxx0822.github.io/2021/12/01/web-qian-hou-duan-shu-ju-jiao-hu-ji-chu-yu-ying-yong/","excerpt":"","text":"简介&emsp;&emsp;Web前后端中数据交互是实际项目业务中最为常见的一种需求。目前比较成熟的解决方案是采用axios的方式，而其本质也就是计算机网络中的HTTP的概念。 HTTP简介&emsp;&emsp;HTTP(hypertext transport protocol)协议，即超文本传输协议，详细规定了浏览器和万维网服务器之间互相通信的规则和约定。&emsp;&emsp;其用于数据交互的两个重要概念为：HTTP请求报文和HTTP响应报文。 HTTP请求报文&emsp;&emsp;一个HTTP请求报文由请求行request line、请求头部header、空行和请求数据4个部分组成。 请求行&emsp;&emsp;请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号:分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：&emsp;&emsp;User-Agent：产生请求的浏览器类型。&emsp;&emsp;Accept：客户端可识别的内容类型列表。&emsp;&emsp;Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。 请求头部&emsp;&emsp;请求头部由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。&emsp;&emsp;HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。&emsp;&emsp;其中最常见的为GET(查询)和POST(增加)请求。(PUT请求对应于更新，DELETE请求对应于删除) GET请求GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（?）代表URL的结尾与请求参数的开始，传递参数长度受限制。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST请求POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。 空行&emsp;&emsp;最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。 请求数据&emsp;&emsp;请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。 HTT响应报文&emsp;&emsp;和请求报文类似，HTTP响应报文也由三个部分组成，分别是：状态行、消息报头、响应正文。&emsp;&emsp;在响应报文中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行status line通过提供一个状态码来说明所请求的资源情况。 状态行格式&emsp;&emsp;HTTP-Version Status-Code Reason-Phrase CRLF&emsp;&emsp;其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。 1xx：指示信息—表示请求已接收，继续处理。 2xx：成功—表示请求已被成功接收、理解、接受。 3xx：重定向—要完成请求必须进行更进一步的操作。 4xx：客户端错误—请求有语法错误或请求无法实现。 5xx：服务器端错误—服务器未能实现合法的请求。 &emsp;&emsp;常见状态代码、状态描述的说明如下。 200 OK：客户端请求成功。 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。 403 Forbidden：服务器收到请求，但是拒绝提供服务。 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。 500 Internal Server Error：服务器发生不可预期的错误。 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。 参考博客HTTP请求报文和HTTP响应报文 Ajax简介&emsp;&emsp;AJAX全称为Asynchronous JavaScript And XML，就是异步的JS和XML。AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。它是一种技术方案，但并不是一种新技术。&emsp;&emsp;它依赖的是现有的CSS/HTML/Javascript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象。这个对象为向服务器发送请求和解析服务器响应提供了流畅的接口，使得浏览器可以发出HTTP请求与接收HTTP响应，实现在页面不刷新的情况下和服务端进行数据交互。&emsp;&emsp;本质上就是一种依赖于HTTP技术提出的一种解决Web数据交互的解决方案。&emsp;&emsp;通过AJAX可以在浏览器中向服务器发送异步请求，最大的优势为无刷新获取数据。 原生Ajax实现&emsp;&emsp;本质上就是对浏览器提供的XMLHttpRequest类进行一系列的操作。 请求状态&emsp;&emsp;0：请求未初始化，还没有调用open()&emsp;&emsp;1：请求已经建立，但是还没有发送，还没有调用send()&emsp;&emsp;2：请求已发送，正在处理中，通常现在可以从响应中获取内容头。&emsp;&emsp;3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。&emsp;&emsp;4：响应已完成；可以获取并使用服务器的响应了。 简单使用12345678910111213141516171819// 1.创建 XMLHttpRequest 对象var xhr = new XMLHttpRequest();// 2.设置请求信息xhr.open(method, url);// 3.设置请求头，一般不设置xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');// 4.发送请求// get请求不传body参数，只有post请求使用xhr.send(body) // 5.接收响应// xhr.responseXML 接收 xml 格式的响应数据// xhr.responseText 接收文本格式的响应数据xhr.onreadystatechange = function ()&#123; // 判断是否响应完成且返回的状态码正确 if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; var text = xhr.responseText; console.log(text); &#125;&#125; 请求超时与网络异常处理1234567891011const xhr = new XMLHttpRequest();// 超时设置 2s 设置xhr.timeout = 2000;// 超时回调xhr.ontimeout = function()&#123; alert(\"网络异常, 请稍后重试!!\");&#125;// 网络异常回调xhr.onerror = function()&#123; alert(\"你的网络似乎出了一些问题!\");&#125; 取消请求1xhr.abort(); 常见的Ajax请求方式jQuery12345678910111213141516171819202122232425262728$.ajax(&#123; // url url: 'http://127.0.0.1:8000/jquery-server', //头信息 headers: &#123; c: 300, d: 400 &#125;, //超时时间 timeout: 2000, // 参数 data: &#123; a: 100, b: 200 &#125;, //请求类型 type: 'GET', //响应体结果 dataType: 'json', //成功的回调 success: function(data)&#123; console.log(data); &#125;, //失败的回调 error: function()&#123; console.log('出错啦!!'); &#125;&#125;); Axios12345678910111213141516171819202122232425262728293031axios.defaults.baseURL = 'http://127.0.0.1:8000';axios(&#123; // url url: '/axios-server', // url参数 params: &#123; vip: 10, level: 30 &#125;, // 头信息,此部分如果使用自定义的头信息,需要服务端进行相应修改,正常不设置 headers: &#123; a: 100, b: 200 &#125;, // 请求方法 method: 'POST', // 请求体参数 data: &#123; username: 'admin', password: 'admin' &#125;&#125;).then(response =&gt; &#123; // 响应状态码 console.log(response.status); // 响应状态字符串 console.log(response.statusText); // 响应头信息 console.log(response.headers); // 响应体 console.log(response.data);&#125;) Fetch123456789101112131415fetch('http://127.0.0.1:8000/fetch-server?vip=10', &#123; // 请求头 headers: &#123; name: 'atguigu' &#125;, // 请求方法 method: 'POST', // 请求体 body: 'username=admin&amp;password=admin'&#125;).then(response =&gt; &#123; // return response.text(); return response.json();&#125;).then(response =&gt; &#123; console.log(response);&#125;); 跨域问题跨越原因&emsp;&emsp;一个网页向另一个不同域名/不同协议/不同端口的网页请求资源，这就是跨域。&emsp;&emsp;跨域原因产生：在当前域名请求网站中，默认不允许通过ajax请求发送其他域名。因为浏览器使用了同源策略。 同源策略&emsp;&emsp;同源策略是Netscape提出的一个著名的安全策略，现在所有支持JavaScript的浏览器都会使用这个策略。同源策略是浏览器最核心也最基本的安全功能，如果缺少同源策略，浏览器的正常功能可能受到影响。可以说web是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现。&emsp;&emsp;同源：协议、域名、端口号必须完全相同。违背同源策略就是跨域。&emsp;&emsp;浏览器使用同源策略是为了保证用户的信息安全，防止恶意网站窃取数据，如果网页之间不满足同源要求，将不能: 共享Cookie、LocalStorage、IndexDB 获取DOM AJAX请求不能发送 解决方案 前端使用jsonp（不推荐使用） 后台Http请求转发 后台配置同源Cors（推荐） 使用SpringCloud网关 使用nginx做转发 (推荐) Axios简介&emsp;&emsp;目前前端最流行的ajax请求库。react/vue官方都推荐使用axios发送ajax请求。其特点主要包括： 基于xhr(XMLHttpRequest) + promise的异步ajax请求库 浏览器端/node端都可以使用 支持请求/响应拦截器 支持请求取消 请求/响应数据转换 批量发送多个请求 创建实例12345678const axios1 = axios.create(&#123; baseURL: 'https://api.apiopen.top', timeout: 2000&#125;);const axios2 = axios.create(&#123; baseURL: 'https://b.com', timeout: 2000&#125;); 调用顺序&emsp;&emsp;调用axios()并不是立即发送ajax请求, 而是需要经历一个较长的流程：&emsp;&emsp;请求拦截器2 =&gt; 请求拦截器1 =&gt; 发送ajax请求 =&gt; 响应拦截器1 =&gt; 响应拦截器2 =&gt; 请求的回调(如果此时有多个请求和响应拦截器)&emsp;&emsp;此流程是通过promise串连起来的, 请求拦截器传递的是 config, 响应拦截器传递的是response。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 设置请求拦截器 config 配置对象axios.interceptors.request.use(function (config) &#123; console.log('请求拦截器 成功 - 1号'); //修改 config 中的参数 config.params = &#123; a: 100 &#125;; return config;&#125;, function (error) &#123; console.log('请求拦截器 失败 - 1号'); return Promise.reject(error);&#125;);axios.interceptors.request.use(function (config) &#123; console.log('请求拦截器 成功 - 2号'); //修改 config 中的参数 config.timeout = 2000; return config;&#125;, function (error) &#123; console.log('请求拦截器 失败 - 2号'); return Promise.reject(error);&#125;);// 设置响应拦截器axios.interceptors.response.use(function (response) &#123; console.log('响应拦截器 成功 1号'); return response.data; // return response;&#125;, function (error) &#123; console.log('响应拦截器 失败 1号') return Promise.reject(error);&#125;);axios.interceptors.response.use(function (response) &#123; console.log('响应拦截器 成功 2号') return response;&#125;, function (error) &#123; console.log('响应拦截器 失败 2号') return Promise.reject(error);&#125;);//发送请求axios(&#123; method: 'GET', url: 'http://localhost:3000/posts'&#125;).then(response =&gt; &#123; console.log('自定义回调处理成功的结果'); console.log(response);&#125;); 默认配置1234567891011121314// 默认配置// 设置基础 URLaxios.defaults.baseURL = 'http://localhost:3000';// 设置默认的请求类型为 GETaxios.defaults.method = 'GET';// 默认请求时间axios.defaults.timeout = 3000;axios.defaults.params = &#123; id: 100 &#125;;axios(&#123; url: '/posts'&#125;).then(response =&gt; &#123; console.log(response);&#125;) 其他请求/相应数据转换器12345678// 请求转换器: 对请求头和请求体数据进行特定处理的函数if (utils.isObject(data)) &#123; setContentTypeIfUnset(headers, 'application/json;charset=utf-8'); return JSON.stringify(data);&#125;// 响应转换器: 将响应体 json 字符串解析为 js 对象或数组的函数response.data = JSON.parse(response.data) response与error的整体结构1234// response的整体结构&#123; data, status, statusText, headers, config, request &#125;// error的整体结构&#123; message, response, request &#125; ajax fetch和axios的区别ajax&emsp;&emsp;本身是针对MVC的编程，不符合现在前端MVVM的浪潮基于原生的XHR开发，XHR本身的架构不够清晰，已经有了fetch的替代方案。 fetch&emsp;&emsp;fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中Promise对象。&emsp;&emsp;fetch的代码结构比ajax简单多了，但fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。 优点 符合关注分离: 没有将输入、输出和用事件来跟踪的状态混杂在一个对象里。 更加底层，提供的API丰富，是更好更方便的写法。 脱离了XHR，是ES规范里新的实现方式。 缺点 fetch只对网络请求报错，对400、500都当成成功的请求，需要封装去处理。 fetch默认不会带cookie，需要添加配置项。 fetch不支持abort(中止) 、不支持超时控制，使用setTimeout及Promise.reject实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费。 fetch不能原生检测请求的进度，而XHR可以。 axios&emsp;&emsp;Axios是一个基于promise的HTTP库，可以在浏览器和Nodejs中使用。 特性 从浏览器中创建XMLHttpRequests 从Node.js中创建http请求 支持Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换JSON数据 客户端支持防御XSRF 参考视频及博客&emsp;&emsp;视频：3小时Ajax入门到精通，尚硅谷Web前端axios入门与源码解析&emsp;&emsp;博客：Ajax、Axios学习笔记","categories":[{"name":"Web开发与应用","slug":"Web开发与应用","permalink":"http://cxx0822.github.io/categories/Web开发与应用/"}],"tags":[]},{"title":"Web安全框架与简单应用","slug":"Web安全框架与简单应用","date":"2021-11-24T09:07:26.000Z","updated":"2022-03-21T06:19:12.618Z","comments":true,"path":"2021/11/24/web-an-quan-kuang-jia-yu-jian-dan-ying-yong/","link":"","permalink":"http://cxx0822.github.io/2021/11/24/web-an-quan-kuang-jia-yu-jian-dan-ying-yong/","excerpt":"","text":"平台及技术栈&emsp;&emsp;开发：Windows 10，部署：Ubuntu 18.04&emsp;&emsp;后端框架：Spring Boot 2.5.8&emsp;&emsp;前端框架： Vue 2.6.10 项目地址&emsp;&emsp;github Web安全系统简介&emsp;&emsp;软件应用系统安全主要包括认证（登录）和授权（权限管理）两部分，通常称为权限管理。&emsp;&emsp;安全框架主要是解决应用系统中的两类问题：认证和授权。其中认证就是登录，即判断用户是否是系统的合法用户；而授权就是权限设计与验证，即判断该用户是否具备访问系统中某些资源的权限。&emsp;&emsp;目前，在Java安全框架中有Spring Security和Apache Shiro两个比较优秀的架构。 Spring Security和Apache ShiroSpring Security&emsp;&emsp;官网，源代码。&emsp;&emsp;Spring Security是强大的，且容易定制的，基于Spring开发的实现认证登录与资源授权的应用安全框架。&emsp;&emsp;Spring Security的核心功能： Authentication：认证，用户登陆的验证（解决你是谁的问题） Authorization：授权，授权系统资源的访问权限（解决你能干什么的问题） 安全防护，防止跨站请求，session攻击等 Apache Shiro&emsp;&emsp;官网。&emsp;&emsp;Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码学和会话管理。使用Shiro易于理解的API，可以快速、轻松地获得任何应用程序，从最小的移动应用程序到最大的网络和企业应用程序。&emsp;&emsp;三个核心组件：Subject，SecurityManager和Realms。 Subject：即当前操作用户。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着当前跟软件交互的东西。但考虑到大多数目的和用途，你可以把它认为是Shiro的用户概念。Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。 SecurityManager：它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。 Realm：Realm充当了Shiro与应用安全数据间的桥梁或者连接器。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。 总结&emsp;&emsp;在Spring Boot项目中选用Spring Security的优点：Spring Security基于Spring开发，在已经选用Spring框架（尤其是Spring Boot框架）的项目下，Spring Security的使用更加方便。另外，Spring Security的功能也比Shiro的强大。&emsp;&emsp;在非Spring Boot项目下，选择Shiro的优点：Shiro的配置和使用比较简单，不需要任何框架和容器，可以单独运行，而Spring Security依赖Spring容器。 JWT简介&emsp;&emsp;JSON Web Token(JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。 JWT构成&emsp;&emsp;JSON Web Token由三部分构成，它们之间用圆点(.)连接。这三部分分别是：Header、Payload和Signature。 认证流程 浏览器发起请求登录，携带用户名和密码； 服务端验证身份，根据算法，将用户标识符打包生成token； 服务器返回JWT信息给浏览器，JWT不包含敏感信息； 浏览器发起请求获取用户资料，把刚刚拿到的token一起发送给服务器； 服务器发现数据中有token，验明正身； 服务器返回该用户的用户资料。 结合Spring Boot实现添加依赖12345678910111213&lt;!-- ======BEGIN jwt ====== --&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- ======END jwt ====== --&gt; JWT工具类&emsp;&emsp;JWTUtil.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class JWTUtil &#123; // 私有签名 private static final String SING = \"6Dx8SIuaHXJYnpsG18SSpjPs50lZcT52\"; /* * 生成token */ public static String getToken(Map&lt;String, String&gt; map)&#123; String token = null; Calendar instance = Calendar.getInstance(); // 默认7天过期 instance.add(Calendar.DATE, 7); // 创建jwt builder JWTCreator.Builder builder = JWT.create(); // 添加payload map.forEach((k, v) -&gt; &#123; builder.withClaim(k, v); &#125;); // 指定令牌过期时间 builder.withExpiresAt(instance.getTime()); // sign token = builder.sign(Algorithm.HMAC256(SING)); return token; &#125; /* * 验证token */ public static void verify(String token) throws Exception&#123; JWT.require(Algorithm.HMAC256(SING)).build().verify(token); &#125; /* * 获取信息 */ public static DecodedJWT getTokenInfo(String token) &#123; return JWT.require(Algorithm.HMAC256(SING)).build().verify(token); &#125;&#125; &emsp;&emsp;这里主要包含生成token和验证token两个主要的功能模块。 头部信息&emsp;&emsp;JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示。1234&#123; \"alg\": \"HS256\", \"typ\": \"JWT\"&#125; &emsp;&emsp;alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base64 URL算法将上述JSON对象转换为字符串保存。&emsp;&emsp;代码中使用了默认的头部值，当然也可以更改为其他的：12builder.setHeaderParam(\"typ\", \"JWT\") //令牌类型 .setHeaderParam(\"alg\", \"HS256\") //签名算法 有效载荷pyload&emsp;&emsp;有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。JWT指定七个默认字段供选择。1234567iss: jwt签发者sub: 主题aud: 接收jwt的一方exp: jwt的过期时间，这个过期时间必须要大于签发时间nbf: 定义在什么时间之前，该jwt都是不可用的.iat: jwt的签发时间jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击 &emsp;&emsp;除以上默认字段外，我们还可以自定义私有字段，如下例12345&#123; \"name\": \"Cxx\", \"admin\": true, \"avatar\": \"Cxx.jpg\"&#125; &emsp;&emsp;例如，在本例中，通过提供map参数，可以自定义添加任何信息。&emsp;&emsp;默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露。JSON对象也使用Base64 URL算法转换为字符串保存。 数字签名&emsp;&emsp;数字签名一般是随机生成的一长串字符串，是保存在服务器端的，任何时候都不能泄露出去。 有效时间&emsp;&emsp;为了提高token的有效性，一般还会设置其有效时间。 参考博客 五分钟带你了解啥是JWT JSON Web令牌(JWT)的原理，流程和数据结构 JWT认证原理、流程整合springboot实战应用,前后端分离认证的解决方案! &emsp;&emsp;注 这里所有的异常处理均放在全局异常处理中。 拦截器实现Spring Security实现Apache Shiro实现数据库系统配置用户数据信息表&emsp;&emsp;这里需要对用户密码进行加密处理，并以密文的方式存储在数据库中。 用户-角色-权限关系数据表&emsp;&emsp;这里采用目前比较普遍的权限设计模型：RBAC，即基于角色的访问控制(Role-Based Access Control)。&emsp;&emsp;一个用户可用具有多个角色，一个角色也可以具有多个权限控制，而权限控制也可以细分为可访问资源控制和可操作资源控制，即可以访问哪些菜单资源和可以执行哪些功能按钮。&emsp;&emsp;为了简化开发，这里设定为一个用户只能拥有一个角色。最终的关系图为：&emsp;&emsp;其中为了完整的描述用户-角色-权限三者的关系，还需要添加用户-角色表、角色-资源表和角色-操作表。 基于Spring Boot的Apache Shiro配置Shiro Config配置&emsp;&emsp;ShiroConfig.java：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091@Configurationpublic class ShiroConfig &#123; // 1.创建shiroFilter // 负责拦截所有请求 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager defaultWebSecurityManager, JwtFilter jwtFilter) &#123; // 实例化shiroFilter ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 给filter设置安全管理器 shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager); // 添加自定义过滤器 Map&lt;String, Filter&gt; filterMap = new HashMap&lt;&gt;(); filterMap.put(\"jwt\", jwtFilter); shiroFilterFactoryBean.setFilters(filterMap); // 配置拦截设置 Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(); // 不拦截swagger // anon为shiro自带的过滤器，即不拦截 map.put(\"/swagger-ui.html#/**\", \"anon\"); map.put(\"/v2/api-docs\", \"anon\"); map.put(\"/swagger-resources/**\", \"anon\"); map.put(\"/webjars/**\", \"anon\"); // 其余均用自定义jwt拦截 map.put(\"/**\", \"jwt\"); //默认认证界面路径---当认证不通过时跳转 shiroFilterFactoryBean.setLoginUrl(\"/user/login\"); shiroFilterFactoryBean.setUnauthorizedUrl(\"/user/login\"); shiroFilterFactoryBean.setFilterChainDefinitionMap(map); return shiroFilterFactoryBean; &#125; // 自定义过滤器，注入Bean中 @Bean public JwtFilter getJwtFilter() &#123; return new JwtFilter(); &#125; //2.创建安全管理器 @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(MyRealm myRealm, MyCredentialsMatcher myCredentialsMatcher) &#123; DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager(); // 设置Realm的自定义密码验证器 myRealm.setCredentialsMatcher(myCredentialsMatcher); // 设置自定义Realm defaultWebSecurityManager.setRealm(myRealm); return defaultWebSecurityManager; &#125; // 3.自定义realm 注入Bean中 @Bean public MyRealm getRealm() &#123; return new MyRealm(); &#125; // 自定义密码验证器 注入Bean中 @Bean public MyCredentialsMatcher getMyCredentialsMatcher() &#123; return new MyCredentialsMatcher(); &#125; /** * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions), * 需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证 * 配置以下两个bean(DefaultAdvisorAutoProxyCreator和AuthorizationAttributeSourceAdvisor)即可实现此功能 */ @Bean public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator()&#123; DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator(); advisorAutoProxyCreator.setProxyTargetClass(true); return advisorAutoProxyCreator; &#125; /** * 开启aop注解支持 */ @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123; AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; &#125;&#125; &emsp;&emsp;根据上文的shiro框架简介，配置文件主要可以分为3个部分。&emsp;&emsp;首先创建shiroFilter，负责拦截所有的请求，其中对于swagger测试页采用自带的anno拦截方式，即不拦截方式。其余均采用自定义过滤器jwt。&emsp;&emsp;其次需要配置安全管理器，这里采用自定义的Realm，且Realm中的密码验证器也需要结合jwt进行自定义设计。&emsp;&emsp;最后是将自定义的Realm注入到Springboot的Bean中。&emsp;&emsp;注：最后需要开启shiro的注解模式。 自定义过滤器&emsp;&emsp;JwtFilter.java：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// 自定义过滤器public class JwtFilter extends AuthenticatingFilter &#123; // 从请求中获取token信息,然后对String类型的token进行转换成JwtToken @Override protected AuthenticationToken createToken(ServletRequest servletRequest, ServletResponse servletResponse) throws Exception &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; // 前端获取X-Token String jwt = request.getHeader(\"X-Token\"); if (StringUtils.isEmpty(jwt)) &#123; return null; &#125; // 返回shiro中需要的Token格式 return new JwtToken(jwt); &#125; // 真正的拦截方法,判断请求是否带有token,没有token即为未登录状态,有token的为登录状态 // 若没有token直接放行(登录状态或者其他情况) // 若有token则需要判断这个token是否合法或者是否失效等 // 最后调用executeLogin方法,提交给登录 @Override protected boolean onAccessDenied(ServletRequest servletRequest, ServletResponse servletResponse) throws Exception &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; // 需要和前端的axios的header字段保持一致 String jwt = request.getHeader(\"X-Token\"); if (StringUtils.isEmpty(jwt)) &#123; return true; &#125; else &#123; // 校验jwt Claims claim = JwtUtil.parseJWT(jwt); // 判断token是否为空或者是否过期 if (claim == null || JwtUtil.isTokenExpired(claim.getExpiration())) &#123; HttpServletResponse response = (HttpServletResponse) servletResponse; response.setContentType(\"application/plain;charset=utf-8\"); PrintWriter writer = response.getWriter(); // 向前端发送过期错误提示 writer.write(JSON.toJSONString(R.setResult(ResultCodeEnum.TokenExpiredException))); return false; &#125; // 执行shiro中的登录方法 // 需要执行登录，否则获取接口时没有subject信息 return executeLogin(servletRequest, servletResponse); &#125; &#125; // 登录失败处理 @Override protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) &#123; HttpServletResponse httpServletResponse = (HttpServletResponse) response; Throwable throwable = e.getCause() == null ? e : e.getCause(); String json = JSON.toJSONString(R.error().message(e.getMessage())); try &#123; // 向前端返回错误信息 httpServletResponse.getWriter().print(json); &#125; catch (IOException ioException) &#123; ioException.printStackTrace(); &#125; return false; &#125; // 跨域处理 @Override protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception &#123; HttpServletRequest httpServletRequest = WebUtils.toHttp(request); HttpServletResponse httpServletResponse = WebUtils.toHttp(response); httpServletResponse.setHeader(\"Access-control-Allow-Origin\", httpServletRequest.getHeader(\"Origin\")); httpServletResponse.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS,PUT,DELETE\"); httpServletResponse.setHeader(\"Access-Control-Allow-Headers\", httpServletRequest.getHeader(\"Access-Control-Request-Headers\")); // 跨域时会首先发送一个OPTIONS请求，这里我们给OPTIONS请求直接返回正常状态 if (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) &#123; httpServletResponse.setStatus(org.springframework.http.HttpStatus.OK.value()); return false; &#125; return super.preHandle(request, response); &#125;&#125; &emsp;&emsp;自定义过滤器主要基于继承AuthenticatingFilter类实现。&emsp;&emsp;首先是从请求中获取token信息，然后对String类型的token进行转换成自定义的JwtToken类型。注意这里的request.getHeader()字段需要和前端保持一致！&emsp;&emsp;然后需要实现继承类的重载方法onAccessDenied()。当未获取到前端的token信息时，返回true放行(因此这里一定要保证前端发送的非登录请求是包含token信息的！)。否则需要对token进行简单的验证处理，如果过期则需要将错误信息返回至前端，最后执行shiro中的登录方法。&emsp;&emsp;最后实现登录失败和跨域处理的重载方法。 自定义JwtToken&emsp;&emsp;这里主要参考的是shiro框架中的UsernamePasswordToken实现的一些构造函数等信息。 自定义Realm&emsp;&emsp;这里参考下文的认证和授权部分。 安全认证过程&emsp;&emsp;身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和密码，看其是否与系统中存储的该用户的用户名和密码一致，来判断用户身份是否正确。 关键对象 Subject：主体访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体； Principal：身份信息是主体(subject)进行身份认证的标识，标识必须具有唯一性，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份(Primary Principal)。 credential：凭证信息是只有主体自己知道的安全信息，如密码、证书等。 认证流程&emsp;&emsp;在自定义的MyRealm.java中需要实现protected AuthenticationInfo doGetAuthenticationInfo()方法的重载：12345678910111213141516171819202122// 验证@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; JwtToken jwtToken = (JwtToken) authenticationToken; // Jwt获取username String token = (String) jwtToken.getPrincipal(); // 拿到token Claims claims = JwtUtil.parseJWT(token); // 解析jwt String username = claims.getId(); // jwt中拿到username // 数据库获取用户信息并验证 QueryWrapper&lt;User&gt; userQueryWrapper = new QueryWrapper&lt;&gt;(); userQueryWrapper.eq(\"username\", username); User user = userMapper.selectOne(userQueryWrapper); if(user == null)&#123; return null; &#125; // 返回密码对比结果 这里会保存用户的用户名和密码，以便后续的密码验证 return new SimpleAuthenticationInfo(username, user.getPassword(), getName());&#125; &emsp;&emsp;首先通过传入的token信息拿到用户名信息，然后获取到数据库中的用户名和用户名密码信息，并将这些信息传入SimpleAuthenticationInfo()方法中进行密码验证。&emsp;&emsp;这里由于采用了MD5+盐值+迭代的加密算法，因此需要自定义密码验证器。&emsp;&emsp;MyCredentialsMatcher.java：12345678910111213141516171819202122232425262728293031323334353637// 自定义密码验证器@Componentpublic class MyCredentialsMatcher extends SimpleCredentialsMatcher &#123; @Autowired private UserMapper userMapper; // 判断密码是否一致 @Override public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123; // 前端返回的token JwtToken jwtToken = (JwtToken) token; if(jwtToken.getPassword() == null) &#123; return true; &#125; // 根据token获取输入的密码 String inputPassword = new String(jwtToken.getPassword()); // 根据Realm中存储的用户名和密码得到数据库密码 String username = String.valueOf(info.getPrincipals()); String dbPassword = (String) info.getCredentials(); // 获取数据库盐值 QueryWrapper&lt;User&gt; userQueryWrapper = new QueryWrapper&lt;&gt;(); userQueryWrapper.eq(\"username\", username); User user = userMapper.selectOne(userQueryWrapper); String salt = user.getSalt(); // 重新对密码加密 md5+盐值+迭代次数 String md5Password = new SimpleHash(\"md5\", inputPassword, salt, 1024).toHex(); // 比较加密后的密码和数据库(shiro)中的密码 return this.equals(md5Password, dbPassword); &#125;&#125; &emsp;&emsp;这里的盐值为新建用户时随机生成并保存到数据库中的盐值信息。 授权流程&emsp;&emsp;授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的。 关键对象&emsp;&emsp;授权可简单理解为who对what(which)进行How操作： Who，即主体(Subject)，主体需要访问系统中的资源。 What，即资源(Resource)，如系统菜单、页面、按钮、类方法、系统商品信息等。资源包括资源类型和资源实例，比如商品信息为资源类型，类型为t01的商品为资源实例，编号为001的商品信息也属于资源实例。 How，权限/许可(Permission)，规定了主体对资源的操作许可，权限离开资源没有意义，如用户查询权限、用户添加权限、某个类方法的调用权限、编号为001用户的修改权限等，通过权限可知主体对哪些资源都有哪些操作许可。 授权流程&emsp;&emsp;在自定义的MyRealm.java中需要实现protected AuthorizationInfo doGetAuthorizationInfo()方法的重载：12345678910111213141516171819202122232425262728// 授权@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; // 获取用户名 String username = (String) principalCollection.getPrimaryPrincipal(); // 根据用户名获取当前用户的角色信息，以及权限信息 SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); // 数据库中获取用户的角色信息 QueryWrapper&lt;User&gt; userQueryWrapper = new QueryWrapper&lt;&gt;(); userQueryWrapper.eq(\"username\", username); User user = userMapper.selectOne(userQueryWrapper); QueryWrapper&lt;UserRole&gt; userRoleQueryWrapper = new QueryWrapper&lt;&gt;(); userRoleQueryWrapper.eq(\"user_id\", user.getId()); UserRole userRole = userRoleMapper.selectOne(userRoleQueryWrapper); QueryWrapper&lt;Role&gt; roleQueryWrapper = new QueryWrapper&lt;&gt;(); roleQueryWrapper.eq(\"id\", userRole.getRoleId()); Role role = roleMapper.selectOne(roleQueryWrapper); // 添加角色 权限信息 // admin simpleAuthorizationInfo.addRole(role.getRoleName()); simpleAuthorizationInfo.addStringPermission(\"user:*\"); return simpleAuthorizationInfo;&#125; &emsp;&emsp;本项目主要采用的在前端进行授权管理，这里主要演示shiro的授权功能。&emsp;&emsp;首先根据输入的信息获取到用户名信息，然后根据用户名查询其角色和权限信息，并将此信息通过simpleAuthorizationInfo.addRole()和simpleAuthorizationInfo.addStringPermission()添加至shiro中。&emsp;&emsp;最后在controller类中添加注解@RequiresRoles(&quot;admin&quot;)或@RequiresPermissions(&quot;user:update&quot;)即可实现权限控制。&emsp;&emsp;个人认为基于后端的权限控制是通过控制controller的访问权限机制实现的，其开放性和灵活性相较于前端不是太方便，因此本项目主要是通过前端实现权限管理控制，后端只需将所有的角色和资源信息发送至前端即可。 参考博客shiro的认证+shiro的授权 基于vue element admin的前端安全权限系统安全登录系统安全登录流程 login-&gt;index.Vue1234567891011121314151617181920212223handleLogin() &#123; // 表单验证 this.$refs.loginForm.validate(valid =&gt; &#123; if (valid) &#123; this.loading = true // 登录功能 store-&gt;modules-&gt;user.js:login() this.$store.dispatch('user/login', this.loginForm) .then(() =&gt; &#123; // 成功则进入主界面 // 在进入主界面前 会首先加载路由：permission.js this.$router.push(&#123; path: this.redirect || '/', query: this.otherQuery &#125;) this.$message.success('登录成功') this.loading = false &#125;) .catch(() =&gt; &#123; this.loading = false &#125;) &#125; else &#123; console.log('error submit!!') return false &#125; &#125;)&#125; &emsp;&emsp;首先是一个简单的表单验证，检查是否输入用户名和密码，验证通过则跳转至登录功能，如果登录成功，则跳转至主页面。 store-&gt;modules-&gt;user.js123456789101112131415login(&#123; commit &#125;, userInfo) &#123;// 结构解析const &#123; username, password &#125; = userInforeturn new Promise((resolve, reject) =&gt; &#123; login(&#123; username: username.trim(), password: password &#125;).then(response =&gt; &#123; const &#123; data &#125; = response // 存储token commit('SET_TOKEN', data.token) setToken(data.token) resolve() &#125;).catch(error =&gt; &#123; reject(error) &#125;)&#125;)&#125; &emsp;&emsp;首先调用api-&gt;user.js中的login()后端接口，如果成功则获取并存储token信息。 src-&gt;utils-&gt;request.js&emsp;&emsp;前后端所有的交互信息均在此文件中配置。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// create an axios instanceconst service = axios.create(&#123; baseURL: process.env.VUE_APP_BASE_API, timeout: 5000 &#125;)// request interceptorservice.interceptors.request.use( config =&gt; &#123; if (store.getters.token) &#123; config.headers['X-Token'] = getToken() &#125; return config &#125;, error =&gt; &#123; console.log(error) return Promise.reject(error) &#125;)// response interceptorservice.interceptors.response.use( response =&gt; &#123; const res = response.data if (res.code !== 20000) &#123; Message(&#123; message: res.message || 'Error', type: 'error', duration: 5 * 1000 &#125;) if (res.code === 50008 || res.code === 50012 || res.code === 50014) &#123; // to re-login MessageBox.confirm('You have been logged out, you can cancel to stay on this page, or log in again', 'Confirm logout', &#123; confirmButtonText: 'Re-Login', cancelButtonText: 'Cancel', type: 'warning' &#125;).then(() =&gt; &#123; store.dispatch('user/resetToken').then(() =&gt; &#123; location.reload() &#125;) &#125;) &#125; return Promise.reject(new Error(res.message || 'Error')) &#125; else &#123; return res &#125; &#125;, error =&gt; &#123; console.log('err' + error) Message(&#123; message: error.message, type: 'error', duration: 5 * 1000 &#125;) return Promise.reject(error) &#125;) &emsp;&emsp;首先实例化一个axios的对象，并配置好url路径。&emsp;&emsp;其次需要配置请求拦截器。如果已经获取到token信息，即此时是非登录页，在请求头headers中均添加X-Token字段。&emsp;&emsp;然后是配置响应拦截器。如果此时返回的code是50008或者其他自定义的code则执行相应的操作，否则其他不为20000的状态均进行错误拦截。&emsp;&emsp;最后是对错误信息的简单处理。&emsp;&emsp;注：这里的字段需要和后端的字段保持一致！ 路由管理系统&emsp;&emsp;本项目主要采用的方案是通过前端去进行路由和权限的控制，后端只需要向前端返回全部的角色信息、路由信息和操作信息等。&emsp;&emsp;这里的路由主要指的是，哪些角色可以访问哪些资源(路由)。 后端接口配置&emsp;&emsp;这里只针对部分接口解释说明，其余接口可参考源代码。 获取所有用户的角色信息&emsp;&emsp;UserMapper.java：123456789101112// 获取所有用户信息@Select(\"select * from user\")@Results(id = \"UserMap\", value = &#123; @Result(column = \"id\", property = \"id\", jdbcType = JdbcType.INTEGER, id = true), @Result(column = \"username\", property = \"username\", jdbcType = JdbcType.VARCHAR), @Result(column = \"nickname\", property = \"nickname\", jdbcType = JdbcType.VARCHAR), @Result(column = \"introduction\", property = \"introduction\", jdbcType = JdbcType.VARCHAR), @Result(column = \"avatar\", property = \"avatar\", jdbcType = JdbcType.VARCHAR), // 用户的角色信息 @Result(column = \"id\", property = \"roleList\", many = @Many(select = \"com.shiro.demo.service.mapper.RoleMapper.selectRolesByUserId\"))&#125;)List&lt;FrontUser&gt; getAllUsers(); &emsp;&emsp;这是通过自定义Sql语句和返回结果实现复杂的数据库查询。&emsp;&emsp;这里返回的数据和数据库中的原始数据并不一致，因此需要在实体类中自定义需要向前端返回的数据格式(这里针对User类自定义FrontUser类，即添加了roleList变量)。&emsp;&emsp;其中roleList项需要嵌套调用RoleMapper的selectRolesByUserId的接口方法。&emsp;&emsp;获取资源等其他信息同理。 前端路由配置前端路由管理流程 路由拦截&emsp;&emsp;vue-router在生成路由前，会首先进入router.beforeEach()函数，也即src-&gt;permission.js(注意文件路径，前端项目中有很多重名的文件)文件中定义的。&emsp;&emsp;permission.js：123456789101112131415161718192021222324252627282930try &#123; // get user info // note: roles must be a object array! such as: ['admin'] or ,['developer','editor'] // 获取当前用户的角色信息 const &#123; roles &#125; = await store.dispatch('user/getUserInfo') // 根据用户的角色信息生成动态信息表 // generate accessible routes map based on roles const accessRoutes = await store.dispatch('permission/generateRoutes', roles) // dynamically add accessible routes // 挂载到动态路由 router.addRoutes(accessRoutes) // 404 page must be placed at the end !!! // 否则会经常显示404 router.addRoutes([&#123; path: '*', redirect: '/404', hidden: true &#125;]) // hack method to ensure that addRoutes is complete // set the replace: true, so the navigation will not leave a history record next(&#123; ...to, replace: true &#125;)&#125; catch (error) &#123; // remove token and go to login page to re-login // await store.dispatch('user/resetToken') Message.error(error || 'Has Error') // next(`/login?redirect=$&#123;to.path&#125;`) // NProgress.done() next()&#125; &emsp;&emsp;首先获取到当前用户的角色信息，然后根据此角色信息，进入src-&gt;modules-&gt;permission.js中的generateRoutes()生成动态路由表：&emsp;&emsp;src-&gt;modules-&gt;permission.js：12345678910111213141516171819202122232425262728async generateRoutes(&#123; commit &#125;, roles) &#123; // 1.从后端数据库中获取所有的路由信息 const res = await getRoutes() const dbAsyncRoutes = res.data.data // 2.过滤路由 const myAsyncRoutes = dbAsyncRoutes.filter(curr =&gt; &#123; if (curr.children == null || curr.children.length === 0) &#123; delete curr.children &#125; return replaceComponent(curr) &#125;) // 3.根据角色动态生成路由 let accessedRoutes // 判断当前的角色列表中，是否有包含admin // 传入的roles信息为role_name if (roles.includes('admin')) &#123; // 所有路由都可以被访问，将ansyncRoutes改成从数据库中获取 accessedRoutes = myAsyncRoutes || [] &#125; else &#123; // 根据角色，过滤掉不能访问的路由表 accessedRoutes = filterAsyncRoutes(myAsyncRoutes, roles) &#125; commit('SET_ROUTES', accessedRoutes) return accessedRoutes &#125; &emsp;&emsp;这里需要从后端数据库中获取到所有的路由信息，然后进行过滤和生成。 路由配置&emsp;&emsp;最后所有的路由信息都会进入到src-&gt;router-&gt;index.js中去查找并生成。由于路由中的component参数需要指定为项目中的vue组件(例如：component: () =&gt; import(&#39;@/views/redirect/index&#39;))，而在数据库中只能用名字代替，因此这里需要先预设好对应的组件信息：&emsp;&emsp;src-&gt;router-&gt;index.js：123456export const componentMap = &#123; // 和数据库中的component字段绑定 'layout': require('@/layout').default, 'permission_role': () =&gt; import('@/views/permission/role').then(m =&gt; m.default), 'permission_user': () =&gt; import('@/views/permission/user').then(m =&gt; m.default)&#125; &emsp;&emsp;然后在src-&gt;modules-&gt;permission.js中替换后端路由字段component的信息。&emsp;&emsp;src-&gt;modules-&gt;permission.js：12345678910111213// 替换route对象中的componentfunction replaceComponent(comp) &#123; if (comp.component &amp;&amp; typeof (comp.component) === 'string') &#123; comp.component = componentMap[comp.component] &#125; if (comp.children &amp;&amp; comp.children.length &gt; 0) &#123; for (let i = 0; i &lt; comp.children.length; i++) &#123; comp.children[i] = replaceComponent(comp.children[i]) &#125; &#125; return comp&#125; 权限管理系统&emsp;&emsp;这里的权限主要指的是，哪些角色可以访问哪些路由中的哪些按钮或其他操作。例如，分配角色权限的角色可以访问查询用户，但不能访问创建和删除用户按钮。 后端接口配置&emsp;&emsp;所有的可操作的权限均在数据库permission表中。&emsp;&emsp;RoleMapper.java：12345// 根据permission获取能访问的角色信息@Select(&#123;\"select rl.role_name\", \"from role rl, role_permission rp, permission pm\", \"where pm.permission_name=#&#123;permissionName&#125; and pm.id=rp.permission_id and rp.role_id=rl.id\"&#125;)List&lt;String&gt; getRoleNameByPermissionName(String permissionName); &emsp;&emsp;这里需要跨表查询，最终返回角色名列表。 前端权限配置&emsp;&emsp;前端首先从后端拿到每个操作权限的角色信息：&emsp;&emsp;user.vue：123456789101112131415161718// 获取 能够操纵 各个操作权限的 角色信息async getOperateRoles() &#123; // 获取能够操作 创建用户 功能的所有角色名称 let res = await getRoleNameByPermissionName('createUser') this.createUserRoles = res.data.data // 获取能够操作 更新用户 功能的所有角色名称 res = await getRoleNameByPermissionName('updateUser') this.updateUserRoles = res.data.data // 获取能够操作 分配用户角色 功能的所有角色名称 res = await getRoleNameByPermissionName('assignUserRole') this.assignUserRoles = res.data.data // 获取能够操作 删除用户 功能的所有角色名称 res = await getRoleNameByPermissionName('deleteUser') this.deleteUserRoles = res.data.data&#125;, &emsp;&emsp;然后在每个按钮中添加v-if属性，并通过checkPermission()函数去判断是否拥有该角色并决定是否显示(v-if=&quot;checkPermission(createUserRoles)&quot;)：&emsp;&emsp;src-&gt;utils-&gt;permission.js：123456789101112131415161718export default function checkPermission(value) &#123; if (value &amp;&amp; value instanceof Array &amp;&amp; value.length &gt; 0) &#123; // 获取用户的角色信息 const roles = store.getters &amp;&amp; store.getters.roles // 具有该权限的角色信息 const permissionRoles = value // 判断该用户是否具有该权限 const hasPermission = roles.some(role =&gt; &#123; return permissionRoles.includes(role) &#125;) return hasPermission &#125; else &#123; // console.error(`need roles! Like v-permission=\"['admin','editor']\"`) return false &#125;&#125; 分配信息管理系统&emsp;&emsp;最后一部分是重新分配用户的角色信息、重新分配角色的路由/操作信息等。 后端接口配置分配角色资源&emsp;&emsp;RoleServiceImpl.java：123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic Boolean assignRoleMenu(Integer roleId, List&lt;Integer&gt; menuList) &#123; QueryWrapper&lt;RoleMenu&gt; roleMenuQueryWrapper = new QueryWrapper&lt;&gt;(); roleMenuQueryWrapper.select(\"menu_id\").eq(\"role_id\", roleId); List&lt;Object&gt; dbRoleMenuList = roleMenuMapper.selectObjs(roleMenuQueryWrapper); List&lt;Object&gt; listAll = new ArrayList(); listAll.addAll(menuList); listAll.addAll(dbRoleMenuList); LinkedHashSet&lt;Object&gt; newMenuList = new LinkedHashSet&lt;Object&gt;(listAll); // 是否添加/删除 成功标志 int insert = 0, delete = 0; for (Object menu : menuList) &#123; // 如果数据库中已有menu，则将合并后的newMenuList中的删除 if (dbRoleMenuList.contains(menu)) &#123; newMenuList.remove(menu); &#125; else &#123; newMenuList.remove(menu); RoleMenu roleMenu = new RoleMenu(); roleMenu.setRoleId(roleId); roleMenu.setMenuId((Integer) menu); // 插入新的menu insert = roleMenuMapper.insert(roleMenu); &#125; &#125; // 删除 数据库中存在，但更新的menu中不存在的数据 for (Object menu2 : newMenuList) &#123; roleMenuQueryWrapper.clear(); roleMenuQueryWrapper.eq(\"role_id\", roleId); roleMenuQueryWrapper.eq(\"menu_id\", menu2); delete = roleMenuMapper.delete(roleMenuQueryWrapper); &#125; if (insert == 0 &amp;&amp; delete == 0) &#123; return false; &#125; else &#123; return true; &#125;&#125; &emsp;&emsp;这里主要考虑到一个逻辑需求：当数据库存放的角色资源信息为[1,2,3]，此时前端传入的信息为[2,3,4]，正确的处理逻辑为：删除[1]，保留[2,3]，添加[4]。&emsp;&emsp;因此，这里首先将数据库中的信息和前端输入的信息合并成新的列表，然后遍历前端输入的信息，如果在数据库中已经存在，则不对数据库操作，并删除合并列表中的相应的数据，如果不存在，则添加至数据库中，最后判断此时合并的列表还剩下的元素，也就是数据库中存在，但前端没有传入的元素，也就是需要删除的元素。 前端分配系统配置&emsp;&emsp;前端实现比较简单，获取选择的数据并传入后端的接口即可。 项目展示登录登录表单及用户名和密码验证 登录登出token变化 未登录访问其他路由 分配系统分配用户角色 分配角色资源 分配角色操作 修复Bug1.前端路由树el-tree获取不到父节点数据&emsp;&emsp;解决：加上半选中状态的父节点id：1const selectedKeys = this.$refs.menuTree.getHalfCheckedKeys().concat(this.$refs.menuTree.getCheckedKeys()) 2.当分配角色信息为空时，后端会提示报错&emsp;&emsp;分析：后端接口为@RequestParam List&lt;Integer&gt; menuList，此时必须传入列表数据，而如果分配角色信息为空，则此时列表为空，不符合后端接口数据要求。&emsp;&emsp;解决：如果用户分配角色的信息为空，则向后端传入的数据为[-1]，后端通过分析传入的数据是否包含-1来判断逻辑。&emsp;&emsp;前端：123if (menuList.length === 0) &#123; menuList = 'menuList=-1' &#125; &emsp;&emsp;后端：123456789101112131415161718192021@ApiOperation(\"分配角色资源\")@RequestMapping(value = \"assignRoleMenu\", method = RequestMethod.POST)public R assignRoleMenu(Integer roleId, @RequestParam List&lt;Integer&gt; menuList) &#123; // 判断前端用户是否选择资源 if (menuList.contains(-1)) &#123; Integer delete = roleMenuService.delete(\"role_id\", String.valueOf(roleId)); if (delete != 0) &#123; return R.ok().message(\"分配成功\"); &#125; else &#123; return R.error().message(\"和数据库数据一致或分配失败\"); &#125; &#125;else &#123; Boolean result = roleService.assignRoleMenu(roleId, menuList); if (result) &#123; return R.ok().message(\"分配成功\"); &#125; else &#123; return R.error().message(\"和数据库数据一致或分配失败\"); &#125; &#125;&#125;","categories":[{"name":"Web开发与应用","slug":"Web开发与应用","permalink":"http://cxx0822.github.io/categories/Web开发与应用/"}],"tags":[]},{"title":"基于Blockly与ROSWeb的可视化编程基础开发","slug":"基于Blockly与ROSWeb的可视化编程基础开发","date":"2021-11-17T10:00:58.000Z","updated":"2022-03-21T06:19:12.757Z","comments":true,"path":"2021/11/17/ji-yu-blockly-yu-rosweb-de-ke-shi-hua-bian-cheng-ji-chu-kai-fa/","link":"","permalink":"http://cxx0822.github.io/2021/11/17/ji-yu-blockly-yu-rosweb-de-ke-shi-hua-bian-cheng-ji-chu-kai-fa/","excerpt":"","text":"平台简介&emsp;&emsp;基于Blockly与ROSWeb实现可视化turtlesim的Web界面基础开发。 环境搭建配置Vue环境&emsp;&emsp;安装以下依赖：123npm install blocklynpm install --save eval5npm i element-ui -S &emsp;&emsp;修改src-&gt;main.js：123456789101112131415161718192021222324252627282930// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import router from './router'Vue.config.productionTip = falseVue.use(ElementUI)Vue.config.ignoredElements.push('xml')Vue.config.ignoredElements.push('block')Vue.config.ignoredElements.push('field')Vue.config.ignoredElements.push('category')Vue.config.ignoredElements.push('sep')Vue.config.ignoredElements.push('value')Vue.config.ignoredElements.push('statement')Vue.config.ignoredElements.push('mutation')/* eslint-disable no-new */new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) &emsp;&emsp;这里主要是导入ElementUI和注册Blockly相关组件。 配置Blockly环境&emsp;&emsp;将node_modules-&gt;blockly-&gt;media所有的文件复制到static文件夹下，这里主要是blockly所需的媒体资源文件。 配置ROSWeb环境&emsp;&emsp;在static中新建文件夹rosweb，用于存放所需要的第三方JavaScript文件。&emsp;&emsp;其中roslib.js和ros3d.js为ros-web提供的库文件，剩余JavaScript文件为用于绘制3D可视化模型的库文件(主要为three.js框架及其依赖库)。&emsp;&emsp;然后在index.html入口文件中，将这些文件添加&lt;head&gt;标签中。123456&lt;script src=\"./static/rosweb/three.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/ColladaLoader.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/STLLoader.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/eventemitter2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/roslib.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/ros3d.js\"&gt;&lt;/script&gt; ESlint代码规范&emsp;&emsp;这里针对ESlint做一些代码规范处理，并添加ROSWeb全局变量。修改.eslintrc.js：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203module.exports = &#123; root: true, parserOptions: &#123; parser: 'babel-eslint', sourceType: 'module' &#125;, env: &#123; browser: true, node: true, es6: true, &#125;, extends: ['plugin:vue/recommended', 'eslint:recommended'], // add your custom rules here //it is base on https://github.com/vuejs/eslint-config-vue rules: &#123; \"vue/max-attributes-per-line\": [2, &#123; \"singleline\": 10, \"multiline\": &#123; \"max\": 1, \"allowFirstLine\": false &#125; &#125;], \"vue/singleline-html-element-content-newline\": \"off\", \"vue/multiline-html-element-content-newline\":\"off\", \"vue/name-property-casing\": [\"error\", \"PascalCase\"], \"vue/no-v-html\": \"off\", 'accessor-pairs': 2, 'arrow-spacing': [2, &#123; 'before': true, 'after': true &#125;], 'block-spacing': [2, 'always'], 'brace-style': [2, '1tbs', &#123; 'allowSingleLine': true &#125;], 'camelcase': [0, &#123; 'properties': 'always' &#125;], 'comma-dangle': [2, 'never'], 'comma-spacing': [2, &#123; 'before': false, 'after': true &#125;], 'comma-style': [2, 'last'], 'constructor-super': 2, 'curly': [2, 'multi-line'], 'dot-location': [2, 'property'], 'eol-last': 2, 'eqeqeq': [\"error\", \"always\", &#123;\"null\": \"ignore\"&#125;], 'generator-star-spacing': [2, &#123; 'before': true, 'after': true &#125;], 'handle-callback-err': [2, '^(err|error)$'], 'indent': [2, 2, &#123; 'SwitchCase': 1 &#125;], 'jsx-quotes': [2, 'prefer-single'], 'key-spacing': [2, &#123; 'beforeColon': false, 'afterColon': true &#125;], 'keyword-spacing': [2, &#123; 'before': true, 'after': true &#125;], 'new-cap': [2, &#123; 'newIsCap': true, 'capIsNew': false &#125;], 'new-parens': 2, 'no-array-constructor': 2, 'no-caller': 2, 'no-console': 'off', 'no-class-assign': 2, 'no-cond-assign': 2, 'no-const-assign': 2, 'no-control-regex': 0, 'no-delete-var': 2, 'no-dupe-args': 2, 'no-dupe-class-members': 2, 'no-dupe-keys': 2, 'no-duplicate-case': 2, 'no-empty-character-class': 2, 'no-empty-pattern': 2, 'no-eval': 2, 'no-ex-assign': 2, 'no-extend-native': 2, 'no-extra-bind': 2, 'no-extra-boolean-cast': 2, 'no-extra-parens': [2, 'functions'], 'no-fallthrough': 2, 'no-floating-decimal': 2, 'no-func-assign': 2, 'no-implied-eval': 2, 'no-inner-declarations': [2, 'functions'], 'no-invalid-regexp': 2, 'no-irregular-whitespace': 2, 'no-iterator': 2, 'no-label-var': 2, 'no-labels': [2, &#123; 'allowLoop': false, 'allowSwitch': false &#125;], 'no-lone-blocks': 2, 'no-mixed-spaces-and-tabs': 2, 'no-multi-spaces': 2, 'no-multi-str': 2, 'no-multiple-empty-lines': [2, &#123; 'max': 1 &#125;], 'no-native-reassign': 2, 'no-negated-in-lhs': 2, 'no-new-object': 2, 'no-new-require': 2, 'no-new-symbol': 2, 'no-new-wrappers': 2, 'no-obj-calls': 2, 'no-octal': 2, 'no-octal-escape': 2, 'no-path-concat': 2, 'no-proto': 2, 'no-redeclare': 2, 'no-regex-spaces': 2, 'no-return-assign': [2, 'except-parens'], 'no-self-assign': 2, 'no-self-compare': 2, 'no-sequences': 2, 'no-shadow-restricted-names': 2, 'no-spaced-func': 2, 'no-sparse-arrays': 2, 'no-this-before-super': 2, 'no-throw-literal': 2, 'no-trailing-spaces': 2, 'no-undef': 2, 'no-undef-init': 2, 'no-unexpected-multiline': 2, 'no-unmodified-loop-condition': 2, 'no-unneeded-ternary': [2, &#123; 'defaultAssignment': false &#125;], 'no-unreachable': 2, 'no-unsafe-finally': 2, 'no-unused-vars': 'off', // 'no-unused-vars': [2, &#123; // 'vars': 'all', // 'args': 'none' // &#125;], 'no-useless-call': 2, 'no-useless-computed-key': 2, 'no-useless-constructor': 2, 'no-useless-escape': 0, 'no-whitespace-before-property': 2, 'no-with': 2, 'one-var': [2, &#123; 'initialized': 'never' &#125;], 'operator-linebreak': [2, 'after', &#123; 'overrides': &#123; '?': 'before', ':': 'before' &#125; &#125;], 'padded-blocks': [2, 'never'], 'quotes': [2, 'single', &#123; 'avoidEscape': true, 'allowTemplateLiterals': true &#125;], 'semi': [2, 'never'], 'semi-spacing': [2, &#123; 'before': false, 'after': true &#125;], 'space-before-blocks': [2, 'always'], 'space-before-function-paren': [2, 'never'], 'space-in-parens': [2, 'never'], 'space-infix-ops': 2, 'space-unary-ops': [2, &#123; 'words': true, 'nonwords': false &#125;], 'spaced-comment': [2, 'always', &#123; 'markers': ['global', 'globals', 'eslint', 'eslint-disable', '*package', '!', ','] &#125;], 'template-curly-spacing': [2, 'never'], 'use-isnan': 2, 'valid-typeof': 2, 'wrap-iife': [2, 'any'], 'yield-star-spacing': [2, 'both'], 'yoda': [2, 'never'], 'prefer-const': 2, 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, 'object-curly-spacing': [2, 'always', &#123; objectsInObjects: false &#125;], 'array-bracket-spacing': [2, 'never'], &#125;, \"globals\":&#123; \"ROSLIB\": true, \"ROS3D\": true &#125;&#125; 工具类blocklytools&emsp;&emsp;新建src-&gt;utils-&gt;blocklytools-&gt;myBlockly.js和src-&gt;utils-&gt;blocklytools-&gt;toolboxStyle.css.js: myBlockly.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// 引入Blocklyimport Blockly from 'blockly'// 1. 为了创建自定义类别，先创建自定义类别，继承自Blockly.ToolboxCategoryclass CustomCategory extends Blockly.ToolboxCategory &#123; // 自定义类别创造函数 // categoryDef: 类别定义的信息 // toolbox: 表示类别的父级toolbox // opt_parent: 可选参数，表示其父类别 constructor(categoryDef, toolbox, optParent) &#123; super(categoryDef, toolbox) &#125; // ToolboxCategory类中默认的方法addColourBorder_会在类别的左侧添加一个颜色条， // 在定制类CustomCategory中覆盖此方法，将其改为设置背景色 addColourBorder_(colour) &#123; this.rowDiv_.style.backgroundColor = colour &#125; // 如果两次点击某个类别，会发现背景色消失了， // 为了解决这个问题，重写setSelected这个方法 setSelected(isSelected) &#123; // 使用getElementsByClassName选中类别对应的span元素 var labelDom = this.rowDiv_.getElementsByClassName('blocklyTreeLabel')[0] if (isSelected) &#123; // 选中的类别背景色设置为白色 this.rowDiv_.style.backgroundColor = 'white' // 选中的类别文本设置为原背景色 labelDom.style.color = this.colour_ // 设置icon的颜色和文本颜色相同 this.iconDom_.style.color = this.colour_ &#125; else &#123; // 未选中的类别背景色设置 this.rowDiv_.style.backgroundColor = this.colour_ // 未选中的类别文本设置为白色 labelDom.style.color = 'black' // 设置icon的颜色和文本颜色相同 this.iconDom_.style.color = 'black' &#125; // This is used for accessibility purposes. Blockly.utils.aria.setState(/** @type &#123;!Element&#125; */ (this.htmlDiv_), Blockly.utils.aria.State.SELECTED, isSelected) &#125; // // 将icon图标改成image // createIconDom_ () &#123; // const img = document.createElement('img') // img.src = './logo_only.svg' // img.alt = '' // img.width = '35' // img.height = '25' // return img // &#125;&#125;// 2. 自定义类别需要向Blockly注册，告知自定义类别的存在，不然会无法识别新建的类Blockly.registry.register( Blockly.registry.Type.TOOLBOX_ITEM, Blockly.ToolboxCategory.registrationName, CustomCategory, true)export const initBlockly = (div, toolbox) =&gt; &#123; return Blockly.inject(div, &#123; // 工具栏 toolbox: document.getElementById(toolbox), // 网格效果 grid: &#123; spacing: 20, length: 3, colour: '#ccc', snap: true &#125;, // 媒体资源 (该框架下需要将资源文件放在public文件夹下) media: './static/media/', // 垃圾桶 trashcan: true, zoom: &#123; controls: true, wheel: true, startScale: 1.0, maxScale: 3, minScale: 0.3, scaleSpeed: 1.2 &#125; &#125; )&#125;export const initMyBlockly = () =&gt; &#123; Blockly.Blocks['turtlesim_move'] = &#123; init: function() &#123; this.appendValueInput('X') .setCheck('Number') .appendField('移动方向：x') this.appendValueInput('Y') .setCheck('Number') .appendField('移动方向：y') this.setInputsInline(false) this.setPreviousStatement(true, null) this.setNextStatement(true, null) this.setColour(230) this.setTooltip('') this.setHelpUrl('') &#125; &#125; Blockly.JavaScript['turtlesim_move'] = (block) =&gt; &#123; // 后面的 || '\\'\\'' 部分表示当输入为空时 返回的值 var x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_FUNCTION_CALL) var y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_FUNCTION_CALL) // 无输入 if (x === '' || y === '') &#123; return 'WAMERROR: 参数错误 请输入正确的参数！' &#125; else &#123; return 'turtlesimMove' + '(' + x + ',' + y + ')' + ';' + '\\n' // return 'test()' + ';' + '\\n' &#125; // 第二个参数为当前使用的操作符对应的优先级 https://www.wenjiangs.com/doc/wkeldh8c // return [code, Blockly.JavaScript.ORDER_FUNCTION_CALL] // return code &#125;&#125; &emsp;&emsp;这里主要重新设计了Blockly的样式，并自定义了一个turtlesim_move的代码块。 toolboxStyle.css12345678910111213141516171819202122232425262728293031323334/* 侧边栏样式 */.blocklyToolboxDiv&#123; /* background-color: #008B93; */&#125;/* 模块字体 */.blocklyTreeLabel &#123; color: black; font-size: 18px;&#125;/* 激活模块的样式 */.blocklyToolboxContents &#123; padding: .5em;&#125;/* Adds space between the categories, rounds the corners and adds space around the label. */.blocklyTreeRow &#123; padding: 1px; margin-bottom: 5px; border-radius: 3px; height: initial;&#125;/* Changes color of the icon to white. */.customIcon &#123; /* color: white; */ width: 30px;&#125;/* 模块样式 */.blocklyTreeRowContentContainer &#123; width: 100px; height: 40px; display: flex; flex-direction: row; align-items: center;&#125; &emsp;&emsp;这里主要是Blockly侧边栏的样式修改。 roswebtoolsturtlesim.js1234567891011121314151617181920212223export const callTurtlesimMoveService = (ros, x, y, z) =&gt; &#123; var service = new ROSLIB.Service(&#123; ros: ros, name: '/turtlesim_move', serviceType: 'turtlesim_move/turtlesim_move_srv' &#125;) var request = new ROSLIB.ServiceRequest(&#123; x: x, y: y, z: z &#125;) return new Promise((resolve, reject) =&gt; &#123; service.callService(request, (result) =&gt; &#123; resolve(result) // 异常处理 &#125;, (falseResult) =&gt; &#123; // 抛出异常 reject(new Error('error')) &#125;) &#125;)&#125; &emsp;&emsp;由于ROS话题(topic)和服务(service)的设计机制，当运行多个话题/服务时，只会运行最后一个，因此需要在应用层做一些逻辑处理。&emsp;&emsp;由于服务具有返回值的特性，可以根据返回值信息来判断是否进行下一个服务的调用，因此本项目ROS端的接口采用服务(service)的机制。&emsp;&emsp;本项目采用ES7提出的async和await异步特性，并结合Promise处理正确/异常信息，从而让其每次调用服务(service)时，都会等待其返回状态，并根据返回状态做下一步的处理。&emsp;&emsp;首先需要返回一个Promise对象，其包含2个参数，即resolve(解析)和reject(拒绝)。然后通过ROSWeb提供的callService(request, callback, failedCallback)判断服务(service)的完成状态。如果返回值为true，则解析并返回结果，如果返回值为false，则抛出异常，并结束该回调函数。&emsp;&emsp;最后在Web端通过async和await接收并处理该Promise(见下文分析)。 Web主界面&emsp;&emsp;HelloWorld.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407&lt;template&gt; &lt;div id=\"visualProgram\" class=\"visualProgram\"&gt; &lt;el-row :gutter=\"10\" type=\"flex\"&gt; &lt;el-col :span=\"12\"&gt; &lt;!-- blockly工作区 --&gt; &lt;div id=\"blocklyDiv\" class=\"div-blocklyDiv\"&gt; &lt;!-- blockly工具栏 --&gt; &lt;!-- xml不能在浏览器中正常渲染，因此需要设置为不可见 --&gt; &lt;xml id=\"toolbox\" style=\"display: none\"&gt; &lt;category name=\"逻辑控制\" colour=\"%&#123;BKY_LOGIC_HUE&#125;\"&gt; &lt;category name=\"If\" colour=\"#008B00\"&gt; &lt;block type=\"controls_if\" /&gt; &lt;block type=\"controls_if\"&gt; &lt;mutation else=\"1\" /&gt; &lt;/block&gt; &lt;block type=\"controls_if\"&gt; &lt;mutation elseif=\"1\" else=\"1\" /&gt; &lt;/block&gt; &lt;/category&gt; &lt;category name=\"Boolean\" colour=\"%&#123;BKY_LOGIC_HUE&#125;\"&gt; &lt;block type=\"logic_compare\" /&gt; &lt;block type=\"logic_operation\" /&gt; &lt;block type=\"logic_negate\" /&gt; &lt;block type=\"logic_ternary\" /&gt; &lt;/category&gt; &lt;category name=\"Loop\" colour=\"%&#123;BKY_LOOPS_HUE&#125;\"&gt; &lt;block type=\"controls_repeat_ext\"&gt; &lt;value name=\"TIMES\"&gt; &lt;block type=\"math_number\"&gt; &lt;field name=\"NUM\"&gt;10&lt;/field&gt; &lt;/block&gt; &lt;/value&gt; &lt;/block&gt; &lt;block type=\"controls_whileUntil\" /&gt; &lt;block type=\"controls_for\"&gt; &lt;field name=\"VAR\"&gt;i&lt;/field&gt; &lt;value name=\"FROM\"&gt; &lt;block type=\"math_number\"&gt; &lt;field name=\"NUM\"&gt;1&lt;/field&gt; &lt;/block&gt; &lt;/value&gt; &lt;value name=\"TO\"&gt; &lt;block type=\"math_number\"&gt; &lt;field name=\"NUM\"&gt;10&lt;/field&gt; &lt;/block&gt; &lt;/value&gt; &lt;value name=\"BY\"&gt; &lt;block type=\"math_number\"&gt; &lt;field name=\"NUM\"&gt;1&lt;/field&gt; &lt;/block&gt; &lt;/value&gt; &lt;/block&gt; &lt;block type=\"controls_forEach\" /&gt; &lt;block type=\"controls_flow_statements\" /&gt; &lt;/category&gt; &lt;/category&gt; &lt;category name=\"数学运算\" colour=\"%&#123;BKY_MATH_HUE&#125;\"&gt; &lt;block type=\"math_arithmetic\" /&gt; &lt;block type=\"math_single\" /&gt; &lt;block type=\"math_trig\" /&gt; &lt;block type=\"math_number_property\" /&gt; &lt;block type=\"math_round\" /&gt; &lt;block type=\"math_on_list\" /&gt; &lt;block type=\"math_modulo\" /&gt; &lt;block type=\"math_constrain\"&gt; &lt;value name=\"LOW\"&gt; &lt;block type=\"math_number\"&gt; &lt;field name=\"NUM\"&gt;1&lt;/field&gt; &lt;/block&gt; &lt;/value&gt; &lt;value name=\"HIGH\"&gt; &lt;block type=\"math_number\"&gt; &lt;field name=\"NUM\"&gt;100&lt;/field&gt; &lt;/block&gt; &lt;/value&gt; &lt;/block&gt; &lt;block type=\"math_random_int\"&gt; &lt;value name=\"FROM\"&gt; &lt;block type=\"math_number\"&gt; &lt;field name=\"NUM\"&gt;1&lt;/field&gt; &lt;/block&gt; &lt;/value&gt; &lt;value name=\"TO\"&gt; &lt;block type=\"math_number\"&gt; &lt;field name=\"NUM\"&gt;100&lt;/field&gt; &lt;/block&gt; &lt;/value&gt; &lt;/block&gt; &lt;block type=\"math_random_float\" /&gt; &lt;block type=\"math_atan2\" /&gt; &lt;/category&gt; &lt;category name=\"列表运算\" colour=\"%&#123;BKY_LISTS_HUE&#125;\"&gt; &lt;block type=\"lists_create_empty\" /&gt; &lt;block type=\"lists_create_with\" /&gt; &lt;block type=\"lists_repeat\"&gt; &lt;value name=\"NUM\"&gt; &lt;block type=\"math_number\"&gt; &lt;field name=\"NUM\"&gt;5&lt;/field&gt; &lt;/block&gt; &lt;/value&gt; &lt;/block&gt; &lt;block type=\"lists_length\" /&gt; &lt;block type=\"lists_isEmpty\" /&gt; &lt;block type=\"lists_indexOf\" /&gt; &lt;block type=\"lists_getIndex\" /&gt; &lt;block type=\"lists_setIndex\" /&gt; &lt;/category&gt; &lt;category name=\"文本控制\" colour=\"%&#123;BKY_TEXTS_HUE&#125;\"&gt; &lt;block type=\"text_length\" /&gt; &lt;block type=\"text_print\" /&gt; &lt;/category&gt; &lt;category name=\"常用变量\" colour=\"#556B2F\"&gt; &lt;block type=\"math_number\"&gt; &lt;field name=\"NUM\"&gt;1&lt;/field&gt; &lt;/block&gt; &lt;block type=\"math_number\"&gt; &lt;field name=\"NUM\"&gt;0&lt;/field&gt; &lt;/block&gt; &lt;block type=\"math_number\"&gt; &lt;field name=\"NUM\"&gt;-1&lt;/field&gt; &lt;/block&gt; &lt;block type=\"logic_boolean\" /&gt; &lt;block type=\"logic_null\" /&gt; &lt;block type=\"math_constant\" /&gt; &lt;block type=\"text\" /&gt; &lt;/category&gt; &lt;category name=\"ROS控制\" colour=\"#FF7F00\"&gt; &lt;block type=\"turtlesim_move\" /&gt; &lt;/category&gt; &lt;/xml&gt; &lt;div class=\"div-run-code\"&gt; &lt;el-button class=\"el-button-run-code\" icon=\"el-icon-video-play\" @click=\"runJavascriptCode\" /&gt; &lt;el-button class=\"el-button-run-code\" icon=\"el-icon-refresh\" @click=\"refreshJavascriptCode\" /&gt; &lt;el-button class=\"el-button-run-code\" icon=\"el-icon-video-pause\" @click=\"stopJavascriptCode\" /&gt; &lt;el-button class=\"el-button-run-code\" icon=\"el-icon-circle-close\" @click=\"clearWorkspace\" /&gt; &lt;!-- &lt;el-button @click=\"test\"&gt;测试&lt;/el-button&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=\"6\"&gt; &lt;div class=\"div-blockly-code\"&gt; &lt;!-- blockly代码区 --&gt; &lt;el-input v-model=\"blocklyCodeMessage\" :disabled=\"true\" :rows=\"39\" type=\"textarea\" class=\"el-input-blockly-code\" /&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=\"6\"&gt; &lt;div class=\"div-blockly-console\"&gt; &lt;!-- blockly代码控制台 --&gt; &lt;el-input v-model=\"blocklyConsoleMessage\" :disabled=\"true\" :rows=\"39\" type=\"textarea\" class=\"el-input-blockly-console\" /&gt; &lt;/div&gt; &lt;div class=\"div-clear-console\"&gt; &lt;el-button style=\"width:28px;height:28px;padding:0px;font-size:25px\" icon=\"el-icon-circle-close\" @click=\"clearConsoleMessage\" /&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// https://github.com/bplok20010/eval5import &#123; Interpreter &#125; from 'eval5'import * as myblock from '@/utils/blocklytools/myBlockly'// 引入Blocklyimport Blockly from 'blockly'// 引入想要转换的语言，语言有php python dart lua javascriptimport 'blockly/javascript'import 'blockly/python'// 引入语言包并使用import * as hans from 'blockly/msg/zh-hans'Blockly.setLocale(hans)import * as turtlesim from '@/utils/roswebtools/turtlesim'export default &#123; name: 'HelloWorld', data() &#123; return &#123; workspace: null, blocklyCodeMessage: '', blocklyConsoleMessage: '', jsCode: null, ros: null, isConnected: false, isRunWamNode: false, wamServerIp: '192.168.31.99', isDone: true &#125; &#125;, mounted() &#123; this.initBlockly() myblock.initMyBlockly() // 将自定义函数添加至window中，否则解析时，无法识别函数 window.turtlesimMove = this.turtlesimMove &#125;, created() &#123; this.ros = new ROSLIB.Ros(&#123; url: 'ws://' + this.wamServerIp + ':9090' &#125;) this.ros.on('connection', () =&gt; &#123; this.isConnected = true this.$message.success('连接ROS成功！') this.blocklyConsoleMessage += '连接ROS成功！' + '\\n' &#125;) this.ros.on('error', (e) =&gt; &#123; this.isConnected = false this.$message.error('连接ROS失败！') this.blocklyConsoleMessage += '连接ROS失败！' + '\\n' &#125;) this.ros.on('close', () =&gt; &#123; this.isConnected = false this.$message.error('关闭ROS连接！') this.blocklyConsoleMessage += '关闭ROS连接！' + '\\n' &#125;) &#125;, beforeDestroy() &#123; // 关闭ros连接 if (this.isConnected) &#123; this.ros.close() &#125; &#125;, methods: &#123; initBlockly() &#123; this.workspace = myblock.initBlockly('blocklyDiv', 'toolbox') // 工作区监听代码生成器 this.workspace.addChangeListener(this.myUpdateFunction) var toolbox = Blockly.getMainWorkspace().getToolbox() &#125;, // 代码生成器 myUpdateFunction(event) &#123; var codeJs = Blockly.JavaScript.workspaceToCode(this.workspace) this.blocklyCodeMessage = codeJs &#125;, async runJavascriptCode() &#123; // const interpreter = new Interpreter(window, &#123; // timeout: 1000 // &#125;) // 实例化JavaScript解释器eval5 const interpreter = new Interpreter(window) // Blokly获取JavaScript代码 this.jsCode = Blockly.JavaScript.workspaceToCode(this.workspace) try &#123; // 代码预检查 var isOk = this.checkCode() if (isOk) &#123; // 按分号切分指令 var stringList = this.jsCode.split(';') for (var i = 0; i &lt; stringList.length - 1; i++) &#123; // await 执行evaluate() var result = await interpreter.evaluate(stringList[i]) this.blocklyConsoleMessage += result + '\\n' &#125; // 异常处理 if (this.isDone === false) &#123; this.$message.error('运行错误！') &#125; &#125; else &#123; // 预检查错误 this.blocklyConsoleMessage += '运行错误' + '\\n' &#125; &#125; catch (e) &#123; // 运行错误 this.blocklyConsoleMessage += e + '\\n' &#125; &#125;, refreshJavascriptCode() &#123; this.isDone = true this.$message.success('重置程序') &#125;, stopJavascriptCode() &#123; this.$message.error('停止运行') &#125;, clearWorkspace() &#123; this.workspace.clear() this.$message.success('清除工作空间') &#125;, clearConsoleMessage() &#123; this.blocklyConsoleMessage = '' &#125;, async turtlesimMove(x, y) &#123; if (this.isDone) &#123; try &#123; this.isDone = false await turtlesim.callTurtlesimMoveService(this.ros, x, y, 0) this.isDone = true return 'turtlesim' + '向右移动了' + x + ',向上移动了' + y + '.' &#125; catch (error) &#123; this.isDone = false return '运行错误' &#125; &#125; &#125;, checkCode() &#123; // 没有错误 if (this.jsCode.length === 0) &#123; this.$message.error('请输入指令') return false &#125; else if (this.jsCode.indexOf('WAMERROR') === -1) &#123; return true &#125; else &#123; return false &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;#visualProgram .el-input-blockly-code /deep/ .el-textarea__inner&#123; color: black; background-color: white&#125;#visualProgram .el-input-blockly-console /deep/ .el-textarea__inner&#123; color: black; background-color: white&#125;&lt;/style&gt;&lt;!-- 这里需要是全局样式，即去掉scoped --&gt;&lt;!-- 这里加上页面的id https://www.jianshu.com/p/4ff9a5397427 --&gt;&lt;style&gt;@import \"../utils/blocklytools/toolboxStyle.css\";.div-blocklyDiv&#123; width:800px; height:850px; margin-top: 20px; margin-left: 20px; position: relative; border: 2px solid #008B93;&#125;.div-run-code&#123; position: absolute; right: 300px; /* bottom: 800px; */ bottom: 30px; z-index: 2;&#125;.el-button-run-code&#123; width:40px; height:40px; padding:0px; font-size:30px&#125;.div-blockly-code&#123; margin-top: 20px; height:850px; color: #008B93; border: 2px solid #008B93;&#125;.div-blockly-console&#123; margin-top: 20px; margin-right: 10px; height:850px; border: 2px solid #008B93;&#125;.el-input-blockly-code&#123; width: 99%; margin: 2px; border: 1px solid #008B93;&#125;.el-input-blockly-console&#123; width: 99%; margin: 2px; border: 1px solid #008B93;&#125;.div-clear-console&#123; position: absolute; right: 25px; top: 30px; z-index: 2;&#125;&lt;/style&gt; &emsp;&emsp;这里比较重要的代码部分为runJavascriptCode()函数和blockly生成的自定义函数，这里为turtlesimMove()。&emsp;&emsp;首先需要将turtlesimMove()声明为async的异步函数，并通过await调用ROSWeb的接口，保证每次都会等待服务(service)的返回状态。&emsp;&emsp;为了统一管理服务(service)返回的状态，这里通过全局变量isDone去处理，即如果正常执行完服务(service)，则将该变量置为true，否则一旦捕获到异常信息，则置为false。&emsp;&emsp;由于eval5并不支持在内部解析await，因此需要将blockly生成的代码字符串jsCode按行解析成单句，通过将runJavascriptCode()声明为async的异步函数，并使用await等待evaluate()的完成状态。&emsp;&emsp;这里会根据全局变量isDone来处理异常情况，一旦ROSWeb接收到异常的状态，会给出用户的错误信息提示。 Ros Service&emsp;&emsp;最后需要在ROS中重写服务(service)的接口。 Service类型&emsp;&emsp;在ROS工程文件夹下，新建srv-&gt;turtlesim_move_srv.srv：12345float32 xfloat32 yfloat32 z---bool result Service接口&emsp;&emsp;在ROS工程文件夹下，新建src-&gt;turtlesim_move.cpp：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/Twist.h&gt;#include &lt;turtlesim_move/turtlesim_move_srv.h&gt;#include &lt;iostream&gt;#include &lt;unistd.h&gt;ros::Publisher turtle_vel_pub;// service回调函数，输入参数req，输出参数resbool moveCallback(turtlesim_move::turtlesim_move_srv::Request &amp;req, turtlesim_move::turtlesim_move_srv::Response &amp;res)&#123; geometry_msgs::Twist vel_msg; vel_msg.linear.x = req.x; vel_msg.linear.y = req.y; vel_msg.linear.z = req.z; turtle_vel_pub.publish(vel_msg); // 设置反馈数据 sleep(2); res.result = true; return res.result;&#125;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, \"turtlesim_move_server\"); // 创建节点句柄 ros::NodeHandle n; // 创建一个名为/turtlesim_move的server，注册回调函数moveCallback ros::ServiceServer move_service = n.advertiseService(\"/turtlesim_move\", moveCallback); // 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(\"/turtle1/cmd_vel\", 10); ros::spin(); return 0;&#125; &emsp;&emsp;这里主要调用/turtle1/cmd_vel话题实现turtlesim的移动。&emsp;&emsp;这里的sleep(2);只是为了测试功能，实际的工程项目中，需要根据实际情况返回true/false状态。 编译运行&emsp;&emsp;CMakeLists.txt12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061cmake_minimum_required(VERSION 3.0.2)project(turtlesim_move)## Compile as C++11, supported in ROS Kinetic and newer# add_compile_options(-std=c++11)## Find catkin macros and libraries## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz)## is used, also find other catkin packagesfind_package(catkin REQUIRED COMPONENTS geometry_msgs roscpp rospy std_msgs turtlesim message_generation)## Generate services in the 'srv' folderadd_service_files(FILES turtlesim_move_srv.srv)## Generate added messages and services with any dependencies listed heregenerate_messages( DEPENDENCIES geometry_msgs std_msgs)##################################### catkin specific configuration ####################################### The catkin_package macro generates cmake config files for your package## Declare things to be passed to dependent projects## INCLUDE_DIRS: uncomment this if your package contains header files## LIBRARIES: libraries you create in this project that dependent projects also need## CATKIN_DEPENDS: catkin_packages dependent projects also need## DEPENDS: system dependencies of this project that dependent projects also needcatkin_package(# INCLUDE_DIRS include# LIBRARIES turtlesim_move# CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim# DEPENDS system_lib)############# Build ############### Specify additional locations of header files## Your package locations should be listed before other locationsinclude_directories(# include $&#123;catkin_INCLUDE_DIRS&#125;)## Specify libraries to link a library or executable target against# target_link_libraries($&#123;PROJECT_NAME&#125;_node# $&#123;catkin_LIBRARIES&#125;# )target_link_libraries(turtlesim_move $&#123;catkin_LIBRARIES&#125;) 功能测试&emsp;&emsp;依次启动ROS接口：123roslaunch rosbridge_server rosbridge_websocket.launchrosrun turtlesim turtlesim_noderosrun turtlesim_move turtlesim_move &emsp;&emsp;拖拽blockly控件，输入正确的参数，运行：","categories":[{"name":"Web前端开发与应用","slug":"Web前端开发与应用","permalink":"http://cxx0822.github.io/categories/Web前端开发与应用/"}],"tags":[]},{"title":"Web前后端基础开发实战","slug":"Web前后端基础开发实战","date":"2021-11-09T12:38:19.000Z","updated":"2022-03-21T06:19:12.613Z","comments":true,"path":"2021/11/09/web-qian-hou-duan-ji-chu-kai-fa-shi-zhan/","link":"","permalink":"http://cxx0822.github.io/2021/11/09/web-qian-hou-duan-ji-chu-kai-fa-shi-zhan/","excerpt":"","text":"平台/技术栈&emsp;&emsp;Windows 10(开发)/Ubuntu 18.04(部署)&emsp;&emsp;数据库：MySQL 8.0&emsp;&emsp;Web后端框架：Spring Boot&emsp;&emsp;数据库连接：JDBC + MyBatis Plus&emsp;&emsp;安全验证：JWT&emsp;&emsp;日志管理：Slf4j&emsp;&emsp;Web前端框架：Vue&emsp;&emsp;UI：Element UI&emsp;&emsp;前后端数据交互：axios 简介&emsp;&emsp;实现一个小型的数据库后台管理系统，包括登录和增删改查等基础功能。 数据库配置&emsp;&emsp;首先在Windows上安装并配置好数据库MySQL服务，并安装数据库软件。&emsp;&emsp;这里只是演示开发流程，只建立了2个表，即用户配置表和用户信息表。&emsp;&emsp;这里采用阿里巴巴数据库代码规范，即数据表必须包含3个字段：id、create_time和update_time，且字段全部为小写，用下划线分割。且主键设置为自增。&emsp;&emsp;在数据库软件中创建数据库Database web_demo，然后导入此sql文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980-- MySQL dump 10.13 Distrib 8.0.26, for Win64 (x86_64)---- Host: localhost Database: web_demo-- -------------------------------------------------------- Server version 8.0.27/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;/*!50503 SET NAMES utf8 */;/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;/*!40103 SET TIME_ZONE='+00:00' */;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;---- Table structure for table `user_config`--DROP TABLE IF EXISTS `user_config`;/*!40101 SET @saved_cs_client = @@character_set_client */;/*!50503 SET character_set_client = utf8mb4 */;CREATE TABLE `user_config` ( `id` int NOT NULL AUTO_INCREMENT COMMENT '表ID', `username` varchar(45) DEFAULT NULL COMMENT '用户名', `password` varchar(45) DEFAULT NULL COMMENT '密码', `create_time` datetime DEFAULT NULL COMMENT '创建时间', `update_time` datetime DEFAULT NULL COMMENT '更新时间', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;/*!40101 SET character_set_client = @saved_cs_client */;---- Dumping data for table `user_config`--LOCK TABLES `user_config` WRITE;/*!40000 ALTER TABLE `user_config` DISABLE KEYS */;/*!40000 ALTER TABLE `user_config` ENABLE KEYS */;UNLOCK TABLES;---- Table structure for table `user_info`--DROP TABLE IF EXISTS `user_info`;/*!40101 SET @saved_cs_client = @@character_set_client */;/*!50503 SET character_set_client = utf8mb4 */;CREATE TABLE `user_info` ( `id` int NOT NULL AUTO_INCREMENT, `name` varchar(45) DEFAULT NULL, `age` int DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3;/*!40101 SET character_set_client = @saved_cs_client */;---- Dumping data for table `user_info`--LOCK TABLES `user_info` WRITE;/*!40000 ALTER TABLE `user_info` DISABLE KEYS */;INSERT INTO `user_info` VALUES (1,'Cxx',18,'2021-11-10 17:31:55','2021-11-10 17:31:55');/*!40000 ALTER TABLE `user_info` ENABLE KEYS */;UNLOCK TABLES;/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;-- Dump completed on 2021-11-11 8:37:38 Web后端基本配置环境搭建&emsp;&emsp;这里采用Spring Boot V2.5.6版本和Java 1.8版本。 添加依赖&emsp;&emsp;在pom.xml中添加以下依赖：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;!-- 依赖版本管理 --&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mybatis-plus.version&gt;3.3.1&lt;/mybatis-plus.version&gt; &lt;velocity.version&gt;2.0&lt;/velocity.version&gt; &lt;swagger.version&gt;2.9.2&lt;/swagger.version&gt; &lt;aliyun.oss.version&gt;3.1.0&lt;/aliyun.oss.version&gt; &lt;jodatime.version&gt;2.10.1&lt;/jodatime.version&gt; &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt; &lt;commons-io.version&gt;2.6&lt;/commons-io.version&gt; &lt;commons-lang.version&gt;3.9&lt;/commons-lang.version&gt; &lt;httpclient.version&gt;4.5.1&lt;/httpclient.version&gt; &lt;jwt.version&gt;0.7.0&lt;/jwt.version&gt; &lt;aliyun-java-sdk-core.version&gt;4.3.3&lt;/aliyun-java-sdk-core.version&gt; &lt;aliyun-java-sdk-vod.version&gt;2.15.2&lt;/aliyun-java-sdk-vod.version&gt; &lt;aliyun-sdk-vod-upload.version&gt;1.4.11&lt;/aliyun-sdk-vod-upload.version&gt; &lt;fastjson.version&gt;1.2.28&lt;/fastjson.version&gt; &lt;gson.version&gt;2.8.2&lt;/gson.version&gt; &lt;json.version&gt;20170516&lt;/json.version&gt; &lt;commons-dbutils.version&gt;1.7&lt;/commons-dbutils.version&gt; &lt;canal.client.version&gt;1.1.0&lt;/canal.client.version&gt; &lt;docker.image.prefix&gt;zx&lt;/docker.image.prefix&gt; &lt;alibaba.easyexcel.version&gt;2.1.1&lt;/alibaba.easyexcel.version&gt; &lt;apache.xmlbeans.version&gt;3.1.0&lt;/apache.xmlbeans.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Web 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql JDBC驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus 持久层--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;$&#123;velocity.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger ui--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--json--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;$&#123;json.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;$&#123;gson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ======BEGIN jwt ====== --&gt; &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ======END jwt ====== --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Swagger UI配置&emsp;&emsp;在工程目录下，新建service-&gt;base-&gt;config-&gt;Myconfig.java(这里表示包的结构，下文有总的工程目录结构图。)：12345678910111213141516171819202122232425262728293031323334353637383940import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class MyConfig &#123; //配置swagger2核心配置docket //修改默认配置bean @Bean public Docket myDocket()&#123; return new Docket(DocumentationType.SWAGGER_2) //指定API类型为swagger2 .apiInfo(apiInfo()) //用于定于api文档汇总信息 .select() .apis(RequestHandlerSelectors .basePackage(\"com.web.demo.service.controller\")) //指定controller包 .paths(PathSelectors.any()) // 所有controller .build(); &#125; private ApiInfo apiInfo()&#123; return new ApiInfoBuilder() .title(\"Web前后端基础开发实战\") // 文档页标题 .contact(new Contact(\"Cxx\", // 联系人信息 \"www.baidu.com\", \"@email\")) .description(\"Web前后端基础开发实战\") // 详细信息 .version(\"1.0.1\") // 文档版本号 .termsOfServiceUrl(\"www.baidu.com\") //网站地址 .build(); &#125;&#125; &emsp;&emsp;注意更改myDocket()的包扫描位置basePackage参数为实际的工程目录。 数据库连接配置包扫描位置配置&emsp;&emsp;在工程目录下，新建service-&gt;base-&gt;config-&gt;MybatisPlusConfig.java：123456789101112import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;@EnableTransactionManagement@Configuration@MapperScan(\"com.web.demo.service.mapper\")public class MybatisPlusConfig &#123;&#125; &emsp;&emsp;注意更改注解参数MapperScan为实际的工程目录。 自动填充字段插件&emsp;&emsp;在工程目录下，新建service-&gt;base-&gt;handler-&gt;CommonMetaObjectHandler.java：123456789101112131415161718192021222324import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;@Slf4j@Componentpublic class CommonMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; //log.info(\"start insert fill ....\"); this.setFieldValByName(\"createTime\", new Date(), metaObject); this.setFieldValByName(\"updateTime\", new Date(), metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; //log.info(\"start update fill ....\"); this.setFieldValByName(\"updateTime\", new Date(), metaObject); &#125;&#125; yaml数据库连接配置&emsp;&emsp;在工程文件中，删除原有的resources-&gt;application.properties文件，并新建application.yaml文件：123456789101112131415spring: profiles: active: dev # 环境设置 application: name: web # 服务名 datasource: # mysql数据库连接 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/web_demo?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8 username: root password: #返回json的全局时间格式 #spring: jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss &emsp;&emsp;注意更改这里的url地址、数据库名称、账号和密码。 拦截器配置token生成&emsp;&emsp;在工程文件夹下，新建service-&gt;utils-JWTUtil.java：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import com.auth0.jwt.JWT;import com.auth0.jwt.JWTCreator;import com.auth0.jwt.algorithms.Algorithm;import com.auth0.jwt.interfaces.DecodedJWT;import java.util.Calendar;import java.util.Map;public class JWTUtil &#123; // 私有签名 private static final String SING = \"6Dx8SIuaHXJYnpsG18SSpjPs50lZcT52\"; /* * 生成token */ public static String getToken(Map&lt;String, String&gt; map)&#123; String token = null; Calendar instance = Calendar.getInstance(); // 默认7天过期 instance.add(Calendar.DATE, 7); // 创建jwt builder JWTCreator.Builder builder = JWT.create(); // 添加payload map.forEach((k, v) -&gt; &#123; builder.withClaim(k, v); &#125;); // 指定令牌过期时间 builder.withExpiresAt(instance.getTime()); // sign token = builder.sign(Algorithm.HMAC256(SING)); return token; &#125; /* * 验证token */ public static void verify(String token) throws Exception&#123; JWT.require(Algorithm.HMAC256(SING)).build().verify(token); &#125; /* * 获取信息 */ public static DecodedJWT getTokenInfo(String token) &#123; return JWT.require(Algorithm.HMAC256(SING)).build().verify(token); &#125;&#125; 拦截器配置&emsp;&emsp;在工程文件夹下，新建service-&gt;interceptor-JwtInterceptor.java：123456789101112131415161718import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;// 拦截器，解决每个接口都需要token导致的代码冗余问题public class JwtInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 获取请求头中的令牌 String token = request.getHeader(\"token\"); // 验证令牌 JWTUtil.verify(token); return true; &#125;&#125; &emsp;&emsp;在工程文件夹下，新建service-&gt;base-&gt;config-&gt;WebConfig.java：1234567891011121314151617181920212223import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; //配置跨域请求 public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowedHeaders(\"*\") .allowedMethods(\"*\"); &#125; // 拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new JwtInterceptor()) .addPathPatterns(\"/user-info/**\") // 拦截的接口 .excludePathPatterns(\"/user-config/login\"); // 登录接口 &#125;&#125; &emsp;&emsp;注意这里拦截器的路径为实际的controller接口地址。 统一返回值配置&emsp;&emsp;在工程文件夹下，新建service-&gt;result-&gt;R.java：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import java.util.HashMap;import java.util.Map;@Data@ApiModel(value = \"全局统一返回结果\")public class R &#123; @ApiModelProperty(value = \"是否成功\") private Boolean success; @ApiModelProperty(value = \"返回码\") private Integer code; @ApiModelProperty(value = \"返回消息\") private String message; @ApiModelProperty(value = \"返回数据\") private Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;(); public R()&#123;&#125; public static R ok()&#123; R r = new R(); r.setSuccess(ResultCodeEnum.SUCCESS.getSuccess()); r.setCode(ResultCodeEnum.SUCCESS.getCode()); r.setMessage(ResultCodeEnum.SUCCESS.getMessage()); return r; &#125; public static R error()&#123; R r = new R(); r.setSuccess(ResultCodeEnum.UNKNOWN_REASON.getSuccess()); r.setCode(ResultCodeEnum.UNKNOWN_REASON.getCode()); r.setMessage(ResultCodeEnum.UNKNOWN_REASON.getMessage()); return r; &#125; public static R setResult(ResultCodeEnum resultCodeEnum)&#123; R r = new R(); r.setSuccess(resultCodeEnum.getSuccess()); r.setCode(resultCodeEnum.getCode()); r.setMessage(resultCodeEnum.getMessage()); return r; &#125; public R success(Boolean success)&#123; this.setSuccess(success); return this; &#125; public R message(String message)&#123; this.setMessage(message); return this; &#125; public Boolean getSuccess() &#123; return success; &#125; public void setSuccess(Boolean success) &#123; this.success = success; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public Map&lt;String, Object&gt; getData() &#123; return data; &#125; public void setData(Map&lt;String, Object&gt; data) &#123; this.data = data; &#125; public R code(Integer code)&#123; this.setCode(code); return this; &#125; public R data(String key, Object value)&#123; this.data.put(key, value); return this; &#125; public R data(Map&lt;String, Object&gt; map)&#123; this.setData(map); return this; &#125;&#125; &emsp;&emsp;在工程文件夹下，新建service-&gt;result-&gt;ResultCodeEnum.java：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import lombok.Getter;import lombok.ToString;@Getter@ToStringpublic enum ResultCodeEnum &#123; SUCCESS(true, 20000,\"成功\"), UNKNOWN_REASON(false, 20001, \"未知错误\"), NullPointerException(false, 20001, \"空对象错误\"), SQLSyntaxErrorException(false, 20001, \"SQL语法错误\"), AlgorithmMismatchException(false, 20001, \"token算法不一致错误\"), TokenExpiredException(false, 20001, \"token过期错误\"), SignatureVerificationException(false, 20001, \"签名认证错误\"), JWTDecodeException(false, 20001, \"JWT解析错误\"); private Boolean success; private Integer code; private String message; public Boolean getSuccess() &#123; return success; &#125; public void setSuccess(Boolean success) &#123; this.success = success; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; ResultCodeEnum(Boolean success, Integer code, String message) &#123; this.success = success; this.code = code; this.message = message; &#125;&#125; 统一异常处理&emsp;&emsp;在工程文件夹下，新建service-&gt;base-&gt;handler-&gt;GlobalExceptionHandler.java：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import com.auth0.jwt.exceptions.AlgorithmMismatchException;import com.auth0.jwt.exceptions.JWTDecodeException;import com.auth0.jwt.exceptions.SignatureVerificationException;import com.auth0.jwt.exceptions.TokenExpiredException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(Exception.class) @ResponseBody public R error(Exception e)&#123; // e.printStackTrace(); // 是否需要在终端显示错误信息 return R.setResult(ResultCodeEnum.UNKNOWN_REASON); &#125; @ExceptionHandler(NullPointerException.class) @ResponseBody public R error(NullPointerException e) &#123; // e.printStackTrace(); return R.setResult(ResultCodeEnum.NullPointerException); &#125; @ExceptionHandler(SQLSyntaxErrorException.class) @ResponseBody public R error(SQLSyntaxErrorException e) &#123; // e.printStackTrace(); return R.setResult(ResultCodeEnum.SQLSyntaxErrorException); &#125; @ExceptionHandler(JWTDecodeException.class) @ResponseBody public R error(JWTDecodeException e)&#123; // e.printStackTrace(); return R.setResult(ResultCodeEnum.JWTDecodeException); &#125; @ExceptionHandler(SignatureVerificationException.class) @ResponseBody public R error(SignatureVerificationException e)&#123; //e.printStackTrace(); return R.setResult(ResultCodeEnum.SignatureVerificationException); &#125; @ExceptionHandler(TokenExpiredException.class) @ResponseBody public R error(TokenExpiredException e)&#123; //e.printStackTrace(); return R.setResult(ResultCodeEnum.TokenExpiredException); &#125; @ExceptionHandler(AlgorithmMismatchException.class) @ResponseBody public R error(AlgorithmMismatchException e)&#123; //e.printStackTrace(); return R.setResult(ResultCodeEnum.AlgorithmMismatchException); &#125;&#125; &emsp;&emsp;这里返回值中的常量为之前ResultCodeEnum类中定义好的，可以根据实际项目需求添加自定义异常处理。 统一日志处理&emsp;&emsp;首先安装IDEA彩色日志插件：grep console。&emsp;&emsp;在resources目录新建logback-spring.xml(只能是这个名字)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration scan=\"true\" scanPeriod=\"10 seconds\"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name=\"log.path\" value=\"D:/Cxx/SpringbootProjects/web_end_demo/log\" /&gt; &lt;!--控制台日志格式：彩色日志--&gt; &lt;!-- magenta:洋红 --&gt; &lt;!-- boldMagenta:粗红--&gt; &lt;!-- cyan:青色 --&gt; &lt;!-- white:白色 --&gt; &lt;!-- magenta:洋红 --&gt; &lt;property name=\"CONSOLE_LOG_PATTERN\" value=\"%yellow(%date&#123;yyyy-MM-dd HH:mm:ss&#125;) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)\"/&gt; &lt;!--文件日志格式--&gt; &lt;property name=\"FILE_LOG_PATTERN\" value=\"%date&#123;yyyy-MM-dd HH:mm:ss&#125; |%-5level |%thread |%file:%line |%logger |%msg%n\" /&gt; &lt;!--编码--&gt; &lt;property name=\"ENCODING\" value=\"UTF-8\" /&gt; &lt;!--输出到控制台--&gt; &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;!--日志级别--&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;!--日志格式--&gt; &lt;Pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/Pattern&gt; &lt;!--日志字符集--&gt; &lt;charset&gt;$&#123;ENCODING&#125;&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;appender name=\"INFO_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!--日志过滤器：此日志文件只记录INFO级别的--&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_info.log&lt;/file&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;charset&gt;$&#123;ENCODING&#125;&lt;/charset&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 每天日志归档路径以及格式 --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;500MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;appender name=\"WARN_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 日志过滤器：此日志文件只记录WARN级别的 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;WARN&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_warn.log&lt;/file&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;charset&gt;$&#123;ENCODING&#125;&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;appender name=\"ERROR_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 日志过滤器：此日志文件只记录ERROR级别的 --&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;log.path&#125;/log_error.log&lt;/file&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;charset&gt;$&#123;ENCODING&#125;&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!--开发环境--&gt; &lt;springProfile name=\"dev\"&gt; &lt;!--可以灵活设置此处，从而控制日志的输出--&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;appender-ref ref=\"INFO_FILE\" /&gt; &lt;appender-ref ref=\"WARN_FILE\" /&gt; &lt;appender-ref ref=\"ERROR_FILE\" /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!--生产环境--&gt; &lt;springProfile name=\"pro\"&gt; &lt;root level=\"ERROR\"&gt; &lt;appender-ref ref=\"ERROR_FILE\" /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; &emsp;&emsp;注意更改这里的log.path路径。&emsp;&emsp;在使用时，在类上面加上注解@Slf4j，然后在相应位置加上log.error(&quot;***&quot;);或者log.info(&quot;***&quot;);即可。&emsp;&emsp;如果需要打印出完整的错误信息，需要重写一个错误类，在utils包中新建ExceptionUtil.java：123456789101112131415161718192021222324252627282930313233import java.io.IOException;import java.io.PrintWriter;import java.io.StringWriter;public class ExceptionUtil &#123; public static String getMessage(Exception e) &#123; StringWriter sw = null; PrintWriter pw = null; try &#123; sw = new StringWriter(); pw = new PrintWriter(sw); // 将出错的栈信息输出到printWriter中 e.printStackTrace(pw); pw.flush(); sw.flush(); &#125; finally &#123; if (sw != null) &#123; try &#123; sw.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; if (pw != null) &#123; pw.close(); &#125; &#125; return sw.toString(); &#125;&#125; &emsp;&emsp;然后在需要的地方加上打印信息：log.error(ExceptionUtil.getMessage(e));。&emsp;&emsp;启动程序，即可在相应的日志文件夹中看到输出的日志文件。 项目配置文件结构&emsp;&emsp;最终的项目文件结构如图所示： 代码生成器&emsp;&emsp;这里使用MyBatis-Plus的代码生成器，通过 AutoGenerator可以快速生成Entity、Mapper、Mapper XML、Service、Controller等各个模块的代码。&emsp;&emsp;Entity为实体类，存放基本的数据定义，Mapper为数据库操作，Service为后端主要逻辑实现，Controller主要提供前端界面的接口。&emsp;&emsp;在工程文件夹下的test目录下面新建CodeGenerator.java文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.po.TableFill;import com.baomidou.mybatisplus.generator.config.rules.DateType;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import org.junit.jupiter.api.Test;import java.util.ArrayList;public class CodeGenerator &#123; @Test public void genCode() &#123; // 执行时 需要删除之前生成的 com包 String prefix = \"web_demo\"; // 数据表的名字 //String moduleName = \"edu\"; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 // 生成文件的路径 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath + \"/src/main/java\"); gc.setAuthor(\"Cxx\"); gc.setOpen(false); //生成后是否打开资源管理器 gc.setFileOverride(true); //重新生成时文件是否覆盖 gc.setServiceName(\"%sService\"); //去掉Service接口的首字母I gc.setIdType(IdType.ASSIGN_ID); //主键策略 gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型 gc.setSwagger2(true);//开启Swagger2模式 mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); //dsc.setUrl(\"jdbc:mysql://localhost:3306/\" + prefix + \"guli_\" + moduleName + \"?serverTimezone=GMT%2B8\"); dsc.setUrl(\"jdbc:mysql://localhost:3306/\" + prefix + \"?serverTimezone=GMT%2B8\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"\"); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); //pc.setModuleName(moduleName); //模块名 pc.setParent(\"com.web.demo.service\"); pc.setController(\"controller\"); pc.setEntity(\"entity\"); pc.setService(\"service\"); pc.setMapper(\"mapper\"); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略 //strategy.setTablePrefix(moduleName + \"_\");//设置表前缀不生成 strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略 strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作 //strategy.setLogicDeleteFieldName(\"is_deleted\");//逻辑删除字段名 //strategy.setEntityBooleanColumnRemoveIsPrefix(true);//去掉布尔值的is_前缀 //自动填充 TableFill createTime = new TableFill(\"create_time\", FieldFill.INSERT); TableFill updateTime = new TableFill(\"update_time\", FieldFill.INSERT_UPDATE); ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(createTime); tableFills.add(updateTime); strategy.setTableFillList(tableFills); // controller控制层 换成restcontroller 即返回值都是Json格式的 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125;&#125; &emsp;&emsp;注意更改相应的数据库和包位置信息。&emsp;&emsp;右击选择run&#39;genCode()&#39;即可。&emsp;&emsp;这里还需要在IDEA中安装lombok插件。并在所有生成的Mapper接口类中增加@Repository注解。 数据库CURD实现&emsp;&emsp;这里只根据Mybatic-plus提供的数据库接口实现简单的增删改查操作，仅供参考。如需复杂的数据库操作，可参考官网案例。MyBatis-Plus&emsp;&emsp;UserInfoController.java：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131@RestController@RequestMapping(\"/user-info\")public class UserInfoController &#123; @Autowired private UserInfoService userInfoService; @Autowired private UserInfoMapper userInfoMapper; @ApiOperation(\"所有用户信息列表\") @GetMapping(\"listAll\") public R listAll()&#123; List&lt;UserInfo&gt; userInfoList = userInfoService.list(); return R.ok().data(\"userInfoList\", userInfoList); &#125; // Swagger-ui测试接口 @ApiOperation(\"注册用户信息\") @PostMapping(\"register\") public R register(@ApiParam(value = \"用户信息\", required = true) @RequestBody UserInfo userInfo)&#123; String name = userInfo.getName(); Integer age = userInfo.getAge(); if(name == null || name.length() == 0 || age == null)&#123; return R.error().message(\"请输入正确的用户信息\"); &#125; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", name); List&lt;UserInfo&gt; userInfoList = userInfoMapper.selectByMap(map); if(userInfoList.size() != 0)&#123; return R.error().message(\"用户已存在\"); &#125;else&#123; boolean result = userInfoService.save(userInfo); if (result) &#123; return R.ok().message(\"注册成功\"); &#125; else &#123; return R.error().message(\"注册失败\"); &#125; &#125; &#125; // Postman测试接口 @ApiOperation(\"注册用户信息\") @RequestMapping(value = \"register2\", method = RequestMethod.POST) public R register2(UserInfo userInfo)&#123; String name = userInfo.getName(); Integer age = userInfo.getAge(); if(name == null || name.length() == 0 || age == null)&#123; return R.error().message(\"请输入正确的用户信息\"); &#125; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", name); List&lt;UserInfo&gt; userInfoList = userInfoMapper.selectByMap(map); if(userInfoList.size() != 0)&#123; return R.error().message(\"用户已存在\"); &#125;else&#123; boolean result = userInfoService.save(userInfo); if (result) &#123; return R.ok().message(\"注册成功\"); &#125; else &#123; return R.error().message(\"注册失败\"); &#125; &#125; &#125; // Swagger-ui测试接口 @ApiOperation(\"根据姓名查询用户信息\") @GetMapping(\"get-userInfo-byName/&#123;name&#125;\") public R getUserInfoByName(@ApiParam(value = \"姓名\", required = true) @PathVariable String name) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", name); List&lt;UserInfo&gt; userInfoList = userInfoMapper.selectByMap(map); if (userInfoList.size() == 0) &#123; return R.error().message(\"查询失败，没有该用户信息\"); &#125;else &#123; return R.ok().data(\"userInfoList\", userInfoList); &#125; &#125; // Postman测试接口 @ApiOperation(\"根据姓名查询用户信息\") @RequestMapping(value = \"get-userInfo-byName\", method = RequestMethod.GET) public R getUserInfoByName2(String name)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", name); List&lt;UserInfo&gt; userInfoList = userInfoMapper.selectByMap(map); if (userInfoList.size() == 0) &#123; return R.error().message(\"查询失败，没有该用户信息\"); &#125;else &#123; return R.ok().data(\"userInfoList\", userInfoList); &#125; &#125; @ApiOperation(\"根据用户姓名删除用户信息\") @DeleteMapping(\"delete-userInfo-byName/&#123;name&#125;\") public R deleteUserInfoByName(@ApiParam(value = \"姓名\", required = true) @PathVariable String name) &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", name); int rows = userInfoMapper.deleteByMap(map); if(rows == 0)&#123; return R.error().message(\"该用户名不存在\"); &#125;else &#123; return R.ok().message(\"删除成功\"); &#125; &#125; @ApiOperation(\"根据姓名更新用户信息\") @PostMapping(\"update-userInfo-byName/&#123;name&#125;\") public R updateUserInfoByName(@ApiParam(value = \"姓名\", required = true) @PathVariable String name, @ApiParam(value = \"用户信息\", required = true) @RequestBody UserInfo userInfo) &#123; UpdateWrapper&lt;UserInfo&gt; userInfoUpdateWrapper = new UpdateWrapper&lt;&gt;(); userInfoUpdateWrapper.eq(\"name\", name); int row = userInfoMapper.update(userInfo, userInfoUpdateWrapper); if(row == 0)&#123; return R.error().message(\"用户名不存在\"); &#125;else &#123; return R.ok().message(\"修改成功\"); &#125; &#125;&#125; &emsp;&emsp;这里提供两种写法，主要用于Swagger-ui和Postman两种测试工具的使用。&emsp;&emsp;UserConfigController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687@RestController@RequestMapping(\"/user-config\")public class UserConfigController &#123; @Autowired private UserConfigService userConfigService; @Autowired private UserConfigMapper userConfigMapper; // Swagger-ui测试接口 @ApiOperation(\"登录\") @PostMapping(\"/login/&#123;username&#125;/&#123;password&#125;\") public R login(@ApiParam(value = \"用户名\", required = true) @PathVariable String username, @ApiParam(value = \"密码\", required = true) @PathVariable String password)&#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"username\", username); List&lt;UserConfig&gt; userConfigList = userConfigMapper.selectByMap(map); if(userConfigList.size() == 0)&#123; return R.error().message(\"用户不存在\"); &#125;else&#123; String truePassword = userConfigList.get(0).getPassword(); if(password.equals(truePassword))&#123; HashMap&lt;String, String&gt; tokenMap = new HashMap&lt;&gt;(); map.put(\"username\", username); return R.ok().data(\"token\", JWTUtil.getToken(tokenMap)); &#125;else &#123; return R.error().message(\"密码错误\"); &#125; &#125; &#125; // Postman测试接口 @ApiOperation(\"登录\") @RequestMapping(value = \"login\", method = RequestMethod.POST) public R login2(String username, String password)&#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"username\", username); List&lt;UserConfig&gt; userConfigList = userConfigMapper.selectByMap(map); if(userConfigList.size() == 0)&#123; return R.error().message(\"用户不存在\"); &#125;else&#123; String truePassword = userConfigList.get(0).getPassword(); if(password.equals(truePassword))&#123; HashMap&lt;String, String&gt; tokenMap = new HashMap&lt;&gt;(); map.put(\"username\", username); return R.ok().data(\"token\", JWTUtil.getToken(tokenMap)); &#125;else &#123; return R.error().message(\"密码错误\"); &#125; &#125; &#125; @ApiOperation(\"所有用户配置信息列表\") @RequestMapping(value = \"listAll\", method = RequestMethod.GET) public R listAll()&#123; List&lt;UserConfig&gt; userConfigList = userConfigService.list(); return R.ok().data(\"userConfigList\", userConfigList); &#125; @ApiOperation(\"注册用户配置信息\") @PostMapping(\"register\") public R register(@ApiParam(value = \"用户信息\", required = true) @RequestBody UserConfig userConfig)&#123; String username = userConfig.getUsername(); String password = userConfig.getPassword(); if(username == null || username.length() == 0 || password == null || password.length() == 0)&#123; return R.error().message(\"请输入正确的用户信息\"); &#125; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"username\", username); List&lt;UserConfig&gt; userConfigList = userConfigMapper.selectByMap(map); if(userConfigList.size() != 0)&#123; return R.error().message(\"用户已存在\"); &#125;else&#123; boolean result = userConfigService.save(userConfig); if (result) &#123; return R.ok().message(\"注册成功\"); &#125; else &#123; return R.error().message(\"注册失败\"); &#125; &#125; &#125;&#125; &emsp;&emsp;注：这里加了拦截器功能，部分接口在测试时，需要在Headers中提供有效的token。(建议使用Postman测试) Web前端&emsp;&emsp;这里主要采用目前比较成熟的一个web后台前端解决方案vue-element-admin。本项目主要使用的是其基础模板vue-admin-template。 环境配置&emsp;&emsp;根据官网文档提示，依次输入指令，配置环境。1234567891011# clone the projectgit clone https://github.com/PanJiaChen/vue-admin-template.git# enter the project directorycd vue-admin-template# install dependencynpm install# developnpm run dev 更改项目标题名称&emsp;&emsp;在src-&gt;settring.js文件中，修改title参数值。 前后端配置关闭警告提示&emsp;&emsp;在.eslintrc.js中屏蔽ESlint的定义未使用的警告提示：1\"no-unused-vars\": 0 关闭Mock虚拟数据&emsp;&emsp;在src-&gt;main.js中，注释掉以下内容：1234// if (process.env.NODE_ENV === 'production') &#123;// const &#123; mockXHR &#125; = require('../mock')// mockXHR()// &#125; 配置后端接口&emsp;&emsp;在.env.development文件中，将VUE_APP_BASE_API参数更改为自己的后端接口地址，如：http://127.0.0.1:8080 更改后端字段信息&emsp;&emsp;打开src-&gt;utils-&gt;request.js文件，更改相应的前后端字段信息。&emsp;&emsp;其中request部分主要为token字段信息：12// 更改为自己的token参数值config.headers['token'] = getToken() &emsp;&emsp;response部分需要修改的主要为后端提供的返回值格式和code值的含义信息等。&emsp;&emsp;该文件也是前后端交互的一个重要配置文件，所有的request和response均在这里处理。&emsp;&emsp;这里已经配置了错误信息的Message提示，在处理业务层逻辑时，如无特殊需求，可以不用考虑错误处理。 更改api后端接口&emsp;&emsp;在src-&gt;api文件中，每个数据表对应一个js文件，并在每个js文件中将参数设置为自己的实际后端接口。(注意data和params的区别。get/post请求params/data传参总结)&emsp;&emsp;这里也是实际的业务逻辑功能处理，这里仅根据上文提供的后端接口编写部分测试功能，仅供参考。 业务逻辑处理user.js1234567891011121314151617181920212223242526import request from '@/utils/request'export function login(username, password) &#123; // 调用utils中的request.js return request(&#123; url: '/user-config/login', method: 'post', params: &#123; username, password &#125; // data &#125;)&#125;export function getInfo(token) &#123; return request(&#123; url: '/user-config/listAll', method: 'get', params: &#123; token &#125; &#125;)&#125;export function logout() &#123; return request(&#123; url: '/user-config/logout', method: 'post' &#125;)&#125; &emsp;&emsp;这里主要提供了登录、登出和获取信息的功能接口，其中由于本案例后端提供的登录接口需要的参数格式为(String String)，因此这里的前端接口也需要做相应的更改。&emsp;&emsp;在src-&gt;store-&gt;modules-&gt;user.js中修改登录接口：123456789101112131415161718// user login login(&#123; commit &#125;, userInfo) &#123; const &#123; username, password &#125; = userInfo return new Promise((resolve, reject) =&gt; &#123; // .trim() 删除多余空格 // 调用api中的user.js // login(&#123; username: username.trim(), password: password &#125;).then(response =&gt; &#123; login(username.trim(), password).then(response =&gt; &#123; const &#123; data &#125; = response commit('SET_TOKEN', data.token) // 存储token setToken(data.token) resolve() &#125;).catch(error =&gt; &#123; reject(error) &#125;) &#125;) &#125;, &emsp;&emsp;这里也需要在后端增加登出接口：&emsp;&emsp;UserConfigController.java12345@ApiOperation(\"退出登录\")@RequestMapping(value = \"logout\", method = RequestMethod.POST)public R logout()&#123; return R.ok().message(\"退出成功\");&#125; user_info.js12345678910111213141516171819202122232425262728293031import request from '@/utils/request'export function getList() &#123; return request(&#123; url: '/user-info/listAll', method: 'get' &#125;)&#125;export function register(userInfo) &#123; return request(&#123; url: '/user-info/register', method: 'post', data: userInfo &#125;)&#125;export function deleteByName(name) &#123; return request(&#123; url: '/user-info/delete-userInfo-byName/' + name, method: 'delete' &#125;)&#125;export function updateByName(name, userInfo) &#123; return request(&#123; url: '/user-info/update-userInfo-byName/' + name, method: 'post', data: userInfo &#125;)&#125; &emsp;&emsp;注意这里的url、method和params/data参数的格式。 路由配置&emsp;&emsp;这里只是功能测试，可以先暂时注释掉不需要的路由。&emsp;&emsp;src-&gt;router-&gt;index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import Vue from 'vue'import Router from 'vue-router'Vue.use(Router)/* Layout */import Layout from '@/layout'/** * constantRoutes * a base page that does not have permission requirements * all roles can be accessed */export const constantRoutes = [ &#123; path: '/login', component: () =&gt; import('@/views/login/index'), hidden: true &#125;, &#123; path: '/404', component: () =&gt; import('@/views/404'), hidden: true &#125;, &#123; path: '/', component: Layout, redirect: '/dashboard', children: [&#123; path: 'dashboard', name: 'Dashboard', component: () =&gt; import('@/views/dashboard/index'), meta: &#123; title: 'Dashboard', icon: 'dashboard' &#125; &#125;] &#125;, // 404 page must be placed at the end !!! &#123; path: '*', redirect: '/404', hidden: true &#125;]const createRouter = () =&gt; new Router(&#123; // mode: 'history', // require service support scrollBehavior: () =&gt; (&#123; y: 0 &#125;), routes: constantRoutes&#125;)const router = createRouter()// Detail see: https://github.com/vuejs/vue-router/issues/1234#issuecomment-357941465export function resetRouter() &#123; const newRouter = createRouter() router.matcher = newRouter.matcher // reset router&#125;export default router &emsp;&emsp;仅保留登录、404页面和dashboard路由。 前端界面编写登录界面&emsp;&emsp;src-&gt;views-&gt;login-&gt;index.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253&lt;template&gt; &lt;div class=\"login-container\"&gt; &lt;div class=\"title-container\"&gt; &lt;h3 class=\"title\"&gt;Web前后端基础开发&lt;/h3&gt; &lt;/div&gt; &lt;el-form ref=\"loginForm\" :model=\"loginForm\" :rules=\"loginRules\" class=\"login-form\" auto-complete=\"on\" label-position=\"left\"&gt; &lt;el-form-item prop=\"username\"&gt; &lt;span class=\"svg-container\"&gt; &lt;svg-icon icon-class=\"user\" /&gt; &lt;/span&gt; &lt;el-input ref=\"username\" v-model=\"loginForm.username\" placeholder=\"Username\" name=\"username\" type=\"text\" tabindex=\"1\" auto-complete=\"on\" /&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=\"password\"&gt; &lt;span class=\"svg-container\"&gt; &lt;svg-icon icon-class=\"password\" /&gt; &lt;/span&gt; &lt;el-input :key=\"passwordType\" ref=\"password\" v-model=\"loginForm.password\" :type=\"passwordType\" placeholder=\"Password\" name=\"password\" tabindex=\"2\" auto-complete=\"on\" @keyup.enter.native=\"handleLogin\" /&gt; &lt;span class=\"show-pwd\" @click=\"showPwd\"&gt; &lt;svg-icon :icon-class=\"passwordType === 'password' ? 'eye' : 'eye-open'\" /&gt; &lt;/span&gt; &lt;/el-form-item&gt; &lt;el-button :loading=\"loading\" type=\"primary\" style=\"width:100%;margin-bottom:30px;\" @click.native.prevent=\"handleLogin\" &gt;登录&lt;/el-button&gt; &lt;!-- &lt;div class=\"tips\"&gt; &lt;span style=\"margin-right:20px;\"&gt;username: admin&lt;/span&gt; &lt;span&gt; password: any&lt;/span&gt; &lt;/div&gt; --&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; validUsername &#125; from '@/utils/validate'export default &#123; name: 'Login', data() &#123; const validateUsername = (rule, value, callback) =&gt; &#123; if (value.length &lt; 1) &#123; callback(new Error('请输入用户名')) &#125; else &#123; callback() &#125; &#125; const validatePassword = (rule, value, callback) =&gt; &#123; if (value.length &lt; 1) &#123; callback(new Error('请输入密码')) &#125; else &#123; callback() &#125; &#125; return &#123; loginForm: &#123; username: '', password: '' &#125;, loginRules: &#123; username: [&#123; required: true, trigger: 'blur', validator: validateUsername &#125;], password: [&#123; required: true, trigger: 'blur', validator: validatePassword &#125;] &#125;, loading: false, passwordType: 'password', redirect: undefined &#125; &#125;, watch: &#123; $route: &#123; handler: function(route) &#123; this.redirect = route.query &amp;&amp; route.query.redirect &#125;, immediate: true &#125; &#125;, methods: &#123; showPwd() &#123; if (this.passwordType === 'password') &#123; this.passwordType = '' &#125; else &#123; this.passwordType = 'password' &#125; this.$nextTick(() =&gt; &#123; this.$refs.password.focus() &#125;) &#125;, handleLogin() &#123; this.$refs.loginForm.validate(valid =&gt; &#123; if (valid) &#123; this.loading = true // 调用store中的user.js this.$store.dispatch('user/login', this.loginForm).then(() =&gt; &#123; this.$message.success('登录成功！') this.$router.push(&#123; path: this.redirect || '/' &#125;) this.loading = false &#125;).catch(() =&gt; &#123; this.loading = false &#125;) &#125; else &#123; this.$message.error('提交失败，请检查用户名和密码！') return false &#125; &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt;/* 修复input 背景不协调 和光标变色 *//* Detail see https://github.com/PanJiaChen/vue-element-admin/pull/927 */$bg:#283443;$light_gray:#fff;$cursor: #fff;$dark_black: #1C1C1C;@supports (-webkit-mask: none) and (not (cater-color: $cursor)) &#123; .login-container .el-input input &#123; color: $cursor; &#125;&#125;/* reset element-ui css */.login-container &#123; .el-input &#123; display: inline-block; height: 47px; width: 85%; input &#123; background: transparent; border: 0px; -webkit-appearance: none; border-radius: 0px; padding: 12px 5px 12px 15px; color: $dark_black; height: 47px; caret-color: $cursor; &amp;:-webkit-autofill &#123; box-shadow: 0 0 0px 1000px $bg inset !important; -webkit-text-fill-color: $cursor !important; &#125; &#125; &#125; .el-form-item &#123; border: 1px solid rgba(255, 255, 255, 0.1); background: rgba(0, 0, 0, 0.1); border-radius: 5px; color: #454545; &#125;&#125;&lt;/style&gt;&lt;style lang=\"scss\" scoped&gt;$bg:#2d3a4b;$dark_gray:#889aa4;$light_gray:#eee;$dark_black: #1C1C1C;.login-container &#123; min-height: 100%; width: 100%; overflow: hidden; // background-color: #E8E8E8; background-color: white; .login-form &#123; position:absolute; right:10%; top:35%; width: 400px; max-width: 100%; padding: 20px 20px 0; margin: 0 auto; overflow: hidden; border-radius: 10px; border: 2px solid #008B93; &#125; .tips &#123; font-size: 14px; color: $dark_black; margin-bottom: 10px; span &#123; &amp;:first-of-type &#123; margin-right: 16px; &#125; &#125; &#125; .svg-container &#123; padding: 6px 5px 6px 15px; color: $dark_black; vertical-align: middle; width: 30px; display: inline-block; &#125; .title-container &#123; position: relative; margin-top: 40px; .title &#123; font-size: 40px; color: #000000; margin: 0px auto 40px auto; text-align: center; font-weight: bold; &#125; &#125; .show-pwd &#123; position: absolute; right: 10px; top: 7px; font-size: 16px; color: $dark_black; cursor: pointer; user-select: none; &#125;&#125;&lt;/style&gt; 数据库CURD业务逻辑处理&emsp;&emsp;src-&gt;views-&gt;dashboard-&gt;index.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182&lt;template&gt; &lt;div class=\"app-container\"&gt; &lt;div class=\"div-table\"&gt; &lt;el-table v-loading=\"listLoading\" :data=\"list\" style=\"width:855px\" element-loading-text=\"Loading\" border fit highlight-current-row &gt; &lt;el-table-column align=\"center\" label=\"ID\" width=\"100\"&gt; &lt;template slot-scope=\"scope\"&gt; &#123;&#123; scope.$index &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"姓名\" width=\"150\" align=\"center\"&gt; &lt;template slot-scope=\"scope\"&gt; &#123;&#123; scope.row.name &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"年龄\" width=\"150\" align=\"center\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;span&gt;&#123;&#123; scope.row.age &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"创建时间\" width=\"150\" align=\"center\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;span&gt;&#123;&#123; scope.row.createTime &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"更新时间\" width=\"150\" align=\"center\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;span&gt;&#123;&#123; scope.row.updateTime &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"操作\" width=\"150\" align=\"center\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-button type=\"primary\" icon=\"el-icon-edit\" circle @click=\"handleEdit(scope.$index, scope.row)\" /&gt; &lt;el-button type=\"danger\" icon=\"el-icon-delete\" circle @click=\"handleDelete(scope.$index, scope.row)\" /&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-dialog title=\"用户信息\" :visible.sync=\"dialogUpdateUserInfoFormVisible\"&gt; &lt;el-form :model=\"userInfo\"&gt; &lt;el-form-item label=\"姓名\" label-width=\"120px\"&gt; &lt;el-input v-model=\"userInfo.name\" autocomplete=\"off\" :disabled=\"true\" /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"年龄\" label-width=\"120px\"&gt; &lt;el-input v-model=\"userInfo.age\" autocomplete=\"off\" /&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=\"footer\" class=\"dialog-footer\"&gt; &lt;el-button @click=\"dialogUpdateUserInfoFormVisible = false\"&gt;取 消&lt;/el-button&gt; &lt;el-button type=\"primary\" @click=\"updateUserInfo()\"&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt; &lt;div&gt; &lt;el-button type=\"primary\" style=\"margin-top:10px\" @click=\"handleRegister\"&gt;注册用户&lt;/el-button&gt; &lt;el-dialog title=\"用户信息\" :visible.sync=\"dialogRegisterUserInfoFormVisible\"&gt; &lt;el-form :model=\"userInfo\"&gt; &lt;el-form-item label=\"姓名\" label-width=\"120px\"&gt; &lt;el-input v-model=\"userInfo.name\" autocomplete=\"off\" /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"年龄\" label-width=\"120px\"&gt; &lt;el-input v-model=\"userInfo.age\" autocomplete=\"off\" /&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=\"footer\" class=\"dialog-footer\"&gt; &lt;el-button @click=\"dialogRegisterUserInfoFormVisible = false\"&gt;取 消&lt;/el-button&gt; &lt;el-button type=\"primary\" @click=\"registerUserInfo()\"&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; getList, register, deleteByName, updateByName &#125; from '@/api/user_info'export default &#123; filters: &#123; statusFilter(status) &#123; const statusMap = &#123; published: 'success', draft: 'gray', deleted: 'danger' &#125; return statusMap[status] &#125; &#125;, data() &#123; return &#123; list: null, listLoading: true, dialogUpdateUserInfoFormVisible: false, dialogRegisterUserInfoFormVisible: false, userInfo: &#123; 'name': null, 'age': null &#125; &#125; &#125;, created() &#123; this.fetchData() &#125;, methods: &#123; fetchData() &#123; this.listLoading = true getList().then(response =&gt; &#123; this.list = response.data.userInfoList this.listLoading = false &#125;) &#125;, handleEdit(index, row) &#123; this.dialogUpdateUserInfoFormVisible = true this.userInfo['name'] = row.name &#125;, updateUserInfo() &#123; this.dialogUpdateUserInfoFormVisible = false updateByName(this.userInfo.name, this.userInfo).then(response =&gt; &#123; this.$message.success('修改成功') this.userInfo['age'] = null this.fetchData() &#125;) &#125;, handleDelete(index, row) &#123; this.$confirm('此操作将永久删除该数据, 是否继续?', '提示', &#123; confirmButtonText: '确定', cancelButtonText: '取消', type: 'warning' &#125;).then(() =&gt; &#123; deleteByName(row.name).then(response =&gt; &#123; this.$message.success('删除成功') this.fetchData() &#125;) &#125;).catch(() =&gt; &#123; this.$message.info('已取消删除') &#125;) &#125;, handleRegister() &#123; this.dialogRegisterUserInfoFormVisible = true &#125;, registerUserInfo() &#123; this.dialogRegisterUserInfoFormVisible = false register(this.userInfo).then(response =&gt; &#123; this.$message.success('注册成功') this.userInfo['name'] = null this.userInfo['age'] = null this.fetchData() &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;.el-table&#123; border: 2px solid #008B93;&#125;&lt;/style&gt; 注意事项 拦截器JwtInterceptor接口修改&emsp;&emsp;JwtInterceptor.java 1234567891011121314151617181920212223// 拦截器，解决每个接口都需要token导致的代码冗余问题public class JwtInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 这里是个坑，因为带请求带headers时，ajax会发送两次请求， // 第一次会发送OPTIONS请求，第二次才会发生get/post请求，所以要放行OPTIONS请求 // 如果是OPTIONS请求，让其响应一个 200状态码，说明可以正常访问 if (HttpMethod.OPTIONS.toString().equals(request.getMethod())) &#123; response.setStatus(HttpServletResponse.SC_OK); // 放行OPTIONS请求 return true; &#125; // 获取请求头中的令牌 String token = request.getHeader(\"token\"); // 验证令牌 JWTUtil.verify(token); return true; &#125;&#125; Linux部署","categories":[{"name":"Web开发与应用","slug":"Web开发与应用","permalink":"http://cxx0822.github.io/categories/Web开发与应用/"}],"tags":[]},{"title":"基于Blockly的可视化编程","slug":"基于Blockly的可视化编程","date":"2021-10-21T16:44:04.000Z","updated":"2022-03-21T06:19:12.760Z","comments":true,"path":"2021/10/22/ji-yu-blockly-de-ke-shi-hua-bian-cheng/","link":"","permalink":"http://cxx0822.github.io/2021/10/22/ji-yu-blockly-de-ke-shi-hua-bian-cheng/","excerpt":"","text":"平台&emsp;&emsp;Windows 10&emsp;&emsp;Web前端框架：Vue.js+Element UI&emsp;&emsp;可视化编程：Blockly&emsp;&emsp;JavaScript解释器：eval5 简介&emsp;&emsp;Blockly是谷歌开源的基于Web的可视化编程工具。具有以下特性： 完全是JavaScript，可离线使用 可生成6门语言：JavaScript、Python、PHP、Dart、Lua和XML 支持主流的浏览器，如：Chrome, Firefox, Safari, Opera, IE 支持移动设备 支持许多编程的基本元素，如：变量、函数、数组 易于扩展自定义的块 支持多国语言（40+） &emsp;&emsp;但是Blockly好像只是一个编辑器，可以通过拖拽的方式实现可视化编程，并生成相应的可执行代码，但是好像并不能运行代码，所以我们还需要一个代码解释器。&emsp;&emsp;由于是运行在Web端，因此需要一个JavaScript解释器。&emsp;&emsp;eval5是基于TypeScript编写的JavaScript解释器，支持完整ES5语法。 Blockly配置安装Blockly1npm install blockly 引入Blockly&emsp;&emsp;在vue文件中的&lt;script&gt;部分引入Blockly和其相关组件：12345678// 引入Blocklyimport Blockly from 'blockly'// 引入想要转换的语言，语言有php python dart lua javascriptimport 'blockly/javascript'import 'blockly/python'// 引入语言包并使用import * as hans from 'blockly/msg/zh-hans'Blockly.setLocale(hans) &emsp;&emsp;在main.js文件中，注册Blockly相关组件：12345678Vue.config.ignoredElements.push('xml')Vue.config.ignoredElements.push('block')Vue.config.ignoredElements.push('field')Vue.config.ignoredElements.push('category')Vue.config.ignoredElements.push('sep')Vue.config.ignoredElements.push('value')Vue.config.ignoredElements.push('statement')Vue.config.ignoredElements.push('mutation') 自定义Blockly块&emsp;&emsp;Blockly块主要由三个部分组成： 块定义对象：定义块的外观和行为，包括文本，颜色，字段和连接。 工具箱参考：工具箱XML中对块类型的引用，因此用户可以将其添加到工作区。 生成器函数：生成此块的代码字符串。 块定义对象&emsp;&emsp;这里可以使用官方提供的开发工具：&emsp;&emsp;下载Blockly源码，打开demos-&gt;index.html，找到Blockly Developer Tools工具。&emsp;&emsp;一个自定义块主要包括以下几个部分： 块名字 输入&emsp;&emsp;value input 值输入&emsp;&emsp;statement input 块输入&emsp;&emsp;dummy input 无输入 输入类型&emsp;&emsp;external 外接&emsp;&emsp;inline 内接 连接方式&emsp;&emsp;left output左连接（输出）&emsp;&emsp;top + bottm connections 上下连接&emsp;&emsp;top connection上连接&emsp;&emsp;bottom connection 下连接 工具提示 帮助提示 颜色 0-360&emsp;&emsp;如图，定义了一个open_grasp块，具有一个inline输入，输入变量名称为张开夹爪，变量类型为Boolean，并设置为上下可连接。&emsp;&emsp;依次点击Sava &quot;block_type&quot;和Block Exporter即可查看样式。&emsp;&emsp;在右侧的Block Definition中选择javaScript，即可查看生成的js代码。 生成器函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 引入Blocklyimport Blockly from 'blockly'export const initBlockly = (div, toolbox) =&gt; &#123; return Blockly.inject(div, &#123; // 工具栏 toolbox: document.getElementById(toolbox), // 网格效果 grid: &#123; spacing: 20, length: 3, colour: '#ccc', snap: true &#125;, // 媒体资源 (该框架下需要将资源文件放在public文件夹下) media: 'media/', // 垃圾桶 trashcan: true, zoom: &#123; controls: true, wheel: true, startScale: 1.0, maxScale: 3, minScale: 0.3, scaleSpeed: 1.2 &#125; &#125; )&#125;export const initMyBlockly = () =&gt; &#123; Blockly.Blocks['open_grasp'] = &#123; init: function() &#123; this.appendValueInput('VALUE') .setCheck('Boolean') .appendField('张开夹爪') this.setInputsInline(false) this.setPreviousStatement(true, null) this.setNextStatement(true, null) this.setColour(230) this.setTooltip('') this.setHelpUrl('') &#125; &#125; Blockly.JavaScript['open_grasp'] = (block) =&gt; &#123; // 后面的 || '\\'\\'' 部分表示当输入为空时 返回的值 var argument0 = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_FUNCTION_CALL) || 'false' // 汇总代码 var code = 'openGrasp' + '(' + argument0 + ');' + '\\n' // 第二个参数为当前使用的操作符对应的优先级 https://www.wenjiangs.com/doc/wkeldh8c // return [code, Blockly.JavaScript.ORDER_FUNCTION_CALL] return code &#125;&#125; &emsp;&emsp;新建一个js文件，将块定义对象生成的代码直接复制过来。生成器函数部分，首先需要获取到块定义对象中的变量值，然后组织代码形式并作为返回值返回。 eval5环境搭建安装eval51npm install --save eval5 引入eval5&emsp;&emsp;在vue文件中的&lt;script&gt;部分引入eval5：1import &#123; Interpreter &#125; from 'eval5' 简单使用123456789101112import &#123; Interpreter &#125; from 'eval5'runJavascriptCode() &#123; const interpreter = new Interpreter(window) var jsCode = \"console.log('Hello')\" try &#123; interpreter.evaluate(jsCode) &#125; catch (e) &#123; console.info('执行代码错误', e) &#125;&#125; &emsp;&emsp;首先实例化Interpreter类，然后调用evaluate()函数即可运行脚本类型的字符串。&emsp;&emsp;注：这里只能运行JavaScript内部的全局函数，如果是自定义的函数，需要声明为全局函数(适用于Vue)：1window.myFunName = this.myFunName 简单使用页面布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div id=\"visualProgram\" class=\"visualProgram\"&gt; &lt;el-row type=\"flex\" :gutter=\"10\"&gt; &lt;el-col :span=\"12\"&gt; &lt;!-- blockly工作区 --&gt; &lt;div id=\"blocklyDiv\" class=\"div-blocklyDiv\"&gt; &lt;!-- blockly工具栏 --&gt; &lt;xml id=\"toolbox\" style=\"display: none\"&gt; &lt;category name=\"移动\" colour=\"%&#123;BKY_LOGIC_HUE&#125;\"&gt; &lt;block type=\"open_grasp\" /&gt; &lt;block type=\"logic_boolean\" /&gt; &lt;block type=\"text\" /&gt; &lt;/category&gt; &lt;/xml&gt; &lt;div class=\"div-run-code\"&gt; &lt;el-button type=\"primary\" @click=\"runJavascriptCode\"&gt;运行javascript code&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=\"6\"&gt; &lt;div class=\"div-blockly-code\"&gt; &lt;!-- blockly代码区 --&gt; &lt;el-input v-model=\"blocklyCodeMessage\" :disabled=\"true\" type=\"textarea\" :rows=\"39\" class=\"el-input-blockly-code\" /&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=\"6\"&gt; &lt;div class=\"div-blockly-console\"&gt; &lt;!-- blockly代码控制台 --&gt; &lt;el-input v-model=\"blocklyConsoleMessage\" :disabled=\"true\" type=\"textarea\" :rows=\"39\" class=\"el-input-blockly-console\" /&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/template&gt; &emsp;&emsp;样式美化：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;#visualProgram .el-input-blockly-code /deep/ .el-textarea__inner&#123; color: black; background-color: white&#125;#visualProgram .el-input-blockly-console /deep/ .el-textarea__inner&#123; color: black; background-color: white&#125;&lt;/style&gt;&lt;style&gt;.div-blocklyDiv&#123; width:800px; height:850px; margin-top: 20px; margin-left: 20px; position: relative; border: 2px solid #008B93;&#125;.div-run-code&#123; position: absolute; right: 300px; bottom: 800px; z-index: 2;&#125;.div-blockly-code&#123; margin-top: 20px; height:850px; color: #008B93; border: 2px solid #008B93;&#125;.div-blockly-console&#123; margin-top: 20px; margin-right: 10px; height:850px; border: 2px solid #008B93;&#125;.el-input-blockly-code&#123; width: 99%; margin: 2px; border: 1px solid #008B93;&#125;.el-input-blockly-console&#123; width: 99%; margin: 2px; border: 1px solid #008B93;&#125;&lt;/style&gt; &emsp;&emsp;页面主要分为三部分，即可视化编程区，代码显示区和代码控制台区。 逻辑功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;script&gt;// https://github.com/bplok20010/eval5import &#123; Interpreter &#125; from 'eval5'import * as myblock from '@/utils/blocktools/myblocks'// 引入Blocklyimport Blockly from 'blockly'// 引入想要转换的语言，语言有php python dart lua javascriptimport 'blockly/javascript'import 'blockly/python'// 引入语言包并使用import * as hans from 'blockly/msg/zh-hans'Blockly.setLocale(hans)export default &#123; name: 'HelloWorld', data() &#123; return &#123; workspace: null, blocklyCodeMessage: '', blocklyConsoleMessage: '' &#125; &#125;, mounted() &#123; this.initBlockly() myblock.initMyBlockly() window.openGrasp = this.openGrasp &#125;, created() &#123; &#125;, beforeDestroy() &#123; &#125;, methods: &#123; initBlockly() &#123; this.workspace = myblock.initBlockly('blocklyDiv', 'toolbox') // 工作区监听代码生成器 this.workspace.addChangeListener(this.myUpdateFunction) var toolbox = Blockly.getMainWorkspace().getToolbox() &#125;, // 代码生成器 myUpdateFunction(event) &#123; var codeJs = Blockly.JavaScript.workspaceToCode(this.workspace) this.blocklyCodeMessage = codeJs &#125;, runJavascriptCode() &#123; // const interpreter = new Interpreter(window, &#123; // timeout: 1000 // &#125;) const interpreter = new Interpreter(window) var jsCode = Blockly.JavaScript.workspaceToCode(this.workspace) // console.log(jsCode) try &#123; interpreter.evaluate(jsCode) &#125; catch (e) &#123; this.blocklyConsoleMessage += e + '\\n' // console.info('执行代码错误', e) &#125; &#125;, openGrasp(value) &#123; // this.$message('openGrasp: ' + value) window.alert(value) &#125; &#125;&#125;&lt;/script&gt; &emsp;&emsp;首先初始化Blockly，然后设置监听代码生成函数，当需要执行代码时，调用eval5的evaluate()进行解释运行。","categories":[{"name":"Web前端开发与应用","slug":"Web前端开发与应用","permalink":"http://cxx0822.github.io/categories/Web前端开发与应用/"}],"tags":[]},{"title":"基于Xterm的Webterminal实现","slug":"基于Xterm的Webterminal实现","date":"2021-10-20T15:29:19.000Z","updated":"2022-03-21T06:19:12.802Z","comments":true,"path":"2021/10/20/ji-yu-xterm-de-webterminal-shi-xian/","link":"","permalink":"http://cxx0822.github.io/2021/10/20/ji-yu-xterm-de-webterminal-shi-xian/","excerpt":"","text":"平台&emsp;&emsp;Web前端：Vue.js&emsp;&emsp;Web后端：tornado&emsp;&emsp;WebSocket插件：Xtermjs 环境配置前端配置——安装xterm1npm install --save xterm &emsp;&emsp;xterm.js的插件，使终端的尺寸适合包含元素。1npm install --save xterm-addon-fit &emsp;&emsp;xterm.js的附加组件，用于附加到Web Socket。1npm install --save xterm-addon-attach &emsp;&emsp;附：建议版本：123\"xterm\": \"^3.1.0\",\"xterm-addon-attach\": \"^0.6.0\",\"xterm-addon-fit\": \"^0.5.0\" &emsp;&emsp;在main.js加入import &#39;xterm/dist/xterm.css&#39;，否则显示有问题。 后端配置——安装tornado12pip install tornado==4.5.3pip install paramiko==2.4.0 代码实现后端服务器实现&emsp;&emsp;后端启动代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# -*- coding: utf-8 -*-import tornadoimport tornado.websocketimport paramikoimport threadingimport time# 配置服务器信息HOSTS = \"192.168.64.131\"PORT = 22USERNAME = \"cxx\"PASSWORD = \" \"class MyThread(threading.Thread): def __init__(self, id, chan): threading.Thread.__init__(self) self.chan = chan def run(self): while not self.chan.chan.exit_status_ready(): time.sleep(0.1) try: data = self.chan.chan.recv(1024) self.chan.write_message(data) except Exception as ex: # 注释掉print，否则会报错，原因：库版本不对 # print(str(ex)) pass self.chan.sshclient.close() return Falseclass webSSHServer(tornado.websocket.WebSocketHandler): def open(self): self.sshclient = paramiko.SSHClient() self.sshclient.load_system_host_keys() self.sshclient.set_missing_host_key_policy(paramiko.AutoAddPolicy()) self.sshclient.connect(HOSTS, PORT, USERNAME, PASSWORD) self.chan = self.sshclient.invoke_shell(term='xterm') self.chan.settimeout(0) t1 = MyThread(999, self) t1.setDaemon(True) t1.start() def on_message(self, message): try: self.chan.send(message) except Exception as ex: print(str(ex)) def on_close(self): self.sshclient.close() def check_origin(self, origin): # 允许跨域访问 return Trueif __name__ == '__main__': # 定义路由 app = tornado.web.Application([ (r\"/terminals/\", webSSHServer), ], debug=True ) # 启动服务器 http_server = tornado.httpserver.HTTPServer(app) # 监听的端口号 http_server.listen(3000) tornado.ioloop.IOLoop.current().start() 前端实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import &#123; Terminal &#125; from 'xterm'import * as fit from 'xterm/lib/addons/fit/fit'import * as attach from 'xterm/lib/addons/attach/attach'Terminal.applyAddon(fit)Terminal.applyAddon(attach)import &#123; Message &#125; from 'element-ui'var webSocket = nullvar term = null// 初始化webSocket，Ip地址和后端对应export const initWebSocket = (IpAddress) =&gt; &#123; webSocket = new WebSocket('ws://' + IpAddress + '/terminals/') // 打开事件 webSocket.onopen = runRealTerminal // 关闭事件 webSocket.onclose = closeRealTerminal // 错误事件 webSocket.onerror = errorRealTerminal&#125;// 初始化terminalexport const initTerminal = (divID, rows, cols) =&gt; &#123; var terminalContainer = document.getElementById(divID) // Terminal构造函数 term = new Terminal(&#123; fontSize: 18, fontFamily: 'monospace', rendererType: 'canvas', // 渲染类型 rows: rows, cols: cols, convertEol: true, // 启用时，光标将设置为下一行的开头 // scrollback: 50, // 终端中的回滚量 // disableStdin: false, // 是否应禁用输入 cursorBlink: true, // 光标闪烁 theme: &#123; foreground: '#ECECEC', // 字体颜色 background: '#000000', // 背景色 lineHeight: 20 &#125; &#125;) term.open(terminalContainer) term.attach(webSocket)&#125;// webSocket发送数据，需要加换行才能生效export const sendData = (data) =&gt; &#123; webSocket.send(data + '\\n')&#125;// 关闭webSocketexport const closeWebSocket = () =&gt; &#123; webSocket.close()&#125;// 销毁terminalexport const destroyTerm = () =&gt; &#123; term.destroy()&#125;// Terminal清屏export const clearTerm = () =&gt; &#123; term.clear()&#125;// 响应连接成功事件function runRealTerminal() &#123; // console.log('webSocket is finished') Message(&#123; message: '连接Terminal成功！', type: 'success' &#125;)&#125;// 响应错误连接事件function errorRealTerminal() &#123; // console.log('error') Message.error('连接Terminal失败！')&#125;// 响应关闭连接事件function closeRealTerminal() &#123; // console.log('close') Message.error('关闭Terminal连接！')&#125; Vue模块12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div class=\"app-container\"&gt; &lt;div id=\"exampleTerminal\" class=\"div-example-terminal\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as myXterm from '@/utils/terminal/myXterm'export default &#123; data() &#123; return &#123; term: null, webSocket: null, terminalContainer: null, &#125; &#125;, mounted() &#123; // 页面加载时，初始化webSocket和Terminal myXterm.initWebSocket('127.0.0.1:3000') myXterm.initTerminal('exampleTerminal', 35, 76) &#125;, beforeDestroy() &#123; // 页面销毁时，关闭webSocket和Terminal myXterm.closeWebSocket() myXterm.destroyTerm() &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;&lt;style&gt;.div-example-terminal&#123; margin-top: 15px; margin-left: 10px; border: 2px solid #008B93;&#125;&lt;/style&gt; 附：vue-prism-editor安装12npm install vue-prism-editor npm install prismjs 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;template&gt; &lt;div class=\"app-container\"&gt; &lt;el-tab-pane label=\"ex01_initialization\"&gt; &lt;prism-editor v-model=\"ex01_code\" class=\"ex01-code-editor\" :highlight=\"highlighter\" :line-numbers=\"lineNumbers\" :readonly=\"true\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 导入vue-prism-editorimport &#123; PrismEditor &#125; from 'vue-prism-editor'import 'vue-prism-editor/dist/prismeditor.min.css' // import the styles somewhere// import highlighting library (you can use any library you want just return html string)import &#123; highlight, languages &#125; from 'prismjs/components/prism-core'import 'prismjs/components/prism-clike'import 'prismjs/components/prism-javascript'import 'prismjs/themes/prism-tomorrow.css' // import syntax highlighting stylesexport default &#123; // 注册组件 components: &#123; PrismEditor &#125;, data() &#123; return &#123; // 多行代码通过`/n`实现 ex01_code: 'cd ~/libbarrett_examples\\ncmake .\\nmake ex01_initialize_wam\\n./ex01_initialize_wam', lineNumbers: true &#125; &#125;, methods: &#123; // 代码颜色高亮 highlighter(code) &#123; return highlight(code, languages.js) // returns html &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;&lt;style&gt;/* required class */.ex01-code-editor &#123; background: #2d2d2d; color: #ccc; font-family: Fira code, Fira Mono, Consolas, Menlo, Courier, monospace; font-size: 16px; line-height: 1.5; padding: 5px; height: 120px; width: 320px; border: 2px solid #008B93;&#125;/* optional */.prism-editor__textarea:focus &#123; outline: none;&#125;&lt;/style&gt;","categories":[{"name":"Web前端开发与应用","slug":"Web前端开发与应用","permalink":"http://cxx0822.github.io/categories/Web前端开发与应用/"}],"tags":[]},{"title":"基于EChart的Unity数据可视化","slug":"基于EChart的Unity数据可视化","date":"2021-10-20T15:28:25.000Z","updated":"2022-03-21T06:19:12.766Z","comments":true,"path":"2021/10/20/ji-yu-echart-de-unity-shu-ju-ke-shi-hua/","link":"","permalink":"http://cxx0822.github.io/2021/10/20/ji-yu-echart-de-unity-shu-ju-ke-shi-hua/","excerpt":"","text":"平台&emsp;&emsp;Windows 10&emsp;&emsp;Unity 2020.3&emsp;&emsp;Unity Web插件：Embedded Browser2.1&emsp;&emsp;Web前端框架：Vue.js+Element UI&emsp;&emsp;数据可视化工具：ECharts Unity配置&emsp;&emsp;首先在ECharts官网下载dist文件夹(编译好的目标文件)，并将其放置在Unity工程文件夹下的BrowserAssets文件夹中(没有则新建，名字必须一样)，并新建一个html文件用于编写web界面。 &emsp;&emsp;然后将Embedded Browser插件导入到工程中，并在Prefabs中找到BrowserGUI控件，将其放置在Canvas中。&emsp;&emsp;然后更改其Rect Transform属性，放置到合适的位置，将Browser(Script)属性下的Url参数更改为刚才新建的html文件：&emsp;&emsp;最后挂载一个脚本用于处理程序逻辑。 Web前端配置&emsp;&emsp;mychart_vue.html：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt; &lt;!-- import CSS --&gt; &lt;link rel=\"stylesheet\" href=\"element-css-index.css\"&gt; &lt;/head&gt;&lt;!-- import Vue before Element --&gt;&lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;!-- import JavaScript --&gt;&lt;script src=\"element-js-index.js\"&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=\"app\" style=\"width:530px;height:320;\" class=\"div-app\"&gt; &lt;el-row :gutter=\"15\"&gt; &lt;el-col :span=\"18\"&gt; &lt;div id=\"main\" class=\"div-main-chart\" style=\"width:400px;height:300px;\"&gt;&lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=\"6\"&gt; &lt;div&gt; &lt;el-button type=\"primary\" @click=\"updateChartAuto\"&gt;&#123;&#123; updateChartBtnName &#125;&#125;&lt;/el-button&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt;new Vue(&#123; el: '#app', data() &#123; return &#123; chartDom: null, myChart: null, option: null, categories: [], data: [], isUpdateChart: false, updateChartInterval: null, updateChartBtnName: \"动态更新\" &#125; &#125;, created () &#123; this.initOption() &#125;, mounted () &#123; this.chartDom = document.getElementById('main') this.myChart = echarts.init(this.chartDom) // 使用刚指定的配置项和数据显示图表。 this.myChart.setOption(this.option); // 在vue的钩子函数中将需要调用的函数赋值给window。 window.updateChart = this.updateChart; window.updateChartAuto = this.updateChartAuto &#125;, methods: &#123; initOption() &#123; this.option = &#123; title: &#123; text: 'Estun Medical', x: 'center', y: 'top', &#125;, // 悬浮框，鼠标放置在数据上面时的响应 tooltip: &#123; trigger: 'axis', axisPointer: &#123; type: 'cross', label: &#123; backgroundColor: '#283b56' &#125; &#125; &#125;, legend: &#123; x: 'right' &#125;, // 右上角小工具 toolbox: &#123; show: false, feature: &#123; dataView: &#123; readOnly: false &#125;, restore: &#123;&#125;, saveAsImage: &#123;&#125; &#125; &#125;, dataZoom: &#123; show: true, start: 0, end: 100 &#125;, // 和下面的系列对应，有几个图就有几个坐标系轴 xAxis: &#123; // 坐标轴类型。'value' 数值轴，适用于连续数据。'category' 类目轴，适用于离散的类目数据 type: 'category', boundaryGap: true, // data: this.categories &#125;, yAxis: &#123; type: 'value', scale: true, name: 'Number', max: 30, min: 0, boundaryGap: [0.2, 0.2] &#125;, // 系列，即包含几种图 series: &#123; name: 'Number Line', type: 'line', // data: this.data &#125; &#125;; &#125;, updateChartAuto() &#123; if (this.isUpdateChart) &#123; this.isUpdateChart = false this.updateChartBtnName = '动态更新' clearInterval(this.updateChartInterval) &#125;else&#123; this.updateChartBtnName = '暂停更新' this.updateChartInterval = setInterval(() =&gt; &#123; this.isUpdateChart = true let axisData = new Date().toLocaleTimeString().replace(/^\\D*/, ''); // shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 if (this.data.length &gt; 10)&#123; this.data.shift(); &#125; this.data.push(Math.round(Math.random() * 30)); if (this.categories.length &gt; 10) &#123; this.categories.shift(); &#125; this.categories.push(axisData); this.myChart.setOption(&#123; xAxis: &#123; data: this.categories &#125;, series: &#123; data: this.data &#125; &#125;); &#125;, 1000) &#125; &#125;, updateChart(xData, yData) &#123; let axisData = xData // shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 if (this.data.length &gt; 10)&#123; this.data.shift(); &#125; this.data.push(yData); if (this.categories.length &gt; 10) &#123; this.categories.shift(); &#125; this.categories.push(axisData); this.myChart.setOption(&#123; xAxis: &#123; data: this.categories &#125;, series: &#123; data: this.data &#125; &#125;); &#125; &#125;&#125;)function updateChart(xData, yData) &#123; updateChart(xData, yData)&#125;function updateChartAuto() &#123; updateChartAuto()&#125;&lt;/script&gt;&lt;style type=\"text/css\"&gt;.div-app&#123; /* border: 2px solid #FF0000; */&#125;.div-main-chart&#123; border: 2px solid #008B93;&#125;&lt;/style&gt;&lt;/html&gt; &emsp;&emsp;这里主要实现了能够自动增加数据的动态折线图显示。比较重要的一点是，在Vue框架中，需要使用钩子函数将其内部函数传给Windows(window.updateChart = this.updateChart;)，否则在Unity中无法找到该函数。 Unity编译运行&emsp;&emsp;Unity脚本控制：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253using System.Collections;using System.Collections.Generic;using System.Data;using UnityEngine;using UnityEngine.UI;using ZenFulcrum.EmbeddedBrowser;public class ChartDemo : MonoBehaviour&#123; public Browser browser; // Start is called before the first frame update void Start() &#123; // 添加按钮对象 List&lt;string&gt; btnsName = new List&lt;string&gt;(); btnsName.Add(\"BtnUpdateChart\"); foreach (string btnName in btnsName) &#123; GameObject btnObj = GameObject.Find(btnName); Button btn = btnObj.GetComponent&lt;Button&gt;(); btn.onClick.AddListener(delegate () &#123; this.OnClick(btnObj); &#125;); &#125; &#125; // 响应按钮点击事件 public void OnClick(GameObject sender) &#123; switch (sender.name) &#123; case \"BtnUpdateChart\": // Debug.Log(\"BtnUpdateChart\"); // browser.CallFunction(\"updateChart\", 1, 10).Done(); browser.CallFunction(\"updateChartAuto\").Done(); // UpdateChart(barChart); break; default: Debug.Log(\"none\"); break; &#125; &#125; // Update is called once per frame void Update() &#123; &#125;&#125; &emsp;&emsp;Unity调用web的方法函数为：browser.CallFunction(&quot;functionName&quot;, functionparams).Done();，然后将刚才的BrowserGUI控件挂载到该脚本上即可。&emsp;&emsp;最后编译打包即可。","categories":[{"name":"Unity开发与应用","slug":"Unity开发与应用","permalink":"http://cxx0822.github.io/categories/Unity开发与应用/"}],"tags":[]},{"title":"Unity与Android的蓝牙通信","slug":"Unity与Android的蓝牙通信","date":"2021-10-20T15:27:26.000Z","updated":"2022-03-21T06:19:12.584Z","comments":true,"path":"2021/10/20/unity-yu-android-de-lan-ya-tong-xin/","link":"","permalink":"http://cxx0822.github.io/2021/10/20/unity-yu-android-de-lan-ya-tong-xin/","excerpt":"","text":"平台&emsp;&emsp;Windows 10&emsp;&emsp;Unity 2020.3&emsp;&emsp;Android Studio 2020.3 安装模块Unity Android模块&emsp;&emsp;打开Unity Hub，安装Android Build Support模块： Android环境配置&emsp;&emsp;首先需要在Anroid Studio上编写好与Unity通信的java包，然后将生成的文件放到Unity中，最后Build生成apk文件，运行在相应的安卓设备上。 新建Android Studio工程&emsp;&emsp;打开Android Studio，新建工程：&emsp;&emsp;这里名字可以任意选择，注意记住这里的SDK版本号。 新建Android Library库&emsp;&emsp;这里我们需要导出的是jar文件，所以需要新建一个Android库。选择File-&gt;New-&gt;New Module，选择Android Library新建： 添加Unity的Android jar包&emsp;&emsp;切换至Project文件目录，选择刚才新建的Android Libray文件夹下面的libs文件夹，将Unity的Android jar包文件(C:\\Program Files\\Unity\\Hub\\Editor\\2020.3.17f1c1\\Editor\\Data\\PlaybackEngines\\AndroidPlayer\\Variations\\il2cpp\\Release\\Classes\\classes.jar)复制到此文件夹：&emsp;&emsp;并右击选择Add as Library将其设置为库文件： 新建MainActivity文件&emsp;&emsp;在myapplication-&gt;src-&gt;main-&gt;java-&gt;com.example.myapplocation文件夹右击选择New-&gt;Activity-&gt;Empty Activity新建空白Activity：&emsp;&emsp;注意这里不要选择Generate a Layout File生成布局文件。 添加Unity3D UnityPlayerActivity.java文件&emsp;&emsp;由于新版Unity(2018版后)，UnityPlayerActivity类没有放到刚才的classes.jar中，因此需要将此文件单独放置到Android的包文件夹中。&emsp;&emsp;新建包com.unity3d.player，将UnityPlayerActivity.java文件(C:\\Program Files\\Unity\\Hub\\Editor\\2020.3.17f1c1\\Editor\\Data\\PlaybackEngines\\AndroidPlayer\\Source\\com\\unity3d\\player\\UnityPlayerActivity.java)复制到此包文件夹中： 更改AndroidManifest.xml&emsp;&emsp;将android工程的app模块(参见上文的文件目录)中的app-&gt;src-&gt;main-&gt;res-&gt;values-&gt;strings.xml和app-&gt;src-&gt;main-&gt;AndroidManifest.xml文件一并复制替换到myapplication库模块的相应位置。&emsp;&emsp;并更改AndroidManifest.xml中的内容为：&emsp;&emsp;附：1&lt;meta-data android:name=\"unityplayer.UnityActivity\" android:value=\"true\" /&gt; 生成jar包文件&emsp;&emsp;点击编译文件工具，即可在build文件夹下看到生成的jar包文件： Android端蓝牙通讯模块BluetoothService&emsp;&emsp;在刚才新建的Android模块中新建MainActivity.java和BluetoothService.java文件：&emsp;&emsp;MainActivity.java：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412import java.util.ArrayList;import java.util.HashMap;import java.util.Map;import java.util.Set;import android.annotation.SuppressLint;import android.bluetooth.BluetoothDevice;import android.bluetooth.BluetoothAdapter;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.widget.Toast;import androidx.annotation.RequiresPermission;import com.unity3d.player.UnityPlayer;import com.unity3d.player.UnityPlayerActivity;public class MainActivity extends UnityPlayerActivity &#123; public static final int MESSAGE_STATE_CHANGE = 1; public static final int MESSAGE_READ = 2; public static final int MESSAGE_WRITE = 3; public static final int MESSAGE_DEVICE_NAME = 4; public static final int MESSAGE_TOAST = 5; private static final int REQUEST_CONNECT_DEVICE = 1; private static final int REQUEST_ENABLE_BT = 2; private static final String TAG = \"BluetoothPlugin\"; private static final String TARGET = \"BluetoothModel\"; private boolean IsScan = false; private String mConnectedDeviceName = null; private StringBuffer mOutStringBuffer; private BluetoothAdapter mBtAdapter = null; private BluetoothService mBtService = null; private ArrayList&lt;String&gt; singleAddress = new ArrayList(); private String pairedDevicesName = \"\"; private Map&lt;String, String&gt; pairedDevicesMap = new HashMap&lt;String,String&gt;(); private String readMessage = \"\"; private String connectStatus = \"false\"; // 处理消息模块Handle private final Handler mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; switch(msg.what) &#123; case MESSAGE_STATE_CHANGE: UnityPlayer.UnitySendMessage(TARGET, \"OnStateChanged\", String.valueOf(msg.arg1)); break; case MESSAGE_READ: // Log.d(TAG, msg.obj.toString()); //byte[] readBuf = (byte[])msg.obj; //String readMessage = new String(readBuf, 0, msg.arg1); // UnityPlayer.UnitySendMessage(TARGET, \"OnReadMessage\", readMessage); //Toast.makeText(MainActivity.this.getApplicationContext(), readMessage, Toast.LENGTH_SHORT).show(); setReadMessage(msg.obj.toString()); break; case MESSAGE_WRITE: byte[] writeBuf = (byte[])msg.obj; String writeMessage = new String(writeBuf); // UnityPlayer.UnitySendMessage(TARGET, \"OnSendMessage\", writeMessage); break; case MESSAGE_DEVICE_NAME: MainActivity.this.mConnectedDeviceName = msg.getData().getString(\"device_name\"); setConnectStatus(\"true\"); Toast.makeText(MainActivity.this.getApplicationContext(), \"Connected to \" + MainActivity.this.mConnectedDeviceName, Toast.LENGTH_SHORT).show(); break; case MESSAGE_TOAST: Toast.makeText(MainActivity.this.getApplicationContext(), msg.getData().getString(\"toast\"), Toast.LENGTH_SHORT).show(); break; &#125; &#125; &#125;; private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @RequiresPermission(\"android.permission.BLUETOOTH\") public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if(\"android.bluetooth.device.action.FOUND\".equals(action)) &#123; BluetoothDevice device = intent.getParcelableExtra(\"android.bluetooth.device.extra.DEVICE\"); MainActivity.this.singleAddress.add(device.getName() + \"\\n\" + device.getAddress()); UnityPlayer.UnitySendMessage(TARGET, \"OnFoundDevice\", device.getName() + \",\\n\" + device.getAddress()); &#125; else if(\"android.bluetooth.adapter.action.DISCOVERY_FINISHED\".equals(action)) &#123; if(MainActivity.this.IsScan) &#123; UnityPlayer.UnitySendMessage(TARGET, \"OnScanFinish\", \"\"); &#125; if(MainActivity.this.singleAddress.size() == 0) &#123; UnityPlayer.UnitySendMessage(TARGET, \"OnFoundNoDevice\", \"\"); &#125; &#125; &#125; &#125;; // 1. Starting Point in Unity Script // 开启蓝牙设备 @RequiresPermission(\"android.permission.BLUETOOTH\") public void StartPlugin() &#123; if(Looper.myLooper() == null) &#123; Looper.prepare(); &#125; this.SetupPlugin(); &#125; // 2. Setup Plugin // Get Default Bluetooth Adapter and start Service @RequiresPermission(\"android.permission.BLUETOOTH\") public void SetupPlugin() &#123; // Bluetooth Adapter this.mBtAdapter = BluetoothAdapter.getDefaultAdapter(); // if Bluettoth Adapter is avaibale, start Service if(this.mBtAdapter == null) &#123; Toast.makeText(MainActivity.this, \"Bluetooth is not available\", Toast.LENGTH_SHORT).show(); &#125; else &#123; if (!this.mBtAdapter.isEnabled()) &#123; this.mBtAdapter.enable(); if (this.mBtService == null) &#123; this.startService(); &#125; Toast.makeText(MainActivity.this, \"Open bluetooth success\", Toast.LENGTH_SHORT).show(); &#125;else &#123; if (this.mBtService == null) &#123; this.startService(); &#125; Toast.makeText(MainActivity.this, \"Open bluetooth success\", Toast.LENGTH_SHORT).show(); &#125; // Log.d(TAG, \"SetupPlugin SUCCESS\"); &#125; &#125; // 3. Setup and Start Bluetooth Service private void startService() &#123; // Log.d(TAG, \"setupService()\"); this.mBtService = new BluetoothService(this, this.mHandler); this.mOutStringBuffer = new StringBuffer(\"\"); &#125; public String DeviceName() &#123; return this.mBtAdapter.getName(); &#125; @RequiresPermission(\"android.permission.BLUETOOTH\") public String GetDeviceConnectedName() &#123; return !this.mBtAdapter.isEnabled()?\"You Must Enable The BlueTooth\":(this.mBtService.getState() != 3?\"Not Connected\":this.mConnectedDeviceName); &#125; @RequiresPermission(\"android.permission.BLUETOOTH\") public boolean IsEnabled() &#123; return this.mBtAdapter.isEnabled(); &#125; public boolean IsConnected() &#123; return this.mBtService.getState() == 3; &#125; @RequiresPermission(\"android.permission.BLUETOOTH\") public void stopThread() &#123; if(this.mBtService != null) &#123; this.mBtService.stop(); this.mBtService = null; &#125; if(this.mBtAdapter != null) &#123; this.mBtAdapter = null; &#125; this.SetupPlugin(); &#125; // 扫描蓝牙设备 @RequiresPermission(allOf = &#123;\"android.permission.BLUETOOTH\", \"android.permission.BLUETOOTH_ADMIN\"&#125;) public String ScanDevice() &#123; // Toast.makeText(MainActivity.this, \"Start - ScanDevice()\", Toast.LENGTH_SHORT).show(); // Log.d(TAG, \"Start - ScanDevice()\"); if(this.mBtAdapter == null || !this.mBtAdapter.isEnabled()) &#123; Toast.makeText(MainActivity.this, \"You Must Enable The BlueTooth\", Toast.LENGTH_SHORT).show(); // Log.d(TAG, \"You Must Enable The BlueTooth\"); // return \"You Must Enable The BlueTooth\"; &#125; else &#123; this.IsScan = true; this.singleAddress.clear(); IntentFilter filter = new IntentFilter(\"android.bluetooth.device.action.FOUND\"); this.registerReceiver(this.mReceiver, filter); filter = new IntentFilter(\"android.bluetooth.adapter.action.DISCOVERY_FINISHED\"); this.registerReceiver(this.mReceiver, filter); // 获取扫描到的蓝牙设备名称和ID this.mBtAdapter = BluetoothAdapter.getDefaultAdapter(); Set&lt;BluetoothDevice&gt; pairedDevices = this.mBtAdapter.getBondedDevices(); if(pairedDevices.size() &gt; 0) &#123; pairedDevicesName = \"\"; for (BluetoothDevice device : pairedDevices) &#123; pairedDevicesName = pairedDevicesName + device.getName() + \",\"; pairedDevicesMap.put(device.getName(), device.getAddress()); &#125; &#125; this.doDiscovery(); Toast.makeText(MainActivity.this, \"ScanDevice SUCCESS\", Toast.LENGTH_SHORT).show(); // Log.d(TAG, \"ScanDevice SUCCESS\"); // return \"SUCCESS\"; &#125; // Toast.makeText(MainActivity.this, pairedDevicesName.toString(), Toast.LENGTH_SHORT).show(); // Log.d(TAG, pairedDevicesName); return pairedDevicesName; &#125; // 根据MAC地址连接蓝牙设备 @RequiresPermission(allOf = &#123;\"android.permission.BLUETOOTH\", \"android.permission.BLUETOOTH_ADMIN\"&#125;) public void Connect(String TheAddress) &#123; if(this.mBtAdapter == null || !this.mBtAdapter.isEnabled()) &#123; Toast.makeText(MainActivity.this, \"You Must Enable The BlueTooth\", Toast.LENGTH_SHORT).show(); &#125;else &#123; if(this.mBtAdapter.isDiscovering()) &#123; this.mBtAdapter.cancelDiscovery(); &#125; this.IsScan = false; String address = TheAddress.substring(TheAddress.length() - 17); this.mConnectedDeviceName = TheAddress.split(\",\")[0]; BluetoothDevice device = this.mBtAdapter.getRemoteDevice(address); this.mBtService.connect(device); // Toast.makeText(MainActivity.this, \"Connect SUCCESS\", Toast.LENGTH_SHORT).show(); &#125; &#125; // 关闭蓝牙连接 @RequiresPermission(\"android.permission.BLUETOOTH\") public void disConnect() &#123; if(this.mBtAdapter == null || !this.mBtAdapter.isEnabled()) &#123; Toast.makeText(MainActivity.this, \"You Must Enable The BlueTooth\", Toast.LENGTH_SHORT).show(); // Log.d(TAG, \"You Must Enable The BlueTooth\"); &#125; else if(this.mBtService.getState() != 3) &#123; Toast.makeText(MainActivity.this, \"Not Connected\", Toast.LENGTH_SHORT).show(); // Log.d(TAG, \"Not Connected\"); &#125; else &#123; this.mBtService.close(); Toast.makeText(MainActivity.this, \"DisConnect SUCCESS\", Toast.LENGTH_SHORT).show(); // Log.d(TAG, \"sendMessage SUCCESS\"); &#125; &#125; @RequiresPermission(allOf = &#123;\"android.permission.BLUETOOTH\", \"android.permission.BLUETOOTH_ADMIN\"&#125;) private void doDiscovery() &#123; if(this.mBtAdapter.isDiscovering()) &#123; this.mBtAdapter.cancelDiscovery(); &#125; this.mBtAdapter.startDiscovery(); &#125; @RequiresPermission(allOf = &#123;\"android.permission.BLUETOOTH\", \"android.permission.BLUETOOTH_ADMIN\"&#125;) String BluetoothSetName(String name) &#123; if(!this.mBtAdapter.isEnabled()) &#123; return \"You Must Enable The BlueTooth\"; &#125; else if(this.mBtService.getState() != 3) &#123; return \"Not Connected\"; &#125; else &#123; this.mBtAdapter.setName(name); return \"SUCCESS\"; &#125; &#125; // 关闭蓝牙设备 @RequiresPermission(allOf = &#123;\"android.permission.BLUETOOTH\", \"android.permission.BLUETOOTH_ADMIN\"&#125;) public void DisableBluetooth() &#123; if(this.mBtAdapter == null || !this.mBtAdapter.isEnabled()) &#123; Toast.makeText(MainActivity.this, \"You Must Enable The BlueTooth\", Toast.LENGTH_SHORT).show(); &#125; else &#123; if(this.mBtAdapter != null) &#123; this.mBtAdapter.cancelDiscovery(); &#125; if(this.mBtAdapter.isEnabled()) &#123; this.mBtAdapter.disable(); &#125; Toast.makeText(MainActivity.this, \"DisableBluetooth SUCCESS\", Toast.LENGTH_SHORT).show(); &#125; &#125; @RequiresPermission(\"android.permission.BLUETOOTH\") public String BluetoothEnable() &#123; try &#123; if(!this.mBtAdapter.isEnabled()) &#123; Intent e = new Intent(\"android.bluetooth.adapter.action.REQUEST_ENABLE\"); this.startActivityForResult(e, 2); &#125; return \"SUCCESS\"; &#125; catch (Exception e) &#123; return \"Faild\"; &#125; &#125; public void showMessage(final String message) &#123; this.runOnUiThread(new Runnable() &#123; public void run() &#123; Toast.makeText(MainActivity.this, message, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; @SuppressLint(\"WrongConstant\") @RequiresPermission(\"android.permission.BLUETOOTH\") public String ensureDiscoverable() &#123; if(!this.mBtAdapter.isEnabled()) &#123; return \"You Must Enable The BlueTooth\"; &#125; else &#123; if(this.mBtAdapter.getScanMode() != 23) &#123; Intent discoverableIntent = new Intent(\"android.bluetooth.adapter.action.REQUEST_DISCOVERABLE\"); discoverableIntent.putExtra(\"android.bluetooth.adapter.extra.DISCOVERABLE_DURATION\", 300); this.startActivity(discoverableIntent); &#125; return \"SUCCESS\"; &#125; &#125; // 发送蓝牙数据 @RequiresPermission(\"android.permission.BLUETOOTH\") public void sendMessage(String message) &#123; if(this.mBtAdapter == null || !this.mBtAdapter.isEnabled()) &#123; Toast.makeText(MainActivity.this, \"You Must Enable The BlueTooth\", Toast.LENGTH_SHORT).show(); // Log.d(TAG, \"You Must Enable The BlueTooth\"); &#125; else if(this.mBtService.getState() != 3) &#123; Toast.makeText(MainActivity.this, \"Not Connected\", Toast.LENGTH_SHORT).show(); // Log.d(TAG, \"Not Connected\"); &#125; else &#123; if(message.length() &gt; 0) &#123; byte[] send = message.getBytes(); this.mBtService.write(send); this.mOutStringBuffer.setLength(0); &#125; // Toast.makeText(MainActivity.this, \"sendMessage SUCCESS\", Toast.LENGTH_SHORT).show(); // Log.d(TAG, \"sendMessage SUCCESS\"); &#125; &#125; // 与Unity的接口 public void onOpen()&#123; StartPlugin(); &#125; public String onScan() &#123; return ScanDevice(); &#125; public String onGetDevicesAddress(String deviceName) &#123; return pairedDevicesMap.get((deviceName)); &#125; public void onConnect(String deviceName) &#123; String deviceAddress = onGetDevicesAddress(deviceName); Connect(deviceAddress); &#125; public String getConnectStatus() &#123; return connectStatus; &#125; public void setConnectStatus(String connectStatus) &#123; this.connectStatus = connectStatus; &#125; public void onSendMessage(String message) &#123; sendMessage(message); &#125; public String getReadMessage() &#123; return readMessage; &#125; public void setReadMessage(String readMessage) &#123; this.readMessage = readMessage; &#125; public String onReadMessage()&#123; return getReadMessage(); &#125; public void onDisconnect() &#123; disConnect(); &#125;&#125; &emsp;&emsp;蓝牙连接的大致步骤可以分为打开蓝牙-&gt;扫描蓝牙设备-&gt;连接蓝牙设备-&gt;发送信息-&gt;关闭蓝牙设备。 &emsp;&emsp;BluetoothService.java：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393package com.example.myapplication;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.nio.charset.StandardCharsets;import java.util.UUID;import android.bluetooth.BluetoothAdapter;import android.bluetooth.BluetoothDevice;import android.bluetooth.BluetoothSocket;import android.bluetooth.BluetoothServerSocket;import android.content.Context;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.util.Log;import androidx.annotation.RequiresPermission;public class BluetoothService &#123; // Debugging Tag private static final String TAG = \"BluetoothService\"; // RFCOMM Protocol // 蓝牙固定的uuid private static final UUID MY_UUID = UUID .fromString(\"00001101-0000-1000-8000-00805F9B34FB\"); private final BluetoothAdapter mBtAdapter; private final Handler mHandler; // Threads // 3个子线程 连接，连接后，接受 private BluetoothService.ConnectThread mConnectThread; private BluetoothService.ConnectedThread mConnectedThread; private BluetoothService.AcceptThread mAcceptThread; private int mState; // Connection State // 连接状态标志位 private static final int STATE_NONE = 0; // we're doing nothing private static final int STATE_LISTEN = 1; // now listening for incoming private static final int STATE_CONNECTING = 2; // now initiating an outgoing private static final int STATE_CONNECTED = 3; // now connected to a remote public static final String DEVICE_NAME = \"device_name\"; // Constructors public BluetoothService(Context ct, Handler h) &#123; this.mHandler = h; mBtAdapter = BluetoothAdapter.getDefaultAdapter(); &#125; public boolean getDeviceState() &#123; if (mBtAdapter == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; private synchronized void setState(int state) &#123; this.mState = state; this.mHandler.obtainMessage(MainActivity.MESSAGE_STATE_CHANGE, state, -1).sendToTarget(); mState = state; &#125; public synchronized int getState() &#123; return mState; &#125; @RequiresPermission(\"android.permission.BLUETOOTH\") public synchronized void start() &#123; // Cancel any thread attempting to make a connection if (mConnectThread != null) &#123; mConnectThread.cancel(); mConnectThread = null; &#125; // Cancel any thread currently running a connection if (mConnectedThread != null) &#123; mConnectedThread.cancel(); mConnectedThread = null; &#125; // If Accept Tread is null, create and start if (mAcceptThread != null) &#123; &#125; else &#123; this.mAcceptThread = new BluetoothService.AcceptThread(); this.mAcceptThread.start(); &#125; this.setState(STATE_LISTEN); &#125; @RequiresPermission(\"android.permission.BLUETOOTH\") public synchronized void connect(BluetoothDevice device) &#123; // Cancel any thread attempting to make a connection if (mState == STATE_CONNECTING) &#123; if (mConnectThread == null) &#123; &#125; else &#123; mConnectThread.cancel(); mConnectThread = null; &#125; &#125; // Cancel any thread currently running a connection if (mConnectedThread == null) &#123; &#125; else &#123; mConnectedThread.cancel(); mConnectedThread = null; &#125; // Start the thread to connect with the given device // 新建ConnectThread线程 mConnectThread = new BluetoothService.ConnectThread(device); mConnectThread.start(); setState(STATE_CONNECTING); &#125; @RequiresPermission(\"android.permission.BLUETOOTH\") public synchronized void connected(BluetoothSocket socket, BluetoothDevice device) &#123; // Cancel the thread that completed the connection if (this.mConnectThread != null) &#123; this.mConnectThread.cancel(); this.mConnectThread = null; &#125; // Cancel any thread currently running a connection if (this.mConnectedThread != null) &#123; this.mConnectedThread.cancel(); this.mConnectedThread = null; &#125; // Cancel if(this.mAcceptThread != null) &#123; this.mAcceptThread.cancel(); this.mAcceptThread = null; &#125; // Start the thread to manage the connection and perform transmissions // 开始ConnectedThread线程 mConnectedThread = new BluetoothService.ConnectedThread(socket); mConnectedThread.start(); Message msg = this.mHandler.obtainMessage(MainActivity.MESSAGE_DEVICE_NAME); Bundle bundle = new Bundle(); bundle.putString(DEVICE_NAME, device.getName()); msg.setData(bundle); this.mHandler.sendMessage(msg); setState(STATE_CONNECTED); &#125; public synchronized void stop() &#123; if (mConnectThread != null) &#123; mConnectThread.cancel(); mConnectThread = null; &#125; if (mConnectedThread != null) &#123; mConnectedThread.cancel(); mConnectedThread = null; &#125; if(this.mAcceptThread != null) &#123; this.mAcceptThread.cancel(); this.mAcceptThread = null; &#125; setState(STATE_NONE); &#125; // 写入功能 public void write(byte[] out) &#123; // Create temporary object ConnectedThread r; // Synchronize a copy of the ConnectedThread synchronized (this) &#123; if (mState != STATE_CONNECTED) return; r = mConnectedThread; r.write(out); &#125; &#125; // 连接失败处理 private void connectionFailed() &#123; setState(STATE_LISTEN); Message msg = this.mHandler.obtainMessage(MainActivity.MESSAGE_TOAST); Bundle bundle = new Bundle(); bundle.putString(\"toast\", \"Unable to connect device\"); msg.setData(bundle); this.mHandler.sendMessage(msg); &#125; // 连接丢失处理 private void connectionLost() &#123; setState(STATE_LISTEN); Message msg = this.mHandler.obtainMessage(MainActivity.MESSAGE_TOAST); Bundle bundle = new Bundle(); bundle.putString(\"toast\", \"Device connection was lost\"); msg.setData(bundle); this.mHandler.sendMessage(msg); &#125; // 关闭蓝牙 public void close() &#123; // Create temporary object ConnectedThread r; // Synchronize a copy of the ConnectedThread synchronized (this) &#123; if (mState != STATE_CONNECTED) return; r = mConnectedThread; r.cancel(); &#125; &#125; private class AcceptThread extends Thread &#123; private final BluetoothServerSocket mmServerSocket; public AcceptThread() &#123; BluetoothServerSocket tmp = null; try &#123; tmp = BluetoothService.this.mBtAdapter.listenUsingRfcommWithServiceRecord(\"BluetoothPlugin\", BluetoothService.MY_UUID); &#125; catch (IOException ignored) &#123; &#125; this.mmServerSocket = tmp; &#125; @RequiresPermission(\"android.permission.BLUETOOTH\") public void run() &#123; this.setName(\"AcceptThread\"); BluetoothSocket socket = null; while(BluetoothService.this.mState != STATE_CONNECTED) &#123; try &#123; socket = this.mmServerSocket.accept(); &#125; catch (IOException e1) &#123; break; &#125; if(socket != null) &#123; BluetoothService e = BluetoothService.this; synchronized(BluetoothService.this) &#123; switch(BluetoothService.this.mState) &#123; case STATE_NONE: case STATE_CONNECTED: try &#123; socket.close(); &#125; catch (IOException ignored) &#123; &#125; break; case STATE_LISTEN: case STATE_CONNECTING: BluetoothService.this.connected(socket, socket.getRemoteDevice()); &#125; &#125; &#125; &#125; &#125; public void cancel() &#123; try &#123; this.mmServerSocket.close(); &#125; catch (IOException ignored) &#123; &#125; &#125; &#125; private class ConnectThread extends Thread &#123; private final BluetoothSocket mmSocket; private final BluetoothDevice mmDevice; public ConnectThread(BluetoothDevice device) &#123; this.mmDevice = device; BluetoothSocket tmp = null; try &#123; // 验证 Android SPP协议的UUID tmp = device.createRfcommSocketToServiceRecord(MY_UUID); &#125; catch (IOException ignored) &#123; &#125; mmSocket = tmp; &#125; public void run() &#123; this.setName(\"ConnectThread\"); BluetoothService.this.mBtAdapter.cancelDiscovery(); try &#123; // 连接蓝牙 this.mmSocket.connect(); &#125; catch (IOException e) &#123; // 连接失败 connectionFailed(); try &#123; // 关闭蓝牙连接 mmSocket.close(); &#125; catch (IOException ignored) &#123; &#125; BluetoothService.this.start(); return; &#125; synchronized (BluetoothService.this) &#123; mConnectThread = null; &#125; // 连接后的操作（收发功能） connected(mmSocket, mmDevice); &#125; public void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException ignored) &#123; &#125; &#125; &#125; private class ConnectedThread extends Thread &#123; private final BluetoothSocket mmSocket; private final InputStream mmInStream; private final OutputStream mmOutStream; private BufferedReader bufferedReader; public ConnectedThread(BluetoothSocket socket) &#123; mmSocket = socket; InputStream tmpIn = null; OutputStream tmpOut = null; try &#123; // 建立Input Output流 tmpIn = socket.getInputStream(); tmpOut = socket.getOutputStream(); &#125; catch (IOException ignored) &#123; &#125; mmInStream = tmpIn; mmOutStream = tmpOut; &#125; public void run() &#123; char[] charBuffer = new char[128]; int bytesRead = -1; // 循环等待Input流 while (true) &#123; try &#123; // 有新的Input流进入，这里需要注意字符串格式，需要和发送端保持一致，这里为UTF_8 bufferedReader = new BufferedReader(new InputStreamReader(mmSocket.getInputStream(), StandardCharsets.UTF_8)); bytesRead = bufferedReader.read(charBuffer); // 将字符数组转为字符串 String readMessage = new String(charBuffer, 0, bytesRead); BluetoothService.this.mHandler.obtainMessage(MainActivity.MESSAGE_READ, readMessage).sendToTarget(); &#125; catch (IOException e) &#123; // IO错误则视为连接失败，即已经断开连接了 connectionLost(); break; &#125; &#125; &#125; public void write(byte[] buffer) &#123; try &#123; // 写入Output流 mmOutStream.write(buffer); &#125; catch (IOException ignored) &#123; &#125; &#125; public void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException ignored) &#123; &#125; &#125; &#125;&#125; &emsp;&emsp;这里新建了3个线程类ConnectThread，ConnectedThread和AcceptThread分别处理相应的线程事件。 添加蓝牙权限&emsp;&emsp;在AndroidManifest.xml文件中，增加蓝牙权限。1234567891011&lt;uses-permission android:name=\"android.permission.BLUETOOTH_CONNECT\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_SCAN\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt;&lt;uses-permission android:name=\"android.permission.WAKE_LOCK\"/&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/&gt; Unity蓝牙Mobile端模块Scene布局&emsp;&emsp;首先新建一个Canvas，然后放置相应的按钮控件，最后挂载一个TestBluetoothSend.cs脚本文件。 Unity与Android交互模块&emsp;&emsp;TestBluetoothSend.cs：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115using System;using System.Collections;using System.Collections.Generic;using System.Text;using UnityEngine;using UnityEngine.UI;public class TestBluetoothSend : MonoBehaviour&#123; private AndroidJavaClass jc; private AndroidJavaObject jo; private string deviceNameStr; private Dropdown dpn; private InputField bluetoothText; // Start is called before the first frame update void Start() &#123; //获得com.unity3d.player.UnityPlayer 下的类，对于扩展的Activity 是一个固定的写法。只要记住就行了 jc = new AndroidJavaClass(\"com.unity3d.player.UnityPlayer\"); //获得 jc 类中的 currentActivity 对象，也是一种固定的写法 jo = jc.GetStatic&lt;AndroidJavaObject&gt;(\"currentActivity\"); // 添加按钮对象 List&lt;string&gt; btnsName = new List&lt;string&gt;(); btnsName.Add(\"BtnOpen\"); btnsName.Add(\"BtnDisconnect\"); btnsName.Add(\"BtnSend\"); btnsName.Add(\"BtnReceive\"); // 输入控件 bluetoothText = GameObject.Find(\"Canvas/BluetoothText\").GetComponent&lt;InputField&gt;(); foreach (string btnName in btnsName) &#123; GameObject btnObj = GameObject.Find(btnName); Button btn = btnObj.GetComponent&lt;Button&gt;(); btn.onClick.AddListener(delegate () &#123; this.OnClick(btnObj); &#125;); &#125; // 添加下拉菜单选项 GameObject dpnObj = GameObject.Find(\"DpnDeviceSelect\"); dpn = dpnObj.GetComponent&lt;Dropdown&gt;(); dpn.ClearOptions(); dpn.onValueChanged.AddListener(DpnDeviceSelect);//监听点击 &#125; // 响应按钮点击事件 public void OnClick(GameObject sender) &#123; switch (sender.name) &#123; case \"BtnOpen\": BtnOpen(); break; case \"BtnDisconnect\": jo.Call(\"onDisconnect\"); break; case \"BtnSend\": BtnSend(); break; case \"BtnReceive\": BtnReceice(); break; default: break; &#125; &#125; public void BtnOpen() &#123; jo.Call(\"onOpen\"); deviceNameStr = jo.Call&lt;string&gt;(\"onScan\"); dpn.ClearOptions(); dpn.options.Clear(); string[] deviceNameList = deviceNameStr.Split(','); for (int i = 0; i &lt; deviceNameList.Length - 1; i++) &#123; Dropdown.OptionData data = new Dropdown.OptionData(); data.text = deviceNameList[i].ToString(); dpn.options.Add(data); &#125; &#125; public void DpnDeviceSelect(int n) &#123; jo.Call(\"onConnect\", dpn.captionText.text); &#125; public void BtnSend() &#123; string value = bluetoothText.text; jo.Call(\"onSendMessage\", value); &#125; public void BtnReceice() &#123; string readMessage = jo.Call&lt;string&gt;(\"onReadMessage\"); // 和发送端保持一致 UTF8Encoding utf8 = new UTF8Encoding(); Byte[] encodedBytes = utf8.GetBytes(readMessage); String decodedString = utf8.GetString(encodedBytes); bluetoothText.text = decodedString; &#125;&#125; &emsp;&emsp;AndroidJavaObject.Call说明：12JavaScript =&gt; function Call (methodName : string, params args : object[]) : voidC# =&gt; void Call(string methodName, params object[] args); &emsp;&emsp;参考文档：AndroidJavaClass、AndroidJavaObject、Unity5 中文 API 手册 &emsp;&emsp;打开蓝牙后，在选项框中选择相应的蓝牙设备，正确连接中，在输入控件输入相应的发送内容，点击发送即可向PC端设备发送内容。&emsp;&emsp;当有PC端设备发送内容时，点击接收即可在输入控件中看到发送的内容。 添加Android Jar包文件&emsp;&emsp;在Plugins文件夹中新建Android文件夹，将Android工程中编译出来的AndroidMainifest.xml和class.jar文件放到此文件夹中。&emsp;&emsp;注：需要将AndroidMainifest.xml文件中的123&lt;uses-sdk android:minSdkVersion=\"21\" android:targetSdkVersion=\"31\" /&gt; &emsp;&emsp;部分删除。 编译与Build&emsp;&emsp;选择File-&gt;Build Settings，选择Android设备，点击Player Settings中的Other Settings选项更改相应的包名和安卓API版本号。 Unity蓝牙PC端模块Scene布局&emsp;&emsp;同样的，在接收端也建立一些简单的布局控件。 蓝牙接收模块&emsp;&emsp;TestBluetoothReceive.cs：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181using System.Collections.Generic;using UnityEngine;using System.IO.Ports;using System.Threading;using UnityEngine.UI;using System.Text;public class TestBluetoothReceive : MonoBehaviour&#123; // 串口设置 private string portName = \"COM5\"; private int baudRate = 9600; private Parity parity = Parity.Odd; private int dataBits = 8; private StopBits stopBits = StopBits.One; // 串口对象 private SerialPort sp = null; // 读取数据线程对象 private Thread dataReceiveThread = null; // 是否接收数据 private bool canRecieveMsg = true; // 接收到的数据 string strReceived; private bool IsOpenSerial = false; private InputField bluetoothText; void Awake() &#123; strReceived = string.Empty; &#125; // Use this for initialization void Start() &#123; List&lt;string&gt; btnsName = new List&lt;string&gt;(); btnsName.Add(\"BtnOpenSerial\"); btnsName.Add(\"BtnCloseSerial\"); btnsName.Add(\"BtnSend\"); // 输入控件 bluetoothText = GameObject.Find(\"Canvas/BluetoothText\").GetComponent&lt;InputField&gt;(); foreach (string btnName in btnsName) &#123; GameObject btnObj = GameObject.Find(btnName); Button btn = btnObj.GetComponent&lt;Button&gt;(); btn.onClick.AddListener(delegate () &#123; this.OnClick(btnObj); &#125;); &#125; // 实例化对象 sp = new SerialPort(portName, baudRate, parity, dataBits, stopBits); // OpenPort(); &#125; public void OnClick(GameObject sender) &#123; switch (sender.name) &#123; case \"BtnOpenSerial\": OpenPort(); break; case \"BtnCloseSerial\": ClosePort(); break; case \"BtnSend\": BtnSend(); break; default: break; &#125; &#125; public void OpenPort() &#123; // 读取时间 sp.ReadTimeout = 100; try &#123; sp.Open(); Debug.Log(\"open success\"); // 实例化读取数据线程 this.dataReceiveThread = new Thread(new ThreadStart(DataReceiveFunction)); this.dataReceiveThread.IsBackground = true; this.dataReceiveThread.Start(); IsOpenSerial = true; &#125; catch (System.Exception ex) &#123; Debug.Log(ex.Message); &#125; &#125; public void ClosePort() &#123; try &#123; sp.Close(); Debug.Log(\"close success\"); dataReceiveThread.Abort(); &#125; catch (System.Exception ex) &#123; Debug.Log(ex.Message); &#125; &#125; /// &lt;summary&gt; /// 可以读取多个字符，即字节数组；但是需要的平台的是.net 4.6 /// 将 Scripting Runing Vision 和Api Compatibility都改为.Net 4.6 /// &lt;/summary&gt; void DataReceiveFunction() &#123; try &#123; while (canRecieveMsg) &#123; // 设定读取间隔 Thread.Sleep(25); if (!sp.IsOpen) return; int datalength = sp.BytesToRead; if (datalength == 0) &#123; continue; &#125; byte[] bytes = new byte[datalength]; sp.Read(bytes, 0, datalength); strReceived = System.Text.Encoding.Default.GetString(bytes); &#125; &#125; catch (System.Exception ex) &#123; if (ex.GetType() != typeof(ThreadAbortException)) &#123; &#125; Debug.Log(ex); &#125; &#125; public void handleReceivedData(string str) &#123; if (str != \"\") &#123; bluetoothText.text = str; &#125; &#125; private void Update() &#123; if (IsOpenSerial) &#123; handleReceivedData(strReceived); strReceived = string.Empty; &#125; &#125; void OnApplicationQuit() &#123; canRecieveMsg = false; ClosePort(); &#125; public void BtnSend() &#123; byte[] bytes = Encoding.GetEncoding(\"utf-8\").GetBytes(bluetoothText.text); sp.Write(bytes, 0, bytes.Length); &#125;&#125; &emsp;&emsp;首先配置串口信息，然后实例化串口对象，最后单独开启一个线程处理接收到的串口数据。&emsp;&emsp;这里的COM端口号信息可以在系统-&gt;蓝牙设置中查看：&emsp;&emsp;也可以使用串口调试工具进行简单的测试。 编译与build&emsp;&emsp;这里编译生成选择PC即可。&emsp;&emsp;运行后，首先打开蓝牙串口，如果此时Mobile端有数据发送过来，就会在输入控件中显示。&emsp;&emsp;在输入控件中输入相应内容，并点击发送，此时在Mobile端点击接收即可在Mobile端的输入控件中看到发送的内容。 常见问题整理 Android最新的添加蓝牙注解包为import androidx.annotation.RequiresPermission; 每次编辑完Anroid工程要重新编译打包。 Unity打包andorid jar包时出现报错：提示 \\unityLibrary\\src\\main\\java\\com\\unity3d\\player\\UnityPlayerActivity.java使用或覆盖了已过时的 API。，将Unity中的UnityPlayerActivity.java文件(C:\\Program Files\\Unity\\Hub\\Editor\\2020.3.17f1c1\\Editor\\Data\\PlaybackEngines\\AndroidPlayer\\Source\\com\\unity3d\\player\\UnityPlayerActivity.java)删除。 使用蓝牙串口时，注意Unity中.net的版本号，本项目采用的是.net 4.0版本。","categories":[{"name":"Unity开发与应用","slug":"Unity开发与应用","permalink":"http://cxx0822.github.io/categories/Unity开发与应用/"}],"tags":[]},{"title":"Unity实现PDF文件的生成","slug":"Unity实现PDF文件的生成","date":"2021-10-20T15:26:21.000Z","updated":"2022-03-21T06:19:12.592Z","comments":true,"path":"2021/10/20/unity-shi-xian-pdf-wen-jian-de-sheng-cheng/","link":"","permalink":"http://cxx0822.github.io/2021/10/20/unity-shi-xian-pdf-wen-jian-de-sheng-cheng/","excerpt":"","text":"平台&emsp;&emsp;操作系统：Ubuntu16.04+Windows 10&emsp;&emsp;Web前端框架：Vue.js + EChart.js + Element UI&emsp;&emsp;Web后端框架：Spring Boot&emsp;&emsp;Unity web插件：Embedded Browser&emsp;&emsp;Unity PDF插件：iTextSharp 方案说明&emsp;&emsp;&emsp;&emsp;PDF主要分为两部分，即文字+图片。文字部分可以直接由iTextSharp插件提供的库函数编写，图片部分首先需要根据Web前端和EChart插件生成图表信息，然后通过axios交互技术，将此信息传递给Web后端，并生成本地图片文件，最后再由iTextSharp插件读取本地图片并写入PDF中。 Web前端——生成图表环境配置&emsp;&emsp;安装EChart：1npm install echarts --save &emsp;&emsp;安装Element UI：1npm i element-ui -S &emsp;&emsp;安装axios：1npm install axios -S &emsp;&emsp;安装qs：1npm install qs -S &emsp;&emsp;然后在main.js中声明：123456789101112131415161718192021import Vue from 'vue'import App from './App'import qs from 'qs'import axios from 'axios'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import echarts from 'echarts'import router from './router'Vue.config.productionTip = falseVue.prototype.$qs = qsVue.prototype.$axios = axiosVue.prototype.$echarts = echartsVue.use(ElementUI) 生成EChart123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;template&gt; &lt;div id=\"main\" class=\"div-main-chart\" style=\"width:400px;height:300px;\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; chartDom: null, myChart: null, option: null, categories: [], data: [], isUpdateChart: false, updateChartInterval: null, updateChartBtnName: '动态更新' &#125; &#125;, created () &#123; this.initOption() &#125;, mounted () &#123; this.chartDom = document.getElementById('main') this.myChart = this.$echarts.init(this.chartDom) // 使用刚指定的配置项和数据显示图表。 this.myChart.setOption(this.option) // 在vue的钩子函数中将需要调用的函数赋值给window。 // 否则Unity无法识别和调用 window.updateChart = this.updateChart window.updateChartAuto = this.updateChartAuto window.saveChart = this.saveChart &#125;, methods: &#123; initOption () &#123; this.option = &#123; backgroundColor: '#008B93', title: &#123; text: 'Estun Medical', x: 'center', y: 'top' &#125;, // 悬浮框，鼠标放置在数据上面时的响应 tooltip: &#123; trigger: 'axis', axisPointer: &#123; type: 'cross', label: &#123; backgroundColor: '#283b56' &#125; &#125; &#125;, legend: &#123; x: 'right' &#125;, // 右上角小工具 toolbox: &#123; show: false, feature: &#123; dataView: &#123; readOnly: false &#125;, restore: &#123;&#125;, saveAsImage: &#123;&#125; &#125; &#125;, dataZoom: &#123; show: false, start: 0, end: 100 &#125;, // 和下面的系列对应，有几个图就有几个坐标系轴 xAxis: &#123; // 坐标轴类型。'value' 数值轴，适用于连续数据。'category' 类目轴，适用于离散的类目数据 type: 'category', boundaryGap: true // data: this.categories &#125;, yAxis: &#123; type: 'value', scale: true, name: 'Number', max: 30, min: 0, boundaryGap: [0.2, 0.2] &#125;, // 系列，即包含几种图 series: &#123; name: 'Number Line', type: 'line' // data: this.data &#125; &#125; &#125;, updateChartAuto () &#123; if (this.isUpdateChart) &#123; this.isUpdateChart = false this.updateChartBtnName = '动态更新' clearInterval(this.updateChartInterval) &#125; else &#123; this.updateChartBtnName = '暂停更新' this.updateChartInterval = setInterval(() =&gt; &#123; this.isUpdateChart = true let axisData = new Date().toLocaleTimeString().replace(/^\\D*/, '') // shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 if (this.data.length &gt; 10) &#123; this.data.shift() &#125; this.data.push(Math.round(Math.random() * 30)) if (this.categories.length &gt; 10) &#123; this.categories.shift() &#125; this.categories.push(axisData) this.myChart.setOption(&#123; xAxis: &#123; data: this.categories &#125;, series: &#123; data: this.data &#125; &#125;) &#125;, 1000) &#125; &#125;, saveChart (serverIp, imagePath, imageName) &#123; // 使用qs插件将参数传递给后端 this.$axios.post(serverIp + '/EChart/getImage', this.$qs.stringify(&#123; imgInfo: this.myChart.getDataURL(), imagePath: imagePath, imageName: imageName &#125;)) &#125; &#125;&#125;&lt;/script&gt; &emsp;&emsp;这里通过vue的axios技术将EChart的信息(getDataURL())，传递给web后端，并开放出服务器地址、图片保存路径和图片名字参数供Unity调用。&emsp;&emsp;这里需要使用过qs插件来封装参数信息，否则web后端会接收不到。&emsp;&emsp;值得注意的是，必须要将和Unity交互的函数赋值给window，否则Unity无法调用。 build打包&emsp;&emsp;最后通过npm run build生成dist文件夹，并将整个文件夹复制到Unity工程文件夹目录中的BrowserAssets文件夹中(和Assets同级文件夹，没有则新建)。 Web后端——保存图表保存图片接口&emsp;&emsp;controller层：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import org.apache.commons.lang3.StringUtils;import org.apache.tomcat.util.codec.binary.Base64;import org.apache.tomcat.util.http.fileupload.IOUtils;import org.springframework.util.ClassUtils;import org.springframework.web.bind.annotation.*;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;@RestController@CrossOrigin(originPatterns = \"*\", methods = &#123;RequestMethod.GET, RequestMethod.POST&#125;)public class EchartController &#123; @PostMapping(value = \"EChart/getImage\") public void getEChartFromVue(String imgInfo, String imagePath, String imageName) &#123; if (StringUtils.isBlank(imgInfo)) &#123; System.out.println(\"imgInfo为空,未从前台获取到base64图片信息!\"); return; &#125; // 传递过程中 \"+\" 变为了 \" \". String newImgInfo = imgInfo.replaceAll(\" \", \"+\"); File file = new File(imagePath + imageName); decodeBase64(newImgInfo, file); &#125; /** * 解析Base64位信息并输出到某个目录下面. * @param base64Info base64串 * @param imgPath 生成的文件路径 */ private void decodeBase64(String base64Info, File imgPath) &#123; if (StringUtils.isEmpty(base64Info)) &#123; return; &#125; // 数据中：data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABI4AAAEsCAYAAAClh/jbAAA ... 在\"base64,\"之后的才是图片信息 String[] arr = base64Info.split(\"base64,\"); // 将图片输出到系统某目录. OutputStream out = null; try &#123; // 使用了Apache commons codec的包来解析Base64 byte[] buffer = Base64.decodeBase64(arr[1]); out = new FileOutputStream(imgPath); out.write(buffer); &#125; catch (IOException e) &#123; e.printStackTrace(); //log.error(\"解析Base64图片信息并保存到某目录下出错!\", e); &#125; finally &#123; IOUtils.closeQuietly(out); &#125; &#125;&#125; 交互问题&emsp;&emsp;这里主要需要解决2个问题：跨域和Https协议。&emsp;&emsp;跨域问题即Web前后端交互时数据的安全性问题，添加注解CrossOrigin即可。&emsp;&emsp;Https协议问题主要是因为在Unity的Web插件Embedded Browser中，默认只能访问https协议的网站，而基于Spring Boot生成的后端默认是基于http协议的，因此需要将其更改为https协议。&emsp;&emsp;首先在任意目录下，输入cmd命令：1keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650 &emsp;&emsp;然后根据提示输入密码等其他信息，生成keystore.p12 SSL证书文件。&emsp;&emsp;然后将此文件复制到Spring Boot工程文件夹下的resources文件夹下，并更改application.properties文件： 1234server.ssl.key-store=classpath:keystore.p12server.ssl.key-store-password=123456server.ssl.keyStoreType=PKCS12server.ssl.keyAlias=tomcat &emsp;&emsp;此时，启动后端程序，即可通过https:// 来访问。&emsp;&emsp;最后还需要在Embedded Browser插件中，找到BrowserNative.cs脚本，并找到commandLineSwitches变量，在最后一行，添加&quot;--ignore-certificate-errors&quot;字段，将任何https网站的私有证书都进行了忽略并信任。 编译打包&emsp;&emsp;最后点击右侧栏中的Maven控件，依次点击Lifecycle中的clean和package功能生成Jar包文件。 Unity——生成PDF环境配置&emsp;&emsp;首先将Embedded Browser包导入到工程中，然后将itextsharp所需的dll等库文件放置在Assets中的Plugins-&gt;PDF文件夹中。 功能实现&emsp;&emsp;&emsp;&emsp;界面主要包括Embedded Browser的BrowserGUI控件和3个功能按钮。&emsp;&emsp;Controller.cs：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118using System.Collections;using System.Collections.Generic;using System;using UnityEngine;using UnityEngine.UI;using ZenFulcrum.EmbeddedBrowser;using iTextSharp.text.pdf;using iTextSharp.text;using System.Threading;public class Controller : MonoBehaviour &#123; public Browser browser; private string serverIp; private string imagePath; private string imageName; // Start is called before the first frame update void Start() &#123; // 添加按钮对象 List&lt;string&gt; btnsName = new List&lt;string&gt;(); btnsName.Add(\"BtnUpdateChart\"); btnsName.Add(\"BtnSaveChart\"); btnsName.Add(\"BtnSaveToPDF\"); foreach (string btnName in btnsName) &#123; GameObject btnObj = GameObject.Find(btnName); Button btn = btnObj.GetComponent&lt;Button&gt;(); btn.onClick.AddListener(delegate () &#123; this.OnClick(btnObj); &#125;); &#125; &#125; // 响应按钮点击事件 public void OnClick(GameObject sender) &#123; switch (sender.name) &#123; case \"BtnUpdateChart\": // browser.CallFunction(\"updateChart\", 1, 10).Done(); browser.CallFunction(\"updateChartAuto\").Done(); break; case \"BtnSaveChart\": SaveChart(); break; case \"BtnSaveToPDF\": CreatePDF(); break; default: Debug.Log(\"none\"); break; &#125; &#125; // Update is called once per frame void Update() &#123; &#125; public void SaveChart()&#123; // 这里更改为https，否则无法访问(Unity机制) serverIp = \"https://192.168.64.131:8080\"; imagePath = \"/home/cxx/\"; imageName = \"123.png\"; browser.CallFunction(\"saveChart\", serverIp, imagePath, imageName).Done(); &#125; public void CreatePDF()&#123; SaveChart(); Thread.Sleep (2000); //使用字体 //BaseFont bf = BaseFont.CreateFont(\"/usr/share/fonts/truetype/ubuntu-font-family/UbuntuMono-R.ttf\", BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED); // 创建 PDF 文档 iTextSharp.text.Document document = new iTextSharp.text.Document(); // 创建写入器实例，PDF 文件将会保存到这里 iTextSharp.text.pdf.PdfWriter.GetInstance(document, new System.IO.FileStream(\"/home/cxx/demo.pdf\", System.IO.FileMode.Create) ); // 打开文档 document.Open(); //iTextSharp.text.Font font = new iTextSharp.text.Font(bf); //写入一个段落, Paragraph //Paragraph title = new Paragraph(\"Estun Medical Report\", font); Paragraph title = new Paragraph(\"Estun Medical Report\"); document.Add(title); //添加图片 try &#123; iTextSharp.text.Image image = iTextSharp.text.Image.GetInstance(\"/home/cxx/123.png\"); document.Add(image); Debug.Log(\"Save image Success!\"); System.Console.WriteLine(\"Save image Success!\"); &#125; catch( System.Net.WebException e) &#123; Debug.Log(\"no image file!\"); &#125; document.Close(); &#125;&#125; &emsp;&emsp;这里使用字体时，在build打包后出现一定的问题，可以使用默认的字体代替。 build打包&emsp;&emsp;最后打包运行，添加--logFile参数可以查看运行日志： ./***.x86_64 -logFile /path/to/logfile.txt","categories":[{"name":"Unity开发与应用","slug":"Unity开发与应用","permalink":"http://cxx0822.github.io/categories/Unity开发与应用/"}],"tags":[]},{"title":"基于ROSWEB的WAM简单功能开发","slug":"基于ROSWEB的WAM简单功能开发","date":"2021-10-20T15:24:57.000Z","updated":"2022-03-21T06:19:12.779Z","comments":true,"path":"2021/10/20/ji-yu-rosweb-de-wam-jian-dan-gong-neng-kai-fa/","link":"","permalink":"http://cxx0822.github.io/2021/10/20/ji-yu-rosweb-de-wam-jian-dan-gong-neng-kai-fa/","excerpt":"","text":"平台&emsp;&emsp;操作系统：Ubuntu18.04、Windows 10&emsp;&emsp;操作平台：Barrett七自由度机械臂&emsp;&emsp;Web前端框架：Node.js + Vue.js + Element UI&emsp;&emsp;ROS与Web开发工具：Robot Web Tools(roslibjs+ros2djs+ros3djs)&emsp;&emsp;开发工具：Visual Studio Code&emsp;&emsp;服务器：Tomcat8.5 环境搭建基础环境搭建&emsp;&emsp;参照基于Vue.js的ROSWeb环境搭建文档。 ROSWeb工具简介&emsp;&emsp;ros-web是ros官方提供的从ros到web端的一个开源接口。其主要的功能库有3个，即roslibjs基本库，ros2djs2D库和ros3djs3D库。本项目主要用的是roslibjs和ros3djs。 roslibjs库文件&emsp;&emsp;roslibjs库是ros-web中的基础库，可以实现创建ROS，订阅消息、发布话题和调用服务等功能。其中比较重要的类有ROS、Topic和Service。 ROS类&emsp;&emsp;从ROS类的源码中可以看出，其底层也是基于socket协议实现的ros与web连接。ROS类在定义时，只需要提供ros端的IP和端口号即可(需要和rosbridge部分对应)，如：123var ros = new ROSLIB.Ros(&#123; url: 'ws://192.168.*.*:9090' &#125;) &emsp;&emsp;定义完该类后，可以使用ros.on()函数实时监听ros的系统状态。Ros类一共提供了3种状态，即connection、error和close，分别对应连接成功、连接错误和关闭连接状态。在对应的回调函数里面可以编写相应的逻辑功能。12345678910111213141516171819202122232425262728this.ros.on('connection', () =&gt; &#123; this.$message(&#123; message: '连接成功！', type: 'success' &#125;)&#125;)this.ros.on('error', (e) =&gt; &#123; this.$message.error('连接失败！')&#125;)this.ros.on('close', () =&gt; &#123; this.$message.error('关闭连接！')&#125;)``` ### `Topic`类```jsvar wamPost = new ROSLIB.Topic(&#123; ros: ros, name: '/wam/pose', messageType: 'geometry_msgs/PoseStamped' &#125;)wamPost.subscribe((message) =&gt; &#123; console.log(message) wamPost.unsubscribe()&#125;) &emsp;&emsp;Topic类的构造函数需要给定3个参数，即ros类实例，话题名称name和话题的消息格式messageType。实例化类后，即可调用subscribe()函数订阅话题，并通过回调函数里面的messgage值获取话题信息，在回调函数中可以使用unsubscribe()函数取消订阅。12345678var cmdVel = new ROSLIB.Topic(&#123; ros: ros, name: '/turtle1/cmd_vel', messageType: 'geometry_msgs/Twist'&#125;)geometryMsgsTwist.linear.x = 1cmdVel.publish(geometryMsgsTwist) &emsp;&emsp;除了可以订阅话题并获取信息，还可以发布话题。实例化话题类的方法和订阅一样，但需要提前定义好需要发布的话题消息格式和内容。123456789101112var geometryMsgsTwist = new ROSLIB.Message(&#123; linear: &#123; x: 0.0, y: 0.0, z: 0.0 &#125;, angular: &#123; x: 0.0, y: 0.0, z: 0.0 &#125;&#125;) &emsp;&emsp;消息的定义为对象类型的键值对数据，需要根据实际话题的消息类型来具体定义。&emsp;&emsp;定义好要发送的话题消息数据后，使用publich()发布话题。这里不需要订阅话题。 Service类1234567891011121314151617var setPenClient = new ROSLIB.Service(&#123; ros: ros, name: '/turtle1/set_pen', serviceType: 'turtlesim/SetPen'&#125;)var request = new ROSLIB.ServiceRequest(&#123; r: 255, g: 0, b: 0, width: 2, off: 0&#125;)setPenClient.callService(request, (result) =&gt; &#123; console.log(result)&#125;) &emsp;&emsp;Service类的构造函数也需要给定3个参数，即ros类实例，服务名称name和服务的消息格式serviceType。这里同样需要先定义好服务的请求信息，格式为对象类型的键值对数据。实例化服务类后，可以通过callService()函数调用服务。 ros3djs库文件&emsp;&emsp;ros3djs用于可视化3D模型相关的功能。其中比较重要的类有Viewer、TFClient和UrdfClient等。阅读底层代码可以发现，ros3djs是基于three.js 3D库实现的。 Viewer类123456789var viewer = new ROS3D.Viewer(&#123; // 对应&lt;div&gt;元素 divID: divID, width: width, height: height, // 平滑 抗锯齿 antialias: true, background: color&#125;) &emsp;&emsp;Viewer用于创建一块用于显示3D模型的可视化区域。需要的参数为html的div区域ID divID，区域的宽度width，区域的高度heigh，是否抗锯齿antialias和背景颜色background等信息。实例化类后，即可在网页中看到一块空白区域。如需添加网格，调用ddObject(new ROS3D.Grid())函数即可。 TFClient类1234567var tfClient = new ROSLIB.TFClient(&#123; ros: ros, angularThres: 0.01, transThres: 0.01, rate: 10.0, fixedFrame: fixedFrame&#125;) &emsp;&emsp;TFClient类是一个基础类，后续的一些类的参数经常需要使用它，构造函数的参数值按照官网提供的参数值即可，其中比较重要的一个参数是fixedFrame参数，这里需要和urdf模型中的基础坐标系相对应，否则会出现模型加载不完整，无法控制移动等问题。 UrdfClient类123456789var urdfClient = new ROS3D.UrdfClient(&#123; ros: ros, tfClient: tfClient, // path: 'http://resources.robotwebtools.org/', path: 'http://localhost:8080/static', rootObject: viewer.scene, loader: ROS3D.COLLADA_LOADER_2 // loader: ROS3D.COLLADA_LOADER&#125;) &emsp;&emsp;UrdfClient类可以可视化ros中的urdf模型，其主要的参数有实例化的ros，实例化的tfClient，模型存放的路径path，根对象rootObject(即urdf放在哪个区域)和模型加载器loader。这里比较重要的参数为path路径参数，这里存放的是网络或者本地的模型链接地址，本项目使用的vue.js前端框架，http://localhost:8080网址对应的即为整个项目文件夹的根目录，因此实际的模型地址位于http://localhost:8080/static中(需要将模型放在该文件夹下)。 设计思想界面设计&emsp;&emsp;整体界面分为3个部分，上面为logo显示和一些常用的功能选项。下面左侧为WAM 3D模型的可视化显示，右侧为功能逻辑部分，主要测试一些简单的基础功能。&emsp;&emsp;其中WAM模型在连接成功会实时显示当前的位姿，数据也会实时更新在右下方的表格中。拖动右侧的滑动也会实时更新WAM的位姿状态。 逻辑功能&emsp;&emsp;ROS中常见的功能主要有订阅消息、发布话题和调用服务。另外还需要将3D模型能够可视化显示在web网页中。因此本项目主要实现的逻辑功能包括： 订阅消息(Subscribing message) 发布话题(publishing topic) 调用服务(Calling service) 针对urdf和xacro文件的3D模型可视化 代码模块添加依赖文件&emsp;&emsp;在vue.js的静态文件夹static中新建文件夹rosweb，用于存放所需要的第三方JavaScript文件。&emsp;&emsp;其中roslib.js和ros3d.js为ros-web提供的库文件，剩余JavaScript文件为用于绘制3D可视化模型的库文件(主要为three.js框架及其依赖库)。&emsp;&emsp;然后在index.html入口文件中，将这些文件添加&lt;head&gt;标签中。123456&lt;script src=\"./static/rosweb/three.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/ColladaLoader.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/STLLoader.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/eventemitter2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/roslib.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/ros3d.js\"&gt;&lt;/script&gt; &emsp;&emsp;由于ros-web的ros3d.js库文件在加载3D模型时，需要本地或者网络的模型链接，因此需要将ros中的模型部分放在static文件夹中。这里将barrett_ros中的barrett_model部分添加至static文件夹中： 主界面功能实现&emsp;&emsp;代码文件位于src-&gt;components-&gt;HelloWorld.vue。基本按照ROSWeb工具简介解释的部分，更改为实际的话题/服务和消息的数据类型即可。 常见问题整理 在index.html中导入完js文件，需要在.eslintrc.js中的rules.globals声明全局变量：12345678910111213// add your custom rules here rules: &#123; // allow async-await 'generator-star-spacing': 'off', // allow debugger during development 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'no-unused-vars': 'off' &#125;, \"globals\":&#123; \"THREE\": true, \"ROSLIB\": true, \"ROS3D\": true, &#125; &emsp;&emsp;否则会出现无法找到该变量的定义的问题。 回调函数要改用为箭头函数，这样就可以使用使用this对象了。 解析订阅话题的接收到的值时，需要根据实际的格式对其解析。 如果遇到ctrl+c关闭节点后，节点仍然存在的问题：在环境变量中添加export ROS_HOSTNAME=hostname(输入指令hostname即可查看自己的)，且在关闭节点时不要使用ctrl+c，直接关闭窗口。 连续发布多个话题或调用多个服务时，只会执行最后一个。这是ros系统的问题，话题是异步通讯机制，发布相同消息时，只会处理最后一个，服务是同步通讯机制，可以通过判断返回的信息来实现依次调用相同的多个服务。","categories":[{"name":"Web前端开发与应用","slug":"Web前端开发与应用","permalink":"http://cxx0822.github.io/categories/Web前端开发与应用/"}],"tags":[]},{"title":"基于Vue.js的ROSWeb环境搭建","slug":"基于Vue.js的ROSWeb环境搭建","date":"2021-10-20T15:07:03.000Z","updated":"2022-03-21T06:19:12.801Z","comments":true,"path":"2021/10/20/ji-yu-vue.js-de-rosweb-huan-jing-da-jian/","link":"","permalink":"http://cxx0822.github.io/2021/10/20/ji-yu-vue.js-de-rosweb-huan-jing-da-jian/","excerpt":"","text":"平台&emsp;&emsp;操作系统：Ubuntu18.04&emsp;&emsp;Web前端框架：Node.js + Vue.js + Element UI&emsp;&emsp;ROS与Web开发工具：Robot Web Tools(roslibjs+ros2djs+ros3djs)&emsp;&emsp;开发工具：Visual Studio Code&emsp;&emsp;服务器：Tomcat8.5 环境搭建Vue.js环境搭建安装node.js&emsp;&emsp;打开Node.js官网，查看最新版本号。&emsp;&emsp;本教程中LTS(稳定发行版)版本为14.17，在终端输入指令，添加源：1curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash - &emsp;&emsp;注意这里的setup_14就是安装14版本，后续有新版本或者想安装其他版本更改此数字即可。&emsp;&emsp;然后根据提示的指令(上述指令输入完终端的提示部分)安装node.js和npm：1sudo apt-get install -y nodejs &emsp;&emsp;最后检查是否安装正确：12node -vnpm -v &emsp;&emsp;注：这里注意最好不要使用sudo apt-get install nodejs方式安装，因为此方式安装的版本过低，后续安装其他库时会出现一定的错误。 安装cnpm(淘宝镜像)&emsp;&emsp;在终端输入指令：1sudo npm install -g cnpm --registry=https://registry.npm.taobao.org &emsp;&emsp;注：这里还是建议安装cnpm，库会比较新。 安装Vue.js&emsp;&emsp;安装vue脚手架工具vue-cli，用来搭建项目所需模板框架:1sudo cnpm install -g vue-cli &emsp;&emsp;查看版本号，确定安装完成：1vue -V Visual Studio Code环境搭建VSCode安装&emsp;&emsp;打开官网，下载最新版本的deb格式。&emsp;&emsp;注：这里最好不要从Ubuntu系统的软件商城里面安装，里面版本较老，不支持中文输入。&emsp;&emsp;下载完成后，输入命令安装：1sudo dpkg -i *****.deb VSCode配置Vue.js安装插件 安装vetur插件，vue语法的高亮插件。 安装eslint插件，智能错误检测插件。 创建第一个项目 在VSCode中打开一个文件夹(自己新建)，并打开终端，输入指令创建一个新项目： 1vue init webpack ”项目名称“ &emsp;&emsp;下载模板后，根据提示完成配置。&emsp;&emsp;附：配置信息：&emsp;&emsp;Project name—-项目名称；&emsp;&emsp;Project description—-项目描述；&emsp;&emsp;Author—-作者；&emsp;&emsp;Runtime + Compiler: recommended for most users和Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere两个选项—-第一个是运行加编译，推荐使用，第二个仅运行时。通过键盘上下按钮选择后，点击回车；&emsp;&emsp;Install vue-router?&lt;Y/n&gt;—-是否安装vue路由插件，输入“Y”,点击回车；&emsp;&emsp;Use ESLint to lint your code? &lt;Y/n&gt;—-是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用，输入“y”，点击回车；&emsp;&emsp;Set up unit tests&lt;Y/n&gt;—-是否安装单元测试，这里输入“n”，点击回车；&emsp;&emsp;Setup e2e tests with Nightwatch&lt;Y/n&gt;?—-是否安装e2e测试，这里输入“n”，点击回车；&emsp;&emsp;Should we run “npm install” for you after the project has been created?&lt;recommended&gt;&lt;use arrow keys&gt;Yes, use NPM Yes, use Yarn No, I will handle that myself—-三个选项，这里我们选择第三个，因为通过npm install安装vue项目依赖库，非常的慢，我们可以在项目创建后，自己通过“cnpm install”安装。 切换到项目目录 1cd ”项目名称“ 安装依赖包 1cnpm install 启动项目 1cnpm run dev 输入http://localhost:8080/#/，打开网址。 注：常见问题整理 npm(cnpm) run dev报错，Error: ENOSPC: System limit for number of file watchers reached，在终端输入以下命令： 1echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p VSCode空格间隔小，终端字间隔很大，这里主要是在Ubuntu环境下字体的问题，按下ctrl+shift+p，选择首选项：打开设置，打开User-&gt;setting.json文件，输入以下配置： 123456789&#123; \"editor.fontFamily\": \"'monospace'\", \"editor.fontLigatures\": true, \"editor.fontSize\": 20, \"editor.codeLensFontFamily\": \"'monospace'\", \"terminal.integrated.fontFamily\": \"monospace\", \"terminal.integrated.fontSize\": 16, \"window.zoomLevel\": 2&#125; &emsp;&emsp;重启软件即可。 Robot Web环境搭建安装Robot Web&emsp;&emsp;安装rosbridge_suit功能包：1sudo apt-get install ros-melodic-rosbridge-suite &emsp;&emsp;下载roslibjs，ros2djs和ros3djs功能包：123git clone https://github.com/RobotWebTools/roslibjs.gitgit clone https://github.com/RobotWebTools/ros2djsgit clone https://github.com/RobotWebTools/ros3djs &emsp;&emsp;测试是否安装成功：1roslaunch rosbridge_server rosbridge_websocket.launch &emsp;&emsp;附：Ubuntu16.04安装rosbridge&emsp;&emsp;如果Ubuntu16.04不支持apt-get安装，只能下载源码编译安装(catkin_make)。除了rosbridge官方源码还需要rosauth源码，和python的一些开源库(根据报错提示安装)。 结合Vue.js和Element UI下载rosweb的JS文件&emsp;&emsp;three.js&emsp;&emsp;ColladaLoader.js&emsp;&emsp;STLLoader.js&emsp;&emsp;eventemitter2.min.js&emsp;&emsp;roslib.js&emsp;&emsp;ros3d.js&emsp;&emsp;下载完成后，在vue.js工程中的static文件夹下新建rosweb文件夹，并将这些js文件放入该文件夹。&emsp;&emsp;打开vue.js工程中的index.html文件，在head区域添加以下js文件：123456&lt;script src=\"./static/rosweb/three.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/ColladaLoader.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/STLLoader.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/eventemitter2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/roslib.js\"&gt;&lt;/script&gt;&lt;script src=\"./static/rosweb/ros3d.js\"&gt;&lt;/script&gt; &emsp;&emsp;打开vue.js工程中的.eslintrc.js文件，在rules中添加全局变量：12345678910111213// add your custom rules here rules: &#123; // allow async-await 'generator-star-spacing': 'off', // allow debugger during development 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'no-unused-vars': 'off' &#125;, \"globals\":&#123; \"THREE\": true, \"ROSLIB\": true, \"ROS3D\": true &#125; 安装Element UI&emsp;&emsp;终端输入npm i element-ui -S&emsp;&emsp;在src-&gt;main.js中输入以下内容：1234import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.use(ElementUI); 部署到服务器下载安装Java和Tomcat&emsp;&emsp;下载java jdk 1.8&emsp;&emsp;下载Tomcat8.5(当然也可以是其他版本)&emsp;&emsp;打开~/.bashrc添加到环境变量：1234export JAVA_HOME=/path/to/jdk1.8.0_151export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JAVA_HOME&#125;/jre/libexport PATH=.:$&#123;JAVA_HOME&#125;/bin:$PATHexport CATALINA_HOME=/path/to/apache-tomcat-8.5.69 &emsp;&emsp;这里的/path/to为具体的java sdk和tomcat的路径。 打包Vue.js项目&emsp;&emsp;运行npm run dev指令打包生成dist文件夹。 部署到Tomcat服务器&emsp;&emsp;将dist文件夹到放到tomcat-&gt;webapps中。&emsp;&emsp;进入tomcat-&gt;bin目录，运行启动服务器指令sh startup.sh(可能会出现一些执行权限问题，百度自行更改即可)。&emsp;&emsp;打开网址ip:8080/dist即可进入页面，同一局域网下均可进入该网页。&emsp;&emsp;更改Tomcat服务器的默认主页：打开tomcat-&gt;config-&gt;server.xml找到host节点，添加以下配置：1&lt;Context path=\"\" docBase=\"/path/to/dist\" debug=\"0\" reloadable=\"true\"/&gt; &emsp;&emsp;这里的docBase更改为自己的项目目录，然后重启服务器输入网址ip:8080即可。&emsp;&emsp;注：如果启动失败(启动后网页无法显示)，注意检查server.xml中的host和docBase是否正确！ 注：常见问题整理 首页为空白页更改config/index.js中的assetsPublicPath为&#39;./&#39; Element UI图标显示问题在build/utils.js中，if (options.extract)的return部分增加一行： 123456789if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: 'vue-style-loader', publicPath: '../../' // 增加的部分 &#125;)&#125; else &#123; return ['vue-style-loader'].concat(loaders)&#125; CSS样式没生效在src-&gt;main.js中，将import router from &#39;./router&#39;这一句放在所有的import的最后一行。","categories":[{"name":"Web前端开发与应用","slug":"Web前端开发与应用","permalink":"http://cxx0822.github.io/categories/Web前端开发与应用/"}],"tags":[]},{"title":"基于Retrofit+RxJava的APP网络请求技术","slug":"基于Retrofit+RxJava的APP网络请求技术","date":"2021-07-01T01:59:14.000Z","updated":"2022-03-21T06:19:12.781Z","comments":true,"path":"2021/07/01/ji-yu-retrofit-rxjava-de-app-wang-luo-qing-qiu-ji-zhu/","link":"","permalink":"http://cxx0822.github.io/2021/07/01/ji-yu-retrofit-rxjava-de-app-wang-luo-qing-qiu-ji-zhu/","excerpt":"","text":"Okhttp3依赖配置&emsp;&emsp;build.gradle添加依赖：1implementation 'com.squareup.okhttp3:okhttp:3.10.0' 网络配置&emsp;&emsp;添加res-&gt;xml-&gt;network-security-config.xml文件：1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=\"true\" /&gt;&lt;/network-security-config&gt; &emsp;&emsp;在AndroidMainifest.xml中添加网络安全权限（一共2处）。12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.njtech.myokhttp3\"&gt; &lt;!-- 网络授权 --&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:networkSecurityConfig=\"@xml/network_security_config\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 简单的界面设计&emsp;&emsp;activity_main.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/h30\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.3\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/v50\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.5\" /&gt; &lt;TextView android:id=\"@+id/tv_info\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;Button android:id=\"@+id/bt_test_GET_Syn\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:text=\"测试GET同步无参\" app:layout_constraintEnd_toStartOf=\"@+id/v50\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;Button android:id=\"@+id/bt_test_GET_ASyn\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:text=\"测试GET异步无参\" app:layout_constraintEnd_toStartOf=\"@+id/v50\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@+id/bt_test_GET_Syn\" /&gt; &lt;Button android:id=\"@+id/bt_test_GET_ASyn2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:text=\"测试GET异步有参\" app:layout_constraintEnd_toStartOf=\"@+id/v50\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@+id/bt_test_GET_ASyn\" /&gt; &lt;Button android:id=\"@+id/bt_test_POST_ASyn\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:text=\"测试POST异步\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/v50\" app:layout_constraintTop_toTopOf=\"parent\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; GET和POST测试&emsp;&emsp;MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; // 不能用本地的127.0.0.1，需要用实际的IP地址 String url = \"http://10.22.82.219:8080/\"; private TextView tvInfo; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //隐藏状态栏 View decorView = getWindow().getDecorView(); decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); getWindow().setStatusBarColor(Color.TRANSPARENT); setContentView(R.layout.activity_main); // 初始化控件 Button btTestGETSyn = findViewById(R.id.bt_test_GET_Syn); btTestGETSyn.setOnClickListener(this); Button btTestGETASyn = findViewById(R.id.bt_test_GET_ASyn); btTestGETASyn.setOnClickListener(this); Button btTestGETASyn2 = findViewById(R.id.bt_test_GET_ASyn2); btTestGETASyn2.setOnClickListener(this); Button btTestPOSTASyn = findViewById(R.id.bt_test_POST_ASyn); btTestPOSTASyn.setOnClickListener(this); tvInfo = findViewById(R.id.tv_info); &#125; @Override public void onClick(View view) &#123; switch (view.getId())&#123; case R.id.bt_test_GET_Syn: testGETSyn(); break; case R.id.bt_test_GET_ASyn: testGETASyn(); break; case R.id.bt_test_GET_ASyn2: testGETASyn2(); break; case R.id.bt_test_POST_ASyn: testPOSTASyn(); break; &#125; &#125; // 测试GET同步方法 private void testGETSyn() &#123; OkHttpClient okHttpClient = new OkHttpClient(); final Request request = new Request.Builder() .url(url + \"doctor-user/listAll\") .get() //默认就是GET请求，可以不写 .build(); final Call call = okHttpClient.newCall(request); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Response response = call.execute(); final String info = response.body().string(); // 主线程更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; tvInfo.setText(info); &#125; &#125;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; // 测试GET异步方法（无参） private void testGETASyn() &#123; OkHttpClient okHttpClient = new OkHttpClient(); final Request request = new Request.Builder() .url(url + \"doctor-user/listAll\") .get() .build(); Call call = okHttpClient.newCall(request); call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; // 主线程更新UI runOnUiThread(new Runnable() &#123; @SuppressLint(\"SetTextI18n\") @Override public void run() &#123; tvInfo.setText(\"Error\"); &#125; &#125;); &#125; @Override public void onResponse(Call call, final Response response) throws IOException &#123; final String info = response.body().string(); // 主线程更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; tvInfo.setText(info); &#125; &#125;); &#125; &#125;); &#125; // 测试GET异步方法（有参） private void testGETASyn2() &#123; String requestBody = \"10001\"; OkHttpClient okHttpClient = new OkHttpClient(); final Request request = new Request.Builder() .url(url + \"doctor-user/get/byEmployeeId/\" + requestBody) .get() .build(); okHttpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; // 主线程更新UI runOnUiThread(new Runnable() &#123; @SuppressLint(\"SetTextI18n\") @Override public void run() &#123; tvInfo.setText(\"Error\"); &#125; &#125;); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; try &#123; // 数据解析 String info = response.body().string(); JSONObject jsonObject = null; jsonObject = new JSONObject(info); final String data = jsonObject.get(\"data\").toString(); // 主线程更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; tvInfo.setText(data); &#125; &#125;); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; // 测试异步POST private void testPOSTASyn()&#123; OkHttpClient okHttpClient = new OkHttpClient(); RequestBody requestBody = new FormBody.Builder() .add(\"name\", \"陈修翔\") .add(\"gender\", \"男\") .build(); Request request = new Request.Builder() .url(url + \"doctor-user/update/byName\") .post(requestBody) .build(); okHttpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; // 主线程更新UI runOnUiThread(new Runnable() &#123; @SuppressLint(\"SetTextI18n\") @Override public void run() &#123; tvInfo.setText(\"Error\"); &#125; &#125;); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; try &#123; // 数据解析 String info = response.body().string(); System.out.println(info); JSONObject jsonObject = null; jsonObject = new JSONObject(info); final String data = jsonObject.get(\"message\").toString(); // 主线程更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; tvInfo.setText(data); &#125; &#125;); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; &emsp;&emsp;注：这里异步POST测试没有调通！ 参考博客Android Okhttp3基本使用 Retrofit+RxJavaRetrofit简介&emsp;&emsp;Retrofit是现下Android端开发非常流行的一款网络请求框架，它通过动态代理的方式将Java接口翻译成网络请求，通过OkHttp发送请求，并且其具备强大的可扩展性，支持各种数据格式的转换以及RxJava。&emsp;&emsp;网络请求框架是一套提供给开发者使用的用于网络请求的API接口，Android网络请求一般是基于Http协议的，而Http协议属于应用层的协议，具体的数据传输需要依赖传输层的TCP协议，Android系统提供了Socket编程接口给开发者建立TCP请求，所以具体数据的发送需要依赖Socket；Http协议属于应用层的协议，它是用来规定数据的传输格式的，用于传输双方都能按照固定的格式解读数据；所以，一个网络请求框架至少要包含以下几个功能： 提供接口给开发者传入请求参数； 编写Socket代码，建立TCP； 通过TCP连接，严格按照Http协议的格式将请求参数发送给服务端； 严格按照Http协议的格式解读服务端返回的数据； 提供相应的接口给开发者获得返回数据（一般是通过回调处理的）。 &emsp;&emsp;上面五点是一个网络请求框架必须具备的功能，当然，一个好的网络请求框架还应该具备如下特点： 提供给开发者使用的API尽可能简单； 添加了对网络缓存的处理，避免不必要的请求； 具有较高的性能； 具有较高的可扩展性。 &emsp;&emsp;我们常用的OkHttp、HttpURLConnection等网络请求框架，其内部就会将开发者传入的请求参数按照Http协议的格式组织好，并通过TCP连接发送给服务端，在收到服务端返回数据后，又会按照Http协议去解读数据，并提供相应的API（一般是回调）给开发者获得数据。由于OkHttp属于比较底层的网络请求框架，开发者在使用时还是会比较复杂，于是Retrofit对OkHttp进行了再度的封装，使得开发者在使用时更加的方便。 &emsp;&emsp;App应用程序通过Retrofit请求网络，实际上是使用Retrofit接口层封装请求参数，之后由OkHttp完成后续的请求操作。在服务端返回数据之后，OkHttp将原始的结果交给Retrofit，Retrofit根据用户的需求对结果进行解析。完成数据的转化(converterFactory)，适配(callAdapterFactory)，通过设计模式进行各种扩展。 使用Retrofit的七步骤 添加Retrofit依赖，网络权限 定义接收服务器返回数据的Bean 创建网络请求的接口，使用注解(动态代理，核心) builder模式创建Retrofit实例，converter，calladapter… 创建接口实例，调用具体的网络请求 call同步/异步网络请求 处理服务器返回的数据 Retrofit网络通信八步骤 创建Retrofit实例 定义网络请求接口，并为接口中的方法添加注解 通过动态代理生成网络请求对象 通过网络请求适配器将网络请求对象进行平台适配 通过网络请求执行器，发送网络请求(call) 通过数据解析器解析数据 通过回调执行器，切换线程 用户在主线程处理返回结果 依赖配置&emsp;&emsp;build.gradle添加依赖：1234567//请求网络implementation 'com.squareup.retrofit2:retrofit:2.8.1'implementation 'com.squareup.retrofit2:converter-gson:2.8.1'implementation 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0'//RxJavaimplementation 'io.reactivex.rxjava2:rxjava:2.0.1'implementation 'io.reactivex.rxjava2:rxandroid:2.0.1' 网络配置&emsp;&emsp;参考上文Okhttp3网络配置。 GET和POST测试实体类DoctorInfo.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130public class DoctorInfo &#123; private Long id; private String name; private String gender; private int age; private String job; private String department; private int employeeId; private String cardId; private String fingerId; private String password; // 不能用date，要用String！否则会Json解析错误！ private String updateTime; private String createTime; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public String getDepartment() &#123; return department; &#125; public void setDepartment(String department) &#123; this.department = department; &#125; public int getEmployeeId() &#123; return employeeId; &#125; public void setEmployeeId(int employeeId) &#123; this.employeeId = employeeId; &#125; public String getCardId() &#123; return cardId; &#125; public void setCardId(String cardId) &#123; this.cardId = cardId; &#125; public String getFingerId() &#123; return fingerId; &#125; public void setFingerId(String fingerId) &#123; this.fingerId = fingerId; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUpdateTime() &#123; return updateTime; &#125; public void setUpdateTime(String updateTime) &#123; this.updateTime = updateTime; &#125; public String getCreateTime() &#123; return createTime; &#125; public void setCreateTime(String createTime) &#123; this.createTime = createTime; &#125; // 需要重写toString()! @Override public String toString() &#123; return \"DoctorInfo&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", gender='\" + gender + '\\'' + \", age=\" + age + \", job='\" + job + '\\'' + \", department='\" + department + '\\'' + \", employeeId=\" + employeeId + \", cardId='\" + cardId + '\\'' + \", fingerId='\" + fingerId + '\\'' + \", password='\" + password + '\\'' + \", updateTime='\" + updateTime + '\\'' + \", createTime='\" + createTime + '\\'' + '&#125;'; &#125;&#125; DoctorData.java12345678910111213141516171819public class DoctorData&#123; // 要和后端字段保持一致！ private List&lt;DoctorInfo&gt; doctorUserList; public List&lt;DoctorInfo&gt; getDoctorUserList() &#123; return doctorUserList; &#125; public void setDoctorUserList(List&lt;DoctorInfo&gt; doctorUserList) &#123; this.doctorUserList = doctorUserList; &#125; @Override public String toString() &#123; return \"DoctorData&#123;\" + \"doctorUserList=\" + doctorUserList + '&#125;'; &#125;&#125; DoctorResponse.java123456789101112131415161718192021222324252627282930313233343536373839public class DoctorResponse &#123; private boolean success; private int code; private String message; // 要和后端字段保持一致！ private DoctorData data; public boolean isSuccess() &#123; return success; &#125; public void setSuccess(boolean success) &#123; this.success = success; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public DoctorData getData() &#123; return data; &#125; public void setData(DoctorData data) &#123; this.data = data; &#125;&#125; &emsp;&emsp;注1：所有字段必须要和后端字段保持一致！&emsp;&emsp;注2：需要重写实体类的toString()方法。&emsp;&emsp;注3：Date类型的字段要用String类型替换！否则会Json解析错误。 网络工具类SeerService.java12345678910111213141516public interface SeerService &#123; // 步骤1：创建 用于描述网络请求 的接口 // 注解里传入 网络请求 的部分URL地址 // Retrofit把网络请求的URL分成了两部分：一部分放在Retrofit对象里，另一部分放在网络请求接口里 // 如果接口里的url是一个完整的网址，那么放在Retrofit对象里的URL可以忽略 // 采用Observable&lt;...&gt;接口 // getAllDoctorInfo()是接受网络请求数据的方法 @GET(\"doctor-user/listAll\") Observable&lt;DoctorResponse&gt; getAllDoctorInfo(); @GET(\"doctor-user/get/byEmployeeId/&#123;employee_id&#125;\") Observable&lt;DoctorResponse&gt; getDoctorInfoByEmployeeId(@Path(\"employee_id\") Integer employeeId); @POST(\"/doctor-user/update/byName\") Observable&lt;DoctorResponse&gt; updateDoctorInfoByDoctorName(@Body DoctorInfo doctorInfo);&#125; SeerServiceCreator.java123456789101112131415161718192021222324252627282930// 写成单例类，避免重复创建，浪费资源public class SeerServiceCreator &#123; private static SeerServiceCreator instance; private Retrofit retrofit; private SeerServiceCreator()&#123; retrofit = new Retrofit.Builder() .baseUrl(Constant.SEER_SERVER_IP) // 设置 网络请求 Url .addConverterFactory(GsonConverterFactory.create()) //设置使用Gson解析 .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) // 支持RxJava .build(); &#125; // 双检锁/双重校验锁 public static SeerServiceCreator getInstance()&#123; if (instance == null) &#123; synchronized (SeerServiceCreator.class)&#123; if (instance == null) &#123; instance = new SeerServiceCreator(); &#125; &#125; &#125; return instance; &#125; public &lt;T&gt; T create(Class&lt;T&gt; tClass) &#123; return retrofit.create(tClass); &#125;&#125; MainActivity实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private TextView tvInfo; // 步骤2：创建Retrofit对象 SeerServiceCreator seerServiceCreator = SeerServiceCreator.getInstance(); // 步骤3：创建 网络请求接口 的实例 SeerService seerService = seerServiceCreator.create(SeerService.class); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //隐藏状态栏 View decorView = getWindow().getDecorView(); decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); getWindow().setStatusBarColor(Color.TRANSPARENT); setContentView(R.layout.activity_main); // 初始化控件 Button btTestGETASyn = findViewById(R.id.bt_test_GET_ASyn); btTestGETASyn.setOnClickListener(this); Button btTestGETASyn2 = findViewById(R.id.bt_test_GET_ASyn2); btTestGETASyn2.setOnClickListener(this); Button btTestPOSTASyn = findViewById(R.id.bt_test_POST_ASyn); btTestPOSTASyn.setOnClickListener(this); tvInfo = findViewById(R.id.tv_info); &#125; @Override public void onClick(View view) &#123; switch (view.getId())&#123; case R.id.bt_test_GET_ASyn: testGETASyn(); break; case R.id.bt_test_GET_ASyn2: testGETASyn2(); break; case R.id.bt_test_POST_ASyn: testPOSTASyn(); break; &#125; &#125; private void testGETASyn() &#123; // 步骤4：采用Observable&lt;...&gt;形式 对 网络请求 进行封装 Observable&lt;DoctorResponse&gt; observable = seerService.getAllDoctorInfo(); // 步骤5：发送网络请求 observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;DoctorResponse&gt;() &#123; @Override public void accept(DoctorResponse doctorResponse) throws Exception &#123; final List&lt;DoctorInfo&gt; doctorUserList = doctorResponse.getData().getDoctorUserList(); // 主线程更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; tvInfo.setText(doctorUserList.toString()); &#125; &#125;); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; // 主线程更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; tvInfo.setText(\"Error\"); &#125; &#125;); &#125; &#125;); &#125; private void testGETASyn2() &#123; // 步骤4：采用Observable&lt;...&gt;形式 对 网络请求 进行封装 Observable&lt;DoctorResponse&gt; observable = seerService.getDoctorInfoByEmployeeId(10001); // 步骤5：发送网络请求 observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;DoctorResponse&gt;() &#123; @Override public void accept(DoctorResponse doctorResponse) throws Exception &#123; final List&lt;DoctorInfo&gt; doctorUserList = doctorResponse.getData().getDoctorUserList(); // 主线程更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; tvInfo.setText(doctorUserList.toString()); &#125; &#125;); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; // 主线程更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; tvInfo.setText(\"Error2\"); &#125; &#125;); &#125; &#125;); &#125; private void testPOSTASyn() &#123; // 步骤4：采用Observable&lt;...&gt;形式 对 网络请求 进行封装 DoctorInfo doctorInfo = new DoctorInfo(); doctorInfo.setName(\"陈修翔\"); doctorInfo.setAge(28); doctorInfo.setEmployeeId(10001); Observable&lt;DoctorResponse&gt; observable = seerService.updateDoctorInfoByDoctorName(doctorInfo); // 步骤5：发送网络请求 observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;DoctorResponse&gt;() &#123; @Override public void accept(DoctorResponse doctorResponse) throws Exception &#123; final String message = doctorResponse.getMessage(); // 主线程更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; tvInfo.setText(message); &#125; &#125;); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; // 主线程更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; tvInfo.setText(\"Error3\"); &#125; &#125;); &#125; &#125;); &#125;&#125; &emsp;&emsp;这里只是简单的逻辑测试，不能当成业务代码处理。 参考博客Android：Retrofit 与 RxJava联合使用大合集Retrofit原理分析Retrofit分析面试总结","categories":[{"name":"Web开发与应用","slug":"Web开发与应用","permalink":"http://cxx0822.github.io/categories/Web开发与应用/"}],"tags":[]},{"title":"基于仙工底盘的Web前后端及APP开发","slug":"基于仙工底盘的Web前后端及APP开发","date":"2021-06-22T04:19:55.000Z","updated":"2022-03-21T06:19:12.915Z","comments":true,"path":"2021/06/22/ji-yu-xian-gong-di-pan-de-web-qian-hou-duan-ji-app-kai-fa/","link":"","permalink":"http://cxx0822.github.io/2021/06/22/ji-yu-xian-gong-di-pan-de-web-qian-hou-duan-ji-app-kai-fa/","excerpt":"","text":"平台&emsp;&emsp;仙工AMB系列无人搬运底盘&emsp;&emsp;Windows 10&emsp;&emsp;IntelliJ IDEA&emsp;&emsp;Android Studio 整体框架&emsp;&emsp;首先底盘控制器和Web后端通过TCP协议进行数据交互，所有的逻辑处理均在Web后端中实现，所有产生的交互数据均通过JDBC驱动连接存储在数据库中。&emsp;&emsp;通过S Web后端和Web前端采用Ajax技术实现 仙工AMR底盘TCP通讯数据协议简介&emsp;&emsp;仙工官方文档&emsp;&emsp;该TCP协议的API请求由头部和数据区组成，因此该请求方式可以分为两种，一种是有请求数据的，一种是没有请求数据的。 没有请求数据&emsp;&emsp;此时数据区为0，请求数据的区别只在于报文类型的不同(这里的数据区长度字段为0)，因此只需在官网查询相应API的报文类型即可。例如，第三章的机器人状态API中的查询机器人信息：&emsp;&emsp;这里只需将报文类型字段更改为请求编号03E8即可，其余按默认值处理。 有请求数据&emsp;&emsp;由该例可见，首先需要将JSON对象序列字符串转换为十六进制，然后计算其长度作为数据区长度字段的数值。注意这里的长度是按字节计算，需要除以2(请求示例中，转换为十六进制后数据的字符个数为56，但长度为28)。 TCP通讯端口协议简介&emsp;&emsp;这部分原理比较简单，按照官网提示即可。 基于Socket协议的TCP通讯实现Socket原理基于仙工底盘TCP API接口的Java编程实现新建工程文件&emsp;&emsp;首先打开IntelliJ IDEA创建Web后端工程，选择Spring Initializr：&emsp;&emsp;然后更改相应的Group和Artifact，Java Version选择8。&emsp;&emsp;这里的依赖库可以先选择不安装，后续在pom.xml配置文件中统一安装。&emsp;&emsp;注：如果出现pom.xml配置文件错误：系统找不到文件路径，打开设置文件中的Maven选项检查相应的文件是否正确。 添加依赖文件&emsp;&emsp;在pom.xml依赖管理文件中添加json依赖，并添加依赖版本管理：12345678910111213141516&lt;!--json--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;$&#123;json.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;$&#123;gson.version&#125;&lt;/version&gt;&lt;/dependency&gt; &emsp;&emsp;依赖版本管理，这里部分依赖版本后续会依次添加。12345678910111213141516171819202122232425&lt;!-- 依赖版本管理 --&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mybatis-plus.version&gt;3.3.1&lt;/mybatis-plus.version&gt; &lt;velocity.version&gt;2.0&lt;/velocity.version&gt; &lt;swagger.version&gt;2.9.2&lt;/swagger.version&gt; &lt;aliyun.oss.version&gt;3.1.0&lt;/aliyun.oss.version&gt; &lt;jodatime.version&gt;2.10.1&lt;/jodatime.version&gt; &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt; &lt;commons-io.version&gt;2.6&lt;/commons-io.version&gt; &lt;commons-lang.version&gt;3.9&lt;/commons-lang.version&gt; &lt;httpclient.version&gt;4.5.1&lt;/httpclient.version&gt; &lt;jwt.version&gt;0.7.0&lt;/jwt.version&gt; &lt;aliyun-java-sdk-core.version&gt;4.3.3&lt;/aliyun-java-sdk-core.version&gt; &lt;aliyun-java-sdk-vod.version&gt;2.15.2&lt;/aliyun-java-sdk-vod.version&gt; &lt;aliyun-sdk-vod-upload.version&gt;1.4.11&lt;/aliyun-sdk-vod-upload.version&gt; &lt;fastjson.version&gt;1.2.28&lt;/fastjson.version&gt; &lt;gson.version&gt;2.8.2&lt;/gson.version&gt; &lt;json.version&gt;20170516&lt;/json.version&gt; &lt;commons-dbutils.version&gt;1.7&lt;/commons-dbutils.version&gt; &lt;canal.client.version&gt;1.1.0&lt;/canal.client.version&gt; &lt;docker.image.prefix&gt;zx&lt;/docker.image.prefix&gt; &lt;alibaba.easyexcel.version&gt;2.1.1&lt;/alibaba.easyexcel.version&gt; &lt;apache.xmlbeans.version&gt;3.1.0&lt;/apache.xmlbeans.version&gt; &lt;/properties&gt; 实现Socket工具类&emsp;&emsp;在main-&gt;java-&gt;com.njtech.seerwebrobot文件夹下新建包service-&gt;utils，并在包下面新建SocketUtils.java和StringUtils.java文件。&emsp;&emsp;在main-&gt;java-&gt;com.njtech.seerwebrobot文件夹下新建包service-&gt;constant，并在包下面新建Constant.java、RobotControlAPIConst、RobotStatusAPIConst和RobotTaskAPIConst.java文件。用来存储仙工底盘TCP API接口中的常量。&emsp;&emsp;Constant.java12345678910111213141516171819public interface Constant &#123; // 机器人有线IP // String robotIP = \"192.168.192.5\"; // 机器人AMR无线IP String robotIP = \"192.168.3.99\"; // 机器人状态API端口号 Integer robotStatusPort = 19204; // 机器人控制API端口号 Integer robotControlPort = 19205; // 机器人导航API端口号 Integer robotTaskPort = 19206; // 机器人配置API端口号 Integer robotConfigPort = 19207; // 头部数据区 String apiHeader = \"5A 01 00 01\"; // 保留区 String apiRetain = \"00 00 00 00 00 00\";&#125; &emsp;&emsp;RobotControlAPIConst.java1234public interface RobotControlAPIConst &#123; // 确定定位正确 String robotControlConfirmLoc = \"5A 01 00 01 00 00 00 00 07 D3 00 00 00 00 00 00\";&#125; &emsp;&emsp;RobotStatusAPIConst.java1234567891011121314public interface RobotStatusAPIConst &#123; // 查询机器人信息 String robotStatusAllInfo = \"5A 01 00 01 00 00 00 00 03 E8 00 00 00 00 00 00\"; // 查询机器人运行信息 String robotStatusRunInfo = \"5A 01 00 01 00 00 00 00 03 EA 00 00 00 00 00 00\"; // 查询机器人电池状态 String robotStatusBatteryInfo = \"5A 01 00 01 00 00 00 00 03 EF 00 00 00 00 00 00\"; // 查询机器人位置信息 String robotStatusLocationInfo = \"5A 01 00 01 00 00 00 00 03 EC 00 00 00 00 00 00\"; // 查询机器人I/O数据 String robotStatusIoInfo = \"5A 01 00 01 00 00 00 00 03 F5 00 00 00 00 00 00\"; // 查询机器人急停状态 String robotStatusEmergencyInfo = \"5A 01 00 01 00 00 00 00 03 F4 00 00 00 00 00 00 \";&#125; &emsp;&emsp;RobotTaskAPIConst.java12345678910111213public interface RobotTaskAPIConst &#123; // 路径导航 String robotTaskGotarget = \"0BEB\"; // 暂停当前导航 String robotTaskPause = \"5A 01 00 01 00 00 00 00 0B B9 00 00 00 00 00 00\"; // 继续当前导航 String robotTaskResume = \"5A 01 00 01 00 00 00 00 0B BA 00 00 00 00 00 00\"; // 取消当前导航 String robotTaskCancel = \"5A 01 00 01 00 00 00 00 0B BB 00 00 00 00 00 00\";&#125; &emsp;&emsp;注：这里只列举了部分TCP接口中的数据。&emsp;&emsp;StringUtils.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class StringUtils &#123; /** * 将十六进制的字符串转换成字节数组 * * @param hexString * @return */ public static byte[] hexStringToByteArray(String hexString) &#123; hexString = hexString.replaceAll(\" \", \"\"); int len = hexString.length(); byte[] bytes = new byte[len / 2]; for (int i = 0; i &lt; len; i += 2) &#123; // 两位一组，表示一个字节,把这样表示的16进制字符串，还原成一个字节 bytes[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) &lt;&lt; 4) + Character .digit(hexString.charAt(i + 1), 16)); &#125; return bytes; &#125; /** * 字符串转化成为16进制字符串 * @param s * @return */ public static String strTo16(String s) &#123; String str = \"\"; for (int i = 0; i &lt; s.length(); i++) &#123; int ch = (int) s.charAt(i); String s4 = Integer.toHexString(ch); str = str + s4; &#125; return str; &#125; /** * 将两个byte数组合并为一个 * @param data1 要合并的数组1 * @param data2 要合并的数组2 * @return 合并后的新数组 */ public static byte[] mergeBytes(byte[] data1, byte[] data2) &#123; byte[] data3 = new byte[data1.length + data2.length]; System.arraycopy(data1, 0, data3, 0, data1.length); System.arraycopy(data2, 0, data3, data1.length, data2.length); return data3; &#125; /** * 截取字符串str中指定字符 strStart、strEnd之间的字符串 * * @param str 原始字符串 * @param strStart 开始 * @param strEnd 结束 * @return 截取后的 */ public static String subString(String str, String strStart, String strEnd) &#123; /* 找出指定的2个字符在 该字符串里面的 位置 */ int strStartIndex = str.indexOf(strStart); int strEndIndex = str.indexOf(strEnd); /* index 为负数 即表示该字符串中 没有该字符 */ if (strStartIndex &lt; 0) &#123; return \"字符串 :----&gt;\" + str + \"&lt;---- 中不存在 \" + strStart + \", 无法截取目标字符串\"; &#125; if (strEndIndex &lt; 0) &#123; return \"字符串 :----&gt;\" + str + \"&lt;---- 中不存在 \" + strEnd + \", 无法截取目标字符串\"; &#125; /* 开始截取 */ String result = str.substring(strStartIndex, strEndIndex).substring(strStart.length()); return result; &#125;&#125; &emsp;&emsp;SocketUtils.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public class SocketUtils &#123; // 发送TCP报文数据，无数据区域 public static JSONObject sendTCPInfo(String robotIP, Integer robotAPIPort, String sendTCPData)&#123; JSONObject jsonInfo = new JSONObject(); try &#123; // 创建socket，指定服务区地址和端口号 // Socket socket = new Socket(Constant.robotIP, apiPort); Socket socket = new Socket(); SocketAddress socketAddress = new InetSocketAddress(robotIP, robotAPIPort); // 设置连接时间 socket.connect(socketAddress, 100); // 获取输出流,向服务器发送信息 OutputStream os = socket.getOutputStream(); byte[] bytes = StringUtils.hexStringToByteArray(sendTCPData); os.write(bytes); os.flush(); socket.shutdownOutput();//关闭输出流 //获取输入流，读取服务器的响应信息 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); // 原始数据 String rawInfo = br.readLine(); // System.out.println(\"原始数据: \" + rawInfo); // 截取 引号 之前字符串 需要截取的字符中间不要加空格！ String subInfo = rawInfo.substring(0, rawInfo.indexOf(\"\\\"\")); // System.out.println(\"截取 &#123; 之前的数据: \" + subInfo); // 重新构造的数据 String newInfo = null; // 去掉 引号 之前的数据 重新构造数据 newInfo = rawInfo.substring(subInfo.length()); // System.out.println(\"新的数据: \" + newInfo); jsonInfo = JSONObject.parseObject(\"&#123;\" + newInfo); jsonInfo.put(\"msg\", \"noError\"); // 关闭资源 br.close(); is.close(); os.close(); socket.close(); &#125; catch (SocketTimeoutException | SocketException s)&#123; jsonInfo.put(\"msg\", \"networkError\"); &#125; catch (Exception e) &#123; jsonInfo.put(\"msg\", \"otherError\"); e.printStackTrace(); &#125; return jsonInfo; &#125; // 发送TCP报文数据，有数据区域 public static JSONObject sendTCPInfo(String robotIP, Integer robotAPIPort, String sendTCPData, String apiType)&#123; JSONObject jsonInfo = new JSONObject(); try &#123; // 创建socket，指定服务区地址和端口号 // Socket socket = new Socket(Constant.robotIP, robotAPIPort); Socket socket = new Socket(); SocketAddress socketAddress = new InetSocketAddress(robotIP, robotAPIPort); // 设置连接时间 socket.connect(socketAddress, 100); // 获取输出流,向服务器发送信息 OutputStream os = socket.getOutputStream(); byte[] totalBytes = sendInfo(Constant.apiHeader, sendTCPData, apiType, Constant.apiRetain); os.write(totalBytes); os.flush(); socket.shutdownOutput();//关闭输出流 // 获取输入流，读取服务器的响应信息 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String rawInfo = br.readLine(); // System.out.println(\"原始字符串: \" + rawInfo); // 截取 引号 之前字符串 需要截取的字符中间不要加空格！ String subInfo = rawInfo.substring(0, rawInfo.indexOf(\"\\\"\")); // System.out.println(\"截取 &#123; 之前的数据: \" + subInfo); // 重新构造的数据 String newInfo = null; // 去掉 引号 之前的数据 重新构造数据 newInfo = rawInfo.substring(subInfo.length()); // System.out.println(\"新的数据: \" + newInfo); jsonInfo = JSONObject.parseObject(\"&#123;\" + newInfo); jsonInfo.put(\"msg\", \"noError\"); //关闭资源 br.close(); is.close(); os.close(); socket.close(); &#125; catch (SocketTimeoutException | SocketException s)&#123; jsonInfo.put(\"msg\", \"networkError\"); &#125; catch (Exception e) &#123; jsonInfo.put(\"msg\", \"otherError\"); e.printStackTrace(); &#125; return jsonInfo; &#125; // 发送数据 public static byte[] sendInfo(String header, String data, String type, String retain)&#123; // 头部数据区 byte[] headerBytes = StringUtils.hexStringToByteArray(header); // 数据区 String data16 = StringUtils.strTo16(data); byte[] dataBytes = StringUtils.hexStringToByteArray(data16); // 数据区长度 需要除以2且数据长度为8位 String dataLength = String.format(\"%08x\", data16.length() / 2); byte[] dataLengthBytes = StringUtils.hexStringToByteArray(dataLength); // 报文类型 byte[] typeBytes = StringUtils.hexStringToByteArray(type); // 保留区 byte[] retainBytes = StringUtils.hexStringToByteArray(retain); byte[] totalBytes = StringUtils.mergeBytes(headerBytes, dataLengthBytes); totalBytes = StringUtils.mergeBytes(totalBytes, typeBytes); totalBytes = StringUtils.mergeBytes(totalBytes, retainBytes); totalBytes = StringUtils.mergeBytes(totalBytes, dataBytes); return totalBytes; &#125;&#125; &emsp;&emsp;由上述分析可知，一共分为两种情况，因此定义2个函数分别处理没有请求数据的和有请求数据的，两者只在发送数据处不同，其他均相似。&emsp;&emsp;首先创建一个JSONObject类型的变量用来处理接收到的json类型的数据。&emsp;&emsp;然后使用SocketAddress socketAddress = new InetSocketAddress(robotIP, robotAPIPort)创建TCP连接。这里可以通过设置连接时间防止TCP网络未正确连接时，服务器长时间等待的情况(如果在连接时间内未正常连接，则会抛出SocketTimeoutException异常)。&emsp;&emsp;这里最重要的一行代码就是byte[] bytes = StringUtils.hexStringToByteArray(sendTCPData)，即将字符串转为字节数组。如果使用字符串作为发送数据，仙工底盘的控制器是无法正确解析的！&emsp;&emsp;然后通过String rawInfo = br.readLine();接收控制器返回的数据。&emsp;&emsp;最后通过字符串操作和JSONObject对象操作将原始数据处理为所需的json对象。&emsp;&emsp;注：这里使用了msg字段来处理各种TCP通讯情况。&emsp;&emsp;针对有请求数据的情况，根据上文的原理分析，首先需要利用StringUtils.strTo16()将发送区数据转为十六进制数据，然后计算数据区长度并除以2，即data16.length() / 2，最后因为数据区长度的字段规定长度为8位，利用String.format()统一长度。 测试Socke连接查询信息&emsp;&emsp;在test文件目录中的SeerwebrobotApplicationTests文件夹下新建测试类：12345678910111213141516@Testvoid testGetInfo()&#123; JSONObject robotRawInfo; // String robotIP = \"192.168.192.5\"; String robotIP = \"192.168.3.99\"; robotRawInfo = SocketUtils.sendTCPInfo(robotIP, Constant.robotStatusPort, RobotStatusAPIConst.robotStatusAllInfo); String robotRawInfoStr = JSON.toJSONString(robotRawInfo, SerializerFeature.PrettyFormat, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteDateUseDateFormat); System.out.println(robotRawInfoStr); // System.out.println(robotRawInfo);&#125; &emsp;&emsp;这里直接调用SocketUtils工具类中的sendTCPInfo()函数，其中robotIP为实际的底盘IP地址，其余2个参数为常量中的相应数据，最后将其格式化JSON输出。 发送信息&emsp;&emsp;这里测试其导航功能，从A点到B点。123456789101112131415161718@Testvoid testSendInfo()&#123; JSONObject jsonSendTCPData = new JSONObject(); jsonSendTCPData.put(\"source_id\", \"LM1\"); jsonSendTCPData.put(\"id\", \"LM6\"); jsonSendTCPData.put(\"task_id\", \"87654321\"); String sendTCPData = JSONObject.toJSONString(jsonSendTCPData); JSONObject robotRawInfo = SocketUtils.sendTCPInfo(Constant.robotIP, Constant.robotTaskPort, sendTCPData, RobotTaskAPIConst.robotTaskGotarget); String robotRawInfoStr = JSON.toJSONString(robotRawInfo, SerializerFeature.PrettyFormat, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteDateUseDateFormat); System.out.println(robotRawInfoStr);&#125; &emsp;&emsp;相比较有数据的发送信息，即查询信息，只需要新建一个JSONObject对象的数据，并按照官网的说明文档将数据依次添加进去即可。 Web后端框架搭建平台&emsp;&emsp;Spring Boot&emsp;&emsp;MySql 数据库配置&emsp;&emsp;首先配置好本地数据库系统MySql 8，按照数据库软件Navicat(也可以是其他任意一个)建立数据表。&emsp;&emsp;这里以机器人信息和机器人任务表作为案例展示，需要其他表格可以按相同操作添加。&emsp;&emsp;根据仙工官网提供的API返回值信息建立数据表： &emsp;&emsp;这里只采用了部分字段建立数据表，其中id、create_time和update_time为数据表必需字段。 Spring Boot后端框架搭建基本配置文件添加依赖&emsp;&emsp;首先在pom.xml添加依赖：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Web 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql JDBC驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus 持久层--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;$&#123;velocity.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger ui--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--json--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;$&#123;json.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;$&#123;gson.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 后端框架配置&emsp;&emsp;然后需要对整个后端框架进行一个基本的配置设置。&emsp;&emsp;在main-&gt;java-&gt;com.njtech.seerwebrobot-&gt;service包下面新建base包，并在base包下面新建config包和handler包，分别处理基本配置和数据库自动填充功能。然后在config包下面新建MyConfig.java和MybaticPlusConfig.java，在handler包下面新建CommonMetaObjectHandler.java文件，最终base包的文件目录如下(后面2个java文件后续会介绍)：&emsp;&emsp;MyConfig.java1234567891011121314151617181920212223242526272829@Configuration@EnableSwagger2public class MyConfig &#123; //配置swagger2核心配置docket //修改默认配置bean @Bean public Docket myDocket()&#123; return new Docket(DocumentationType.SWAGGER_2) //指定API类型为swagger2 .apiInfo(apiInfo()) //用于定于api文档汇总信息 .select() .apis(RequestHandlerSelectors .basePackage(\"com.njtech.seerwebrobot.service.controller\")) //指定controller包 .paths(PathSelectors.any()) // 所有controller .build(); &#125; private ApiInfo apiInfo()&#123; return new ApiInfoBuilder() .title(\"医疗服务机器人\") // 文档页标题 .contact(new Contact(\"Cxx\", // 联系人信息 \"www.baidu.com\", \"@email\")) .description(\"南京工业大学\") // 详细信息 .version(\"1.0.1\") // 文档版本号 .termsOfServiceUrl(\"www.baidu.com\") //网站地址 .build(); &#125;&#125; &emsp;&emsp;这里主要是一个swagger UI的ApiInfo的信息配置和basePackage的包扫描功能。这里需要扫描的包主要为controller包下面的文件。 application.yml文件配置1234567891011121314151617181920#server:# port: 8080 # 服务端口spring: profiles: active: dev # 环境设置 application: name: ruikedaqi # 服务名 datasource: # mysql数据库连接 driver-class-name: com.mysql.cj.jdbc.Driver #url: jdbc:mysql://192.168.2.222:3306/ruikedaqi?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8 url: jdbc:mysql://localhost:3306/seer?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8 #utf-8编码 &amp;useUnicode=true&amp;characterEncoding=UTF-8 username: root password: root #返回json的全局时间格式 #spring: jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss 统一返回值信息&emsp;&emsp;返回值信息主要包括4个方面：是否成功、返回码、返回消息和返回数据，具体定义为：1234private Boolean success private Integer code private String message private Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;() &emsp;&emsp;在service包下面新建result包，并新建R.java和ResultCodeEnum.java分别定义返回结果和返回码、返回消息。&emsp;&emsp;R.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899@Data@ApiModel(value = \"全局统一返回结果\")public class R &#123; @ApiModelProperty(value = \"是否成功\") private Boolean success; @ApiModelProperty(value = \"返回码\") private Integer code; @ApiModelProperty(value = \"返回消息\") private String message; @ApiModelProperty(value = \"返回数据\") private Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;(); public R()&#123;&#125; public static R ok()&#123; R r = new R(); r.setSuccess(ResultCodeEnum.SUCCESS.getSuccess()); r.setCode(ResultCodeEnum.SUCCESS.getCode()); r.setMessage(ResultCodeEnum.SUCCESS.getMessage()); return r; &#125; public static R error()&#123; R r = new R(); r.setSuccess(ResultCodeEnum.UNKNOWN_REASON.getSuccess()); r.setCode(ResultCodeEnum.UNKNOWN_REASON.getCode()); r.setMessage(ResultCodeEnum.UNKNOWN_REASON.getMessage()); return r; &#125; public static R setResult(ResultCodeEnum resultCodeEnum)&#123; R r = new R(); r.setSuccess(resultCodeEnum.getSuccess()); r.setCode(resultCodeEnum.getCode()); r.setMessage(resultCodeEnum.getMessage()); return r; &#125; public R success(Boolean success)&#123; this.setSuccess(success); return this; &#125; public R message(String message)&#123; this.setMessage(message); return this; &#125; public Boolean getSuccess() &#123; return success; &#125; public void setSuccess(Boolean success) &#123; this.success = success; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public Map&lt;String, Object&gt; getData() &#123; return data; &#125; public void setData(Map&lt;String, Object&gt; data) &#123; this.data = data; &#125; public R code(Integer code)&#123; this.setCode(code); return this; &#125; public R data(String key, Object value)&#123; this.data.put(key, value); return this; &#125; public R data(Map&lt;String, Object&gt; map)&#123; this.setData(map); return this; &#125;&#125; &emsp;&emsp;ResultCodeEnum.java12345678910111213141516171819202122232425262728293031323334353637383940414243@Getter@ToStringpublic enum ResultCodeEnum &#123; SUCCESS(true, 20000,\"成功\"), UNKNOWN_REASON(false, 20001, \"未知错误\"), private Boolean success; private Integer code; private String message; public Boolean getSuccess() &#123; return success; &#125; public void setSuccess(Boolean success) &#123; this.success = success; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; ResultCodeEnum(Boolean success, Integer code, String message) &#123; this.success = success; this.code = code; this.message = message; &#125;&#125; &emsp;&emsp;这里主要调用ok()和error()方法，当然也可以定义其他的静态方法，在函数体内设置好setSuccess()、setCode()和setMessage()即可。ResultCodeEnum为枚举类，在里面可以定义各种信息提示，这里只简单列举了成功和未知错误的信息定义。&emsp;&emsp;使用方法如下：123R.ok().message(\"注册成功\"); R.error().message(\"注册失败\"); R.ok().data(\"robotInfoList\", robotInfoList); 其他插件配置&emsp;&emsp;MybaticPlusConfig.java12345678910111213@EnableTransactionManagement@Configuration@MapperScan(\"com.njtech.seerwebrobot.service.mapper\")public class MybatisPlusConfig &#123; /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125;&#125; &emsp;&emsp;这里也主要是一个包扫描和分页插件的配置。&emsp;&emsp;CommonMetaObjectHandler.java1234567891011121314151617@Slf4j@Componentpublic class CommonMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; //log.info(\"start insert fill ....\"); this.setFieldValByName(\"createTime\", new Date(), metaObject); this.setFieldValByName(\"updateTime\", new Date(), metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; //log.info(\"start update fill ....\"); this.setFieldValByName(\"updateTime\", new Date(), metaObject); &#125;&#125; &emsp;&emsp;这里主要是配置数据库自动填充功能。 自动生成代码框架&emsp;&emsp;这里使用MyBatis-Plus的代码生成器，通过 AutoGenerator可以快速生成Entity、Mapper、Mapper XML、Service、Controller等各个模块的代码。&emsp;&emsp;Entity为实体类，存放基本的数据定义，Mapper为数据库操作，Service为后端主要逻辑实现，Controller主要提供前端界面的接口。&emsp;&emsp;在test目录下面新建CodeGenerator.java文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class CodeGenerator &#123; @Test public void genCode() &#123; // 执行时 需要删除之前生成的 com包 String prefix = \"seer\"; // 数据表的名字 //String moduleName = \"edu\"; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 // 生成文件的路径 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath + \"/src/main/java\"); gc.setAuthor(\"Cxx\"); gc.setOpen(false); //生成后是否打开资源管理器 gc.setFileOverride(true); //重新生成时文件是否覆盖 gc.setServiceName(\"%sService\"); //去掉Service接口的首字母I gc.setIdType(IdType.ASSIGN_ID); //主键策略 gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型 gc.setSwagger2(true);//开启Swagger2模式 mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); //dsc.setUrl(\"jdbc:mysql://localhost:3306/\" + prefix + \"guli_\" + moduleName + \"?serverTimezone=GMT%2B8\"); dsc.setUrl(\"jdbc:mysql://localhost:3306/\" + prefix + \"?serverTimezone=GMT%2B8\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"root\"); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); //pc.setModuleName(moduleName); //模块名 pc.setParent(\"com.njtech.seerwebrobot.service\"); pc.setController(\"controller\"); pc.setEntity(\"entity\"); pc.setService(\"service\"); pc.setMapper(\"mapper\"); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略 //strategy.setTablePrefix(moduleName + \"_\");//设置表前缀不生成 strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略 strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作 //strategy.setLogicDeleteFieldName(\"is_deleted\");//逻辑删除字段名 //strategy.setEntityBooleanColumnRemoveIsPrefix(true);//去掉布尔值的is_前缀 //自动填充 TableFill createTime = new TableFill(\"create_time\", FieldFill.INSERT); TableFill updateTime = new TableFill(\"update_time\", FieldFill.INSERT_UPDATE); ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(createTime); tableFills.add(updateTime); strategy.setTableFillList(tableFills); // controller控制层 换成restcontroller 即返回值都是Json格式的 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125;&#125; &emsp;&emsp;首先更改第一行代码中的数据表的名字，然后在数据源配置中，更改数据库的用户名和密码，其次在包配置中，更改setParent()中的包名，最后运行该文件即可自动生成相应的模块代码。&emsp;&emsp;最终完整的Web工程文件夹目录结构如下： Spring Boot后端框架实现&emsp;&emsp;Web后端框架的逻辑均在service包中实现，与前端交互的数据均在controller包中实现。 &emsp;&emsp;注：这里只展示了２个基本的底盘控制器操作，后续如需添加其他功能，只需按照新建数据表(部分功能可省略此步骤)-&gt;重新自动生成代码(这里可以将自动生成代码的setFileOverride()函数的参数改为false，即不替换之前的内容)-&gt;在service中编写具体的后端逻辑-&gt;在controller编写具体的前端交互逻辑。 Service包实现&emsp;&emsp;这里以实现机器人控制器的查询信息和导航任务为例，一个是接收TCP数据，一个是发送TCP数据。 RobotInfoService&emsp;&emsp;在RobotInfoService.java新建2个函数：12345public interface RobotInfoService extends IService&lt;RobotInfo&gt; &#123; RobotInfo getRobotInfo(String robotIp); int updateRobotInfo(RobotInfo robotInfo);&#125; &emsp;&emsp;然后在RobotInfoServiceImpl.java编写具体的逻辑实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Servicepublic class RobotInfoServiceImpl extends ServiceImpl&lt;RobotInfoMapper, RobotInfo&gt; implements RobotInfoService &#123; @Autowired private RobotInfoMapper robotInfoMapper; @Override public RobotInfo getRobotInfo(String robotIP)&#123; JSONObject robotRawInfo; RobotInfo robotInfo = new RobotInfo(); robotRawInfo = SocketUtils.sendTCPInfo(robotIP, Constant.robotStatusPort, RobotStatusAPIConst.robotStatusAllInfo); if(robotRawInfo.get(\"msg\").equals(\"noError\"))&#123; robotInfo.setRobotId(robotRawInfo.get(\"id\").toString()); robotInfo.setVehicleId(robotRawInfo.get(\"vehicle_id\").toString()); robotInfo.setRobotNote(robotRawInfo.get(\"robot_note\").toString()); robotInfo.setCurrentMap(robotRawInfo.get(\"current_map\").toString()); robotInfo.setSsid(robotRawInfo.get(\"ssid\").toString()); robotInfo.setRssi(Double.valueOf(robotRawInfo.get(\"rssi\").toString())); robotInfo.setCurrentIp(robotRawInfo.get(\"current_ip\").toString()); &#125; else &#123; robotInfo.setSsid(\"None\"); &#125; return robotInfo; &#125; @Override public int updateRobotInfo(RobotInfo robotInfo) &#123; RobotInfo newRobotInfo = new RobotInfo(); newRobotInfo.setRobotId(robotInfo.getRobotId()); newRobotInfo.setVehicleId(robotInfo.getVehicleId()); newRobotInfo.setRobotNote(robotInfo.getRobotNote()); newRobotInfo.setCurrentMap(robotInfo.getCurrentMap()); newRobotInfo.setSsid(robotInfo.getSsid()); newRobotInfo.setRssi(robotInfo.getRssi()); newRobotInfo.setCurrentIp(robotInfo.getCurrentIp()); //修改条件 UpdateWrapper&lt;RobotInfo&gt; robotInfoUpdateWrapper = new UpdateWrapper&lt;&gt;(); robotInfoUpdateWrapper .eq(\"current_ip\", robotInfo.getCurrentIp()); return robotInfoMapper.update(newRobotInfo, robotInfoUpdateWrapper); &#125;&#125; &emsp;&emsp;这里需要先定义一个RobotInfoMapper，在RobotInfoMapper.java文件名中添加注解@Repository。 RobotTaskService&emsp;&emsp;同理，实现RobotTaskService的功能模块：&emsp;&emsp;RobotTaskService.java123public interface RobotTaskService extends IService&lt;RobotTask&gt; &#123; JSONObject addRobotTask(String robotIp, String sourceId, String desId, String taskId);&#125; &emsp;&emsp;RobotTaskServiceImpl.java12345678910111213141516171819@Servicepublic class RobotTaskServiceImpl extends ServiceImpl&lt;RobotTaskMapper, RobotTask&gt; implements RobotTaskService &#123; @Autowired private RobotTaskMapper robotTaskMapper; @Override public JSONObject addRobotTask(String robotIp, String sourceId, String desId, String taskId)&#123; JSONObject jsonSendTCPData = new JSONObject(); jsonSendTCPData.put(\"source_id\", sourceId); jsonSendTCPData.put(\"id\", desId); jsonSendTCPData.put(\"task_id\", taskId); String sendTCPData = JSONObject.toJSONString(jsonSendTCPData); JSONObject robotInfo = SocketUtils.sendTCPInfo(robotIp, Constant.robotTaskPort, sendTCPData, RobotTaskAPIConst.robotTaskGotarget); return robotInfo; &#125;&#125; Controller包实现&emsp;&emsp;然后分别实现机器人信息查询和下达任务的后端接口：&emsp;&emsp;RobotInfoController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@RestController@RequestMapping(\"/robot-info\")public class RobotInfoController &#123; @Autowired private RobotInfoService robotInfoService; @Autowired private RobotInfoMapper robotInfoMapper; @ApiOperation(\"所有机器人列表\") @GetMapping(\"listAll\") public R listAll()&#123; List&lt;RobotInfo&gt; robotInfoList = robotInfoService.list(); return R.ok().data(\"robotInfoList\", robotInfoList); &#125; @ApiOperation(\"注册机器人信息\") @PostMapping(\"register\") public R register(@ApiParam(value = \"机器人id和Ip\", required = true) @RequestBody RobotInfo robotInfo)&#123; String robotId = robotInfo.getRobotId(); String currentIp = robotInfo.getCurrentIp(); if(robotId == null || robotId.length() == 0 || currentIp == null || currentIp.length() == 0)&#123; return R.error().message(\"请输入机器人Id和Ip\"); &#125; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"robot_id\", robotId); List&lt;RobotInfo&gt; robotInfoList = robotInfoMapper.selectByMap(map); if(robotInfoList.size() != 0)&#123; return R.error().message(\"机器人已存在\"); &#125;else&#123; boolean result = robotInfoService.save(robotInfo); if (result) &#123; return R.ok().message(\"注册成功\"); &#125; else &#123; return R.error().message(\"注册失败\"); &#125; &#125; &#125; @ApiOperation(\"更新机器人信息\") @PostMapping(\"update/byRobotIp\") public R updateByRobotIp(@ApiParam(value = \"机器人信息\", required = true) @RequestBody RobotInfo robotInfo)&#123; int result = robotInfoService.updateRobotInfo(robotInfo); if(result != 0)&#123; return R.ok().message(\"修改成功\"); &#125;else&#123; return R.error().message(\"数据不存在\"); &#125; &#125;&#125; &emsp;&emsp;这里主要是一些Mybatic Plus与数据库之间的联系。&emsp;&emsp;RobotTaskController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@RestController@RequestMapping(\"/robot-task\")public class RobotTaskController &#123; @Autowired private RobotTaskService robotTaskService; @Autowired private RobotTaskMapper robotTaskMapper; @ApiOperation(\"下达任务\") @PostMapping(\"addTask\") public R addTask(@ApiParam(value = \"任务指令\", required = true) @RequestBody RobotTask robotTask)&#123; String robotIp = robotTask.getRobotIp(); String sourceId = robotTask.getSourceId(); String desId = robotTask.getDesId(); String taskId = robotTask.getTaskId(); if(robotIp == null || robotIp.length() == 0 || sourceId == null || sourceId.length() == 0 || desId == null || desId.length() == 0 || taskId == null || taskId.length() == 0)&#123; return R.error().message(\"请输入正确的任务指令！\"); &#125; JSONObject robotInfo = robotTaskService.addRobotTask(robotIp, sourceId, desId, taskId); if(robotInfo.get(\"msg\") == \"networkError\") &#123; return R.error().message(\"下达任务失败，请检查网络连接！\"); &#125;else &#123; if (robotInfo.get(\"msg\") == \"noError\") &#123; boolean result = robotTaskService.save(robotTask); if (result) &#123; return R.ok().message(\"下达任务成功，添加数据库成功！\"); &#125; else &#123; return R.error().message(\"下达任务成功，添加数据库失败！\"); &#125; &#125;else &#123; return R.error().message(\"任务下达失败，TCP通讯失败！\"); &#125; &#125; &#125; @ApiOperation(\"暂停当前导航\") @GetMapping(\"pause/&#123;robot_ip&#125;\") public R pause(@ApiParam(value = \"机器人Ip\", required = true) @PathVariable String robot_ip) &#123; JSONObject robotInfo = SocketUtils.sendTCPInfo(robot_ip, Constant.robotTaskPort, RobotTaskAPIConst.robotTaskPause); if (robotInfo.get(\"msg\") == \"networkError\") &#123; return R.error().message(\"下达任务失败，请检查网络连接！\"); &#125; else &#123; return R.ok().message(\"下达任务成功！\"); &#125; &#125; @ApiOperation(\"继续当前导航\") @GetMapping(\"resume/&#123;robot_ip&#125;\") public R resume(@ApiParam(value = \"机器人Ip\", required = true) @PathVariable String robot_ip) &#123; JSONObject robotInfo = SocketUtils.sendTCPInfo(robot_ip, Constant.robotTaskPort, RobotTaskAPIConst.robotTaskResume); if (robotInfo.get(\"msg\") == \"networkError\") &#123; return R.error().message(\"下达任务失败，请检查网络连接！\"); &#125; else &#123; return R.ok().message(\"下达任务成功！\"); &#125; &#125; @ApiOperation(\"取消当前导航\") @GetMapping(\"cancel/&#123;robot_ip&#125;\") public R cancel(@ApiParam(value = \"机器人Ip\", required = true) @PathVariable String robot_ip) &#123; JSONObject robotInfo = SocketUtils.sendTCPInfo(robot_ip, Constant.robotTaskPort, RobotTaskAPIConst.robotTaskCancel); if (robotInfo.get(\"msg\") == \"networkError\") &#123; return R.error().message(\"下达任务失败，请检查网络连接！\"); &#125; else &#123; return R.ok().message(\"下达任务成功！\"); &#125; &#125;&#125; Swagger UI本地测试&emsp;&emsp;运行启动类SeerwebrobotApplication.java，并打开浏览器输入Swagger UI本地测试网址：http://127.0.0.1:8080/swagger-ui.html#/：&emsp;&emsp;这里只对robot-task-controller-&gt;addTask接口进行简单的测试：&emsp;&emsp;输入以上内容，并执行，可以看到机器人可以正确导航，并返回正确的信息。 简易实时调度功能实现&emsp;&emsp;主要实现自动更新机器人状态信息和自动充电功能。 医疗运输机器人客户端APP实现(基于retrofit协议)&emsp;&emsp;基于Web后端提供的TCP接口，根据retrofit协议进行数据交互。 基本配置新建工程&emsp;&emsp;打开Android Studio，新建工程： 配置文件&emsp;&emsp;打开build.gradle，在android{}中将minSdkVersion设置为21，然后指定编译Java文件的JDK版本：12345// 指定编译Java文件的JDK版本 compileOptions &#123; targetCompatibility JavaVersion.VERSION_1_8 sourceCompatibility JavaVersion.VERSION_1_8 &#125; &emsp;&emsp;在dependencies依赖管理中添加依赖：123456789//屏幕适配implementation 'me.jessyan:autosize:0.9.5'//请求网络implementation 'com.squareup.retrofit2:retrofit:2.8.1'implementation 'com.squareup.retrofit2:converter-gson:2.8.1'implementation 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0'//RxJavaimplementation 'io.reactivex.rxjava2:rxjava:2.0.1'implementation 'io.reactivex.rxjava2:rxandroid:2.0.1' &emsp;&emsp;打开AndroidManifest.xml文件，添加网络授权：12&lt;!-- 网络授权 --&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &emsp;&emsp;在res文件夹下新建文件夹xml，并新建文件network_security_config.xml：1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=\"true\" /&gt;&lt;/network-security-config&gt; 项目目录结构&emsp;&emsp;整个APP目录结构分为java和res两个文件夹，其中java文件夹主要处理APP中的逻辑部分，res主要为资源文件，处理APP的界面显示部分。&emsp;&emsp;在java文件夹下，为了提高代码的可读性，新建logic和ui2个文件，分别处理与界面无关的逻辑和与界面有关的逻辑部分，具体目录结构如下： retrofit2简介https://blog.csdn.net/xiao_nian/article/details/87802483 欢迎界面设置设计理论&emsp;&emsp;整体风格分为两栏，左侧为医院背景，右侧为文字介绍+功能按钮，点击下达任务可以进入登录界面，输入正确的职工信息，即可进入具体的任务界面。&emsp;&emsp;其中圆弧形分割线为自定义的View，需要在java文件夹中添加具体实现。 界面实现&emsp;&emsp;这里主要有2个界面，即欢迎界面和登录界面，其中登录界面对对话框形式。&emsp;&emsp;activity_main.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".ui.activity.MainActivity\"&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/v60\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.60\"/&gt; &lt;com.njtech.seerwebrobot.ui.view.BackGroundView android:id=\"@+id/backGroundView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; &lt;ImageView android:layout_width=\"300dp\" android:layout_height=\"300dp\" android:scaleType=\"fitCenter\" android:src=\"@drawable/control\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@+id/v60\" app:layout_constraintStart_toStartOf=\"@+id/backGroundView\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;ImageView android:id=\"@+id/img_welcome\" android:layout_width=\"285dp\" android:layout_height=\"120dp\" android:layout_marginTop=\"10dp\" android:scaleType=\"fitCenter\" android:src=\"@drawable/welcome\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/v60\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;TextView android:id=\"@+id/tv_welcome\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:gravity=\"center\" android:text=\"欢迎使用\" android:textColor=\"@color/colorBlack\" android:textSize=\"30sp\" android:textStyle=\"bold\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/v60\" app:layout_constraintTop_toBottomOf=\"@+id/img_welcome\" /&gt; &lt;TextView android:id=\"@+id/tv_company_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"15dp\" android:gravity=\"center\" android:text=\"医疗服务机器人\" android:textColor=\"@color/colorBlack\" android:textSize=\"25sp\" android:textStyle=\"bold\" app:layout_constraintEnd_toEndOf=\"@+id/backGroundView\" app:layout_constraintStart_toStartOf=\"@+id/v60\" app:layout_constraintTop_toBottomOf=\"@+id/tv_welcome\" /&gt; &lt;Button android:id=\"@+id/bt_add_task\" android:layout_width=\"170dp\" android:layout_height=\"60dp\" android:layout_marginBottom=\"15dp\" android:background=\"@drawable/shape_blue_corner\" android:text=\"下达任务\" android:textColor=\"@color/colorWhite\" android:textSize=\"30sp\" app:layout_constraintBottom_toTopOf=\"@+id/img_logo\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.53\" app:layout_constraintStart_toStartOf=\"@+id/v60\" /&gt; &lt;ImageView android:id=\"@+id/img_logo\" android:layout_width=\"150dp\" android:layout_height=\"60dp\" android:scaleType=\"centerCrop\" android:src=\"@drawable/logo\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &emsp;&emsp;dialog_identity.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:clipChildren=\"false\"&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/h7\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.07\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/v6\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.06\" /&gt; &lt;ImageView android:id=\"@+id/bg_dialog\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:scaleType=\"fitXY\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.0\" app:layout_constraintStart_toStartOf=\"@+id/v6\" app:layout_constraintTop_toTopOf=\"@+id/h7\" app:layout_constraintVertical_bias=\"0.0\" app:srcCompat=\"@drawable/bg_dialog\" /&gt; &lt;TextView android:id=\"@+id/tv_identity_title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:gravity=\"center\" android:text=\"职 工 登 录\" android:textColor=\"#304877\" android:textSize=\"35sp\" app:layout_constraintBottom_toTopOf=\"@+id/h30\" app:layout_constraintEnd_toStartOf=\"@+id/v90\" app:layout_constraintStart_toStartOf=\"@+id/v30\" app:layout_constraintTop_toTopOf=\"@+id/h7\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/h30\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.3\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/h50\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.5\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/h70\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.7\" /&gt; &lt;TextView android:id=\"@+id/tv_identity_number\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"工号:\" android:textColor=\"@color/colorBlack\" android:textSize=\"30sp\" app:layout_constraintBottom_toTopOf=\"@+id/h50\" app:layout_constraintStart_toStartOf=\"@+id/v30\" app:layout_constraintTop_toTopOf=\"@+id/h30\" /&gt; &lt;TextView android:id=\"@+id/tv_identity_password\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"密码:\" android:textColor=\"@color/colorBlack\" android:textSize=\"30sp\" app:layout_constraintBottom_toTopOf=\"@+id/h70\" app:layout_constraintStart_toStartOf=\"@+id/tv_identity_number\" app:layout_constraintTop_toTopOf=\"@+id/h50\" /&gt; &lt;EditText android:id=\"@+id/et_identity_doctorNumber\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"20dp\" android:layout_marginLeft=\"20dp\" android:layout_marginTop=\"8dp\" android:layout_marginBottom=\"8dp\" android:background=\"@color/colorWhite\" android:gravity=\"center\" android:lines=\"1\" android:singleLine=\"true\" android:textSize=\"30sp\" android:hint=\"请输入工号\" app:layout_constraintBottom_toTopOf=\"@+id/h50\" app:layout_constraintEnd_toStartOf=\"@+id/v90\" app:layout_constraintStart_toEndOf=\"@+id/tv_identity_number\" app:layout_constraintTop_toTopOf=\"@+id/h30\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/v90\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.9\" /&gt; &lt;EditText android:id=\"@+id/et_identity_doctorPassword\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"20dp\" android:layout_marginLeft=\"20dp\" android:layout_marginTop=\"8dp\" android:layout_marginBottom=\"8dp\" android:background=\"@color/colorWhite\" android:gravity=\"center\" android:inputType=\"textPassword\" android:lines=\"1\" android:singleLine=\"true\" android:textSize=\"30sp\" android:hint=\"请输入密码\" app:layout_constraintBottom_toTopOf=\"@+id/h70\" app:layout_constraintEnd_toStartOf=\"@+id/v90\" app:layout_constraintStart_toEndOf=\"@+id/tv_identity_password\" app:layout_constraintTop_toTopOf=\"@+id/h50\" /&gt; &lt;Button android:id=\"@+id/bt_identity_confirm\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/bg_bt_blue\" android:text=\"确 定\" android:textColor=\"@color/colorWhite\" android:textSize=\"35sp\" app:layout_constraintBottom_toTopOf=\"@+id/h90\" app:layout_constraintEnd_toStartOf=\"@+id/v60\" app:layout_constraintStart_toStartOf=\"@+id/v30\" app:layout_constraintTop_toTopOf=\"@+id/h70\" /&gt; &lt;Button android:id=\"@+id/bt_identity_cancel\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/bg_bt_blue\" android:text=\"取 消\" android:textColor=\"@color/colorWhite\" android:textSize=\"35sp\" app:layout_constraintBottom_toTopOf=\"@+id/h90\" app:layout_constraintEnd_toStartOf=\"@+id/v90\" app:layout_constraintHorizontal_bias=\"0.495\" app:layout_constraintStart_toStartOf=\"@+id/v60\" app:layout_constraintTop_toTopOf=\"@+id/h70\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/v30\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.3\" /&gt; &lt;ImageView android:id=\"@+id/iv_identity_doctor\" android:layout_width=\"150dp\" android:layout_height=\"150dp\" app:layout_constraintBottom_toTopOf=\"@+id/h50\" app:layout_constraintEnd_toStartOf=\"@+id/v30\" app:layout_constraintStart_toStartOf=\"@+id/v6\" app:layout_constraintTop_toTopOf=\"@+id/h7\" app:srcCompat=\"@drawable/doctor\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/v60\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.6\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/h90\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.9\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/h13\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.13\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 界面逻辑功能实现&emsp;&emsp;在ui-&gt;view文件夹下新建自定义分割线View：BackGroundView1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 蓝白背景view */public class BackGroundView extends View &#123; private Paint mPaint; private Path mPath; public BackGroundView(Context context) &#123; super(context); init(); &#125; public BackGroundView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public BackGroundView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init()&#123; mPath = new Path(); mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); drawBackGround(canvas); &#125; /** * 画背景 * @param canvas */ private void drawBackGround(Canvas canvas)&#123; mPaint.setColor(Color.BLUE); mPath.reset(); mPath.lineTo((float) getWidth()*1/2, 0); mPath.quadTo((float) getWidth()*5/7, (float) getHeight()/2, (float) getWidth()*1/2, getHeight()); mPath.lineTo(0, getHeight()); mPath.close(); canvas.drawPath(mPath, mPaint); &#125;&#125; &emsp;&emsp;对话框逻辑实现：IdentityDialog.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class IdentityDialog extends Dialog implements CustomAdapt, View.OnClickListener &#123; private Context context; // 上下文 private int layoutResID; // 布局文件id private int[] listenedItem; // 监听的控件id public IdentityDialog(Context context, int layoutResID, int[] listenedItem)&#123; super(context, R.style.IdentityDialog);//加载dialog的样式 this.context = context; this.layoutResID = layoutResID; this.listenedItem = listenedItem; &#125; private EditText etDoctorNumber; private EditText etDoctorPassword; private String doctorTruePassword; // 实际医生密码 @Override protected void onCreate(Bundle savedInstanceState)&#123; //提前设置Dialog的一些样式 Window dialogWindow = getWindow(); dialogWindow.setGravity(Gravity.CENTER);//设置dialog显示居中 //dialogWindow.setWindowAnimations();设置动画效果 setContentView(layoutResID); WindowManager windowManager = ((Activity)context).getWindowManager(); Display display = windowManager.getDefaultDisplay(); WindowManager.LayoutParams lp = getWindow().getAttributes(); lp.width = display.getWidth()*3/4;// 设置dialog宽度为屏幕的4/5 lp.height = display.getHeight()*3/4;// 设置dialog高度为屏幕的4/5 getWindow().setAttributes(lp); setCanceledOnTouchOutside(false);//点击外部Dialog消失 //给所有控件添加点击监听器 for(int id:listenedItem)&#123; findViewById(id).setOnClickListener(this); &#125; // 输入的工号 etDoctorNumber = findViewById(R.id.et_identity_doctorNumber); // 输入的密码 etDoctorPassword = findViewById(R.id.et_identity_doctorPassword); &#125; @Override public void onClick(View view)&#123; switch (view.getId())&#123; case R.id.bt_identity_confirm: dismiss(); checkIdentity(); break; case R.id.bt_identity_cancel: Toast.makeText(context, \"取消登录！\", Toast.LENGTH_SHORT).show(); dismiss(); break; &#125; &#125; /* * 身份验证 * */ public void checkIdentity()&#123; checkPassword(etDoctorNumber.getText().toString(), etDoctorPassword.getText().toString()); &#125; /** * 密码验证 * @param doctorNumber 工号 * @param doctorPassword 密码 */ private void checkPassword(String doctorNumber, String doctorPassword) &#123; if(doctorNumber.isEmpty() || doctorPassword.isEmpty())&#123; Toast.makeText(context, \"请输入工号和密码！\", Toast.LENGTH_SHORT).show(); &#125;else &#123; if (doctorNumber.equals(\"admin\")) &#123; // 管理员密码密码匹配 if (doctorPassword.equals(\"admin\"))&#123; // Intent intent = new Intent(context, TaskActivity.class); // 传入工号参数 // intent.putExtra(\"num\", 10001); /// context.startActivity(intent); Toast.makeText(context, \"登录成功！\", Toast.LENGTH_SHORT).show(); &#125;else&#123; Toast.makeText(context, \"密码错误！\", Toast.LENGTH_SHORT).show(); &#125; &#125; else &#123; Toast.makeText(context, \"登录成功！\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; /** * 屏幕适配 */ @Override public boolean isBaseOnWidth() &#123; return false; &#125; @Override public float getSizeInDp() &#123; return 375; &#125;&#125; &emsp;&emsp;添加对话框时，需要在res-&gt;values-&gt;styles.xml中添加对话框属性：123456789101112131415&lt;!-- 显示个人信息对话框样式 --&gt;&lt;style name=\"IdentityDialog\" parent=\"android:Theme.Dialog\"&gt; &lt;!-- 背景颜色及透明程度 --&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparent&lt;/item&gt; &lt;!-- 是否半透明 --&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;false&lt;/item&gt; &lt;!-- 是否没有标题 --&gt; &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt; &lt;!-- 是否浮现在activity之上 --&gt; &lt;item name=\"android:windowIsFloating\"&gt;true&lt;/item&gt; &lt;!-- 是否背景模糊 --&gt; &lt;item name=\"android:backgroundDimEnabled\"&gt;false&lt;/item&gt; &lt;!-- 设置背景模糊的透明度--&gt; &lt;item name=\"android:backgroundDimAmount\"&gt;0.5&lt;/item&gt;&lt;/style&gt; &emsp;&emsp;欢迎界面逻辑实现：MainActivity.java：123456789101112131415161718192021222324252627282930313233343536373839404142public class MainActivity extends AppCompatActivity implements CustomAdapt, View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //隐藏状态栏 View decorView = getWindow().getDecorView(); decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); getWindow().setStatusBarColor(Color.TRANSPARENT); setContentView(R.layout.activity_main); // 新增任务按钮 Button btAddTask = findViewById(R.id.bt_add_task); btAddTask.setOnClickListener(this); &#125; @Override public void onClick(View view)&#123; if (view.getId() == R.id.bt_add_task) &#123; // 跳转到自定义身份验证对话框 IdentityDialog identityDialog = new IdentityDialog(MainActivity.this, R.layout.dialog_identity, new int[]&#123;R.id.bt_identity_confirm, R.id.bt_identity_cancel&#125;); identityDialog.show(); &#125; &#125; /** * 屏幕适配 */ @Override public boolean isBaseOnWidth() &#123; return false; &#125; @Override public float getSizeInDp() &#123; return 375; &#125;&#125; 选择机器人界面设置设计理念&emsp;&emsp;整体风格同欢迎界面，左侧为医生信息显示，右侧为机器人信息显示。&emsp;&emsp;其中机器人信息为ListView，通过自定义设计适配器显示机器人的图标、名字、电量和状态信息。&emsp;&emsp;点击相应的机器人信息即可切换到下达任务界面。 界面实现&emsp;&emsp;新建空Activity，实现activity_task.xml：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".ui.activity.TaskActivity\"&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/v60\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.6\"/&gt; &lt;com.njtech.seerwebrobot.ui.view.BackGroundView android:id=\"@+id/backGroundView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_editor_absoluteX=\"16dp\" app:layout_editor_absoluteY=\"30dp\"/&gt; &lt;ImageView android:id=\"@+id/img_back\" android:layout_width=\"30dp\" android:layout_height=\"30dp\" android:layout_marginStart=\"15dp\" android:layout_marginTop=\"15dp\" android:background=\"@drawable/back\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;ImageView android:id=\"@+id/img_doctor\" android:layout_width=\"180dp\" android:layout_height=\"180dp\" android:layout_marginTop=\"30dp\" android:src=\"@drawable/svg_doctor\" app:layout_constraintEnd_toStartOf=\"@+id/v60\" app:layout_constraintHorizontal_bias=\"0.11\" app:layout_constraintStart_toStartOf=\"@+id/backGroundView\" app:layout_constraintTop_toBottomOf=\"@+id/tv_welcome\" /&gt; &lt;TextView android:id=\"@+id/tv_task_doctorName\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"150dp\" android:text=\"姓名：张三\" android:textColor=\"@color/colorWhite\" android:textSize=\"20sp\" app:layout_constraintEnd_toStartOf=\"@+id/v60\" app:layout_constraintHorizontal_bias=\"0.28\" app:layout_constraintStart_toEndOf=\"@+id/img_doctor\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;TextView android:id=\"@+id/tv_task_doctorNumber\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"25dp\" android:textColor=\"@color/colorWhite\" android:textSize=\"20sp\" android:text=\"工号：123456\" app:layout_constraintStart_toStartOf=\"@+id/tv_task_doctorName\" app:layout_constraintTop_toBottomOf=\"@+id/tv_task_doctorName\" /&gt; &lt;TextView android:id=\"@+id/tv_task_doctorJob\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"25dp\" android:textSize=\"20sp\" android:textColor=\"@color/colorWhite\" android:text=\"职位：主治医生\" app:layout_constraintStart_toStartOf=\"@+id/tv_task_doctorName\" app:layout_constraintTop_toBottomOf=\"@+id/tv_task_doctorNumber\" /&gt; &lt;TextView android:id=\"@+id/tv_available\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"30dp\" android:gravity=\"center\" android:text=\"机器人列表\" android:textColor=\"@color/colorBlack\" android:textSize=\"30sp\" android:textStyle=\"bold\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/v60\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;ListView android:background=\"@drawable/shape_gray_corner\" android:id=\"@+id/lv_RobotInfo\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:layout_marginStart=\"20dp\" android:layout_marginTop=\"10dp\" android:layout_marginEnd=\"20dp\" app:layout_constraintBottom_toTopOf=\"@+id/img_logo\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/v60\" app:layout_constraintTop_toBottomOf=\"@+id/tv_available\" /&gt; &lt;ImageView android:id=\"@+id/img_logo\" android:layout_width=\"150dp\" android:layout_height=\"60dp\" android:scaleType=\"centerCrop\" android:src=\"@drawable/logo\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" /&gt; &lt;TextView android:id=\"@+id/tv_welcome\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"50dp\" android:gravity=\"center\" android:text=\"欢迎使用!\" android:textColor=\"@color/colorWhite\" android:textSize=\"35sp\" android:textStyle=\"bold\" app:layout_constraintEnd_toStartOf=\"@+id/v60\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 适配器RobotInfoAdapter&emsp;&emsp;处理一些比较复杂的数据显示。需要提供界面设计和界面逻辑功能实现。&emsp;&emsp;界面实现adapter_robot_item.xml:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"80dp\"&gt; &lt;ImageView android:id=\"@+id/img_robot\" android:layout_width=\"40dp\" android:layout_height=\"40dp\" android:layout_gravity=\"center_vertical\" android:layout_marginLeft=\"30dp\"/&gt; &lt;LinearLayout android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_marginLeft=\"20dp\" android:layout_weight=\"1\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/tv_robot_name\" android:layout_width=\"wrap_content\" android:layout_height=\"30dp\" android:layout_gravity=\"center_vertical\" android:textSize=\"17sp\" android:textColor=\"@color/colorWhite\" android:gravity=\"center\" /&gt; &lt;TextView android:id=\"@+id/tv_robot_power\" android:layout_width=\"wrap_content\" android:layout_height=\"0dp\" android:textColor=\"@color/colorWhite\" android:textSize=\"13sp\" android:layout_weight=\"1\"/&gt; &lt;TextView android:id=\"@+id/tv_robot_status\" android:layout_width=\"wrap_content\" android:layout_height=\"0dp\" android:textColor=\"@color/colorWhite\" android:textSize=\"13sp\" android:layout_weight=\"1\"/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; &emsp;&emsp;逻辑功能实现RobotInfoAdapter.java：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * 机器人listView适配器 */public class RobotInfoAdapter extends ArrayAdapter&lt;RobotInfo&gt; &#123; private int resourceId; private ImageView robotImage; private TextView tvRobotName; private TextView tvRobotPower; private TextView tvRobotStatus; // 房间名称映射 不能传入中文，暂时用这个方法 HashMap&lt;String, String&gt; nameMap = new HashMap&lt;&gt;(); private String startPoint; private String startName; private String endPoint; private String endName; private String targetName; private String currentOrderStatus = \"ERROR\"; // 构造函数 需要activity,layout和list数据 public RobotInfoAdapter(Context context, int resourceId, List&lt;RobotInfo&gt; objects) &#123; super(context, resourceId, objects); this.resourceId = resourceId; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); // 获取当前机器人信息 RobotInfo robotInfo = getItem(position); initView(view); setRobotName(robotInfo.getRobotName()); setRobotBatteryLevel(robotInfo.getRobotBatteryLevel()); setRobotTaskStatus(robotInfo.getRobotTaskStatus(), robotInfo.getRobotEmergencyStatus()); return view; &#125; // 初始化控件信息 private void initView(View view) &#123; robotImage = view.findViewById(R.id.img_robot); tvRobotName = view.findViewById(R.id.tv_robot_name); tvRobotPower = view.findViewById(R.id.tv_robot_power); tvRobotStatus = view.findViewById(R.id.tv_robot_status); nameMap.put(\"101\", \"门诊\"); nameMap.put(\"102\", \"病房\"); nameMap.put(\"103\", \"护士站\"); nameMap.put(\"201\", \"门诊\"); nameMap.put(\"202\", \"病房\"); nameMap.put(\"203\", \"护士站\"); &#125; // 设置机器人名字 @SuppressLint(\"SetTextI18n\") private void setRobotName(String robotName) &#123; switch (robotName)&#123; case \"AMB-01\": tvRobotName.setText(\"小南001号\"); break; case \"AMB-02\": tvRobotName.setText(\"小南002号\"); break; default: tvRobotName.setText(\"暂无登记！\"); break; &#125; &#125; // 设置机器人电量 @SuppressLint(\"SetTextI18n\") private void setRobotBatteryLevel(Double robotBatteryLevel) &#123; tvRobotPower.setText(\"电量：\" + robotBatteryLevel * 100 + \"%\"); &#125; // 设置机器人任务状态 private void setRobotTaskStatus(Integer robotTaskStatus, Boolean robotEmergencyStatus) &#123; if (robotEmergencyStatus)&#123; tvRobotStatus.setText(\"状态： 异常\"); robotImage.setImageResource(R.drawable.redagv); &#125; else&#123; switch (robotTaskStatus)&#123; case -1: tvRobotStatus.setText(\"状态：离线\"); robotImage.setImageResource(R.drawable.redagv); break; case 0: tvRobotStatus.setText(\"状态： 正在休息\"); robotImage.setImageResource(R.drawable.blueagv); break; case 2: tvRobotStatus.setText(\"状态： 正在运行\"); robotImage.setImageResource(R.drawable.greenagv); break; case 3: tvRobotStatus.setText(\"状态： 任务暂停\"); robotImage.setImageResource(R.drawable.redagv); break; case 4: tvRobotStatus.setText(\"状态： 任务完成\"); robotImage.setImageResource(R.drawable.blueagv); break; case 5: tvRobotStatus.setText(\"状态： 任务失败\"); robotImage.setImageResource(R.drawable.redagv); break; case 6: tvRobotStatus.setText(\"状态： 任务取消\"); robotImage.setImageResource(R.drawable.redagv); break; case -10000: tvRobotStatus.setText(\"所有机器人均离线\"); robotImage.setImageResource(R.drawable.redagv); break; default: tvRobotStatus.setText(\"状态： 未知\"); robotImage.setImageResource(R.drawable.ximenziagv); break; &#125; &#125; &#125;&#125; &emsp;&emsp;机器人状态的具体信息在这里设置。 界面逻辑功能实现&emsp;&emsp;TaskActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238public class TaskActivity extends AppCompatActivity implements CustomAdapt, View.OnClickListener &#123; private String doctorNumber; private ImageView imgBack; private TextView tvTaskDoctorName; private TextView tvTaskDoctorNumber; private TextView tvTaskDoctorJob; //当前可用机器人列表 private ListView lvRobotInfo; //当前可用机器人数据源 private List&lt;RobotInfo&gt; RobotInfoList = new ArrayList&lt;&gt;(); //listView适配器 private RobotInfoAdapter robotInfoAdapter; private List&lt;String&gt; allRobots = new ArrayList&lt;&gt;() ; // 所有可用机器人列表 private List&lt;String&gt; allOfflineRobots = new ArrayList&lt;&gt;(); // 所有离线机器人列表 private ScheduledExecutorService requestPool; //定时请求服务器线程池 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //隐藏状态栏 View decorView = getWindow().getDecorView(); decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); getWindow().setStatusBarColor(Color.TRANSPARENT); setContentView(R.layout.activity_task); //获取之前activitity的值 Intent intent = getIntent(); doctorNumber = intent.getStringExtra(\"doctorNumber\"); // 初始化控件 initView(); // 初始化ListView适配器 initListView(); // 设置界面医生信息 setDoctorInfo(doctorNumber); &#125; private void initView() &#123; imgBack = findViewById(R.id.img_back); imgBack.setOnClickListener(this); tvTaskDoctorName = findViewById(R.id.tv_task_doctorName); tvTaskDoctorNumber = findViewById(R.id.tv_task_doctorNumber); tvTaskDoctorJob = findViewById(R.id.tv_task_doctorJob); // 初始化可用机器人列表 allRobots = Arrays.asList(getResources().getStringArray(R.array.allRobot)); allOfflineRobots.add(\"AMB-01\"); allOfflineRobots.add(\"AMB-02\"); &#125; private void initListView() &#123; // 创建构造器，初始化ListView lvRobotInfo = findViewById(R.id.lv_RobotInfo); robotInfoAdapter = new RobotInfoAdapter(TaskActivity.this, R.layout.adapter_robot_item, RobotInfoList); lvRobotInfo.setAdapter(robotInfoAdapter); // 设置ListView监听器 lvRobotInfo.setOnItemClickListener(((parent, view, position, id) -&gt; &#123; // 通过定时调用后端接口实时获取机器人信息 RobotInfo robotInfo = RobotInfoList.get(position); // 急停按下或者任务状态异常 if(!robotInfo.getRobotEmergencyStatus() &amp;&amp; (robotInfo.getRobotTaskStatus() == 0 || robotInfo.getRobotTaskStatus() == 4 || robotInfo.getRobotTaskStatus() == 6))&#123; Toast.makeText(TaskActivity.this, \"你已选择\" + robotInfo.getRobotName(), Toast.LENGTH_SHORT).show(); //点击具体的空闲车辆切换到下任务界面 Intent intent = new Intent(TaskActivity.this, AddTaskActivity.class); intent.putExtra(\"robotName\", robotInfo.getRobotName()); //将选中车辆的名称传给下个界面 startActivity(intent); &#125;else&#123; Toast.makeText(TaskActivity.this, \"不可选择\", Toast.LENGTH_SHORT).show(); &#125; &#125;)); &#125; private void setDoctorInfo(String doctorNumber) &#123; SeerService seerService = SeerServiceCreator.getInstance().create(SeerService.class); seerService.getDoctorInfoByEmployeeId(Integer.parseInt(doctorNumber)) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;DoctorResponse&gt;() &#123; @Override public void accept(DoctorResponse doctorResponse) throws Exception &#123;// Log.d(\"hahaha\", String.valueOf(ruikedaqiResponse.getMessage())); if(doctorResponse.getData().getDoctorUserList()!=null)&#123; String doctorName = doctorResponse.getData().getDoctorUserList().get(0).getName(); Integer doctorNumber = doctorResponse.getData().getDoctorUserList().get(0).getEmployeeId(); String doctorJob = doctorResponse.getData().getDoctorUserList().get(0).getJob(); setTextView(doctorName, doctorNumber, doctorJob); // 设置文本内容 &#125; &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Toast.makeText(TaskActivity.this, throwable.getMessage(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; /** * 设置文本控件内容 */ @SuppressLint(\"SetTextI18n\") public void setTextView(String doctorName, Integer doctorNum, String doctorJob)&#123; tvTaskDoctorName.setText(\"姓名：\" + doctorName); tvTaskDoctorNumber.setText(\"工号：\" + doctorNum); tvTaskDoctorJob.setText(\"职位：\" + doctorJob); &#125; @Override public void onClick(View view)&#123; // 返回到上一个界面 if (view.getId() == R.id.img_back)&#123; finish(); &#125; &#125; /** * 定时获取到小车信息 */ private void getRobotInfoInformation() &#123; SeerService seerService = SeerServiceCreator.getInstance().create(SeerService.class); // 切换回主线程并订阅 seerService.getAllRobotsInfo().subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;RobotAllInfoResponse&gt;() &#123; @Override public void accept(RobotAllInfoResponse robotAllInfoResponse) throws Exception &#123; RobotInfoList.clear(); //每次更新时清掉上一次的数据// allOfflineTankRobots = Arrays.asList(getResources().getStringArray(R.array.allTankRobot));// RobotInfo RobotInfo = null; if(robotAllInfoResponse.getData().getAllRobotInfoList()!=null)&#123; List&lt;RobotAllInfo&gt; robotAllInfoList = robotAllInfoResponse.getData().getAllRobotInfoList(); for (int i=0; i&lt;robotAllInfoList.size(); i++)&#123; RobotAllInfo robotAllInfo = robotAllInfoList.get(i); for (String robotArray : allRobots) &#123; if (robotArray.equals(robotAllInfo.getVehicleId())) &#123; // 如果此时的robotId为机器人列表中的值，则表示此时该机器人处于在线状态 RobotInfo RobotInfo = new RobotInfo(robotAllInfo.getVehicleId(), robotAllInfo.getBatteryLevel(), robotAllInfo.getTaskStatus(), robotAllInfo.getEmergency()); // 添加在线机器人 RobotInfoList.add(RobotInfo); allOfflineRobots.remove(robotArray);// Log.d(\"hahaha\", String.valueOf(allOfflineTankRobots.get(0))); &#125; &#125; &#125; //添加离线机器人 for(String offlineRobotArray: allOfflineRobots)&#123; RobotInfo RobotInfo = new RobotInfo(offlineRobotArray, 0.0, -1, false); RobotInfoList.add(RobotInfo); &#125; &#125;else&#123; // 此时表示所有机器人均离线 RobotInfo RobotInfo = new RobotInfo(\"robotALL\", 0.0, -10000, false); RobotInfoList.add(RobotInfo); &#125; // 通知Adapter更新 robotInfoAdapter.notifyDataSetChanged(); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; // Log.d(\"hahaha\", String.valueOf(throwable)); Toast.makeText(TaskActivity.this, \"错误信息为： \" + throwable.getMessage(), Toast.LENGTH_SHORT).show(); &#125; &#125;);// Log.d(\"hahaha\", \"循环\"); &#125; /** * 定时向服务器请求机器人数据 */ @Override protected void onResume() &#123; super.onResume(); startRequest(); //定时向服务器请求数据 &#125; /** * 停止请求服务器 */ @Override protected void onPause() &#123; super.onPause(); requestPool.shutdownNow(); &#125; /** * 定时向服务器请求机器人状态数据 */ private void startRequest() &#123; final TimerTask task = new TimerTask() &#123; @Override public void run() &#123; //execute task getRobotInfoInformation(); &#125; &#125;; requestPool = Executors.newScheduledThreadPool(1); requestPool.scheduleAtFixedRate(task, 0, 1000, TimeUnit.MILLISECONDS); &#125; /** * 屏幕适配 */ @Override public boolean isBaseOnWidth() &#123; return false; &#125; @Override public float getSizeInDp() &#123; return 375; &#125;&#125; &emsp;&emsp;首先定时从后端获取robotInfo数据，然后依次添加到 List&lt;RobotInfo&gt; RobotInfoList列表中，并根据Adapter的自定义规则显示在界面上。 下达任务界面设置设计理念&emsp;&emsp;左侧为机器人信息显示，右侧为新增任务功能。&emsp;&emsp;其中起点和终点信息均为ListView，通过自定义设计适配器显示起点/终点的房间号和房间名。&emsp;&emsp;选择相应的起点和终点即可新增任务。 界面设计&emsp;&emsp;新建空Activity，实现activity_add_task.xml：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".ui.activity.AddTaskActivity\"&gt; &lt;ImageView android:id=\"@+id/imageView\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:scaleType=\"centerCrop\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.0\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"1.0\" app:srcCompat=\"@drawable/bg_blue\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/v20\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.2\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/v40\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.4\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/v70\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.7\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/v50\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.5\" /&gt; &lt;TextView android:id=\"@+id/tv_add_task\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10dp\" android:text=\"新增任务\" android:textColor=\"@color/colorBlack\" android:textSize=\"40sp\" android:textStyle=\"bold\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/v40\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;TextView android:id=\"@+id/tv_add_task_robotName\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"50dp\" android:text=\"机器人\" android:textColor=\"@color/colorBlack\" android:textSize=\"30sp\" android:textStyle=\"bold\" app:layout_constraintEnd_toStartOf=\"@+id/v40\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;ImageView android:id=\"@+id/img_add_task_robotImg\" android:layout_width=\"250dp\" android:layout_height=\"250dp\" android:layout_marginTop=\"20dp\" android:scaleType=\"fitXY\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@+id/v40\" app:layout_constraintHorizontal_bias=\"0.372\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@+id/tv_add_task_robotName\" /&gt; &lt;TextView android:id=\"@+id/tv_add_task_startPosition\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10dp\" android:text=\"起 点\" android:textColor=\"@color/colorBlack\" android:textSize=\"25sp\" android:textStyle=\"bold\" app:layout_constraintEnd_toStartOf=\"@+id/v70\" app:layout_constraintStart_toStartOf=\"@+id/v40\" app:layout_constraintTop_toBottomOf=\"@+id/tv_add_task\" /&gt; &lt;TextView android:id=\"@+id/tv_add_task_endPosition\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"终 点\" android:textColor=\"@color/colorBlack\" android:textSize=\"25sp\" android:textStyle=\"bold\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/v70\" app:layout_constraintTop_toTopOf=\"@+id/tv_add_task_startPosition\" /&gt; &lt;ListView android:id=\"@+id/lv_add_task_startName\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:layout_marginStart=\"10dp\" android:layout_marginTop=\"10dp\" android:layout_marginEnd=\"10dp\" android:layout_marginBottom=\"10dp\" android:background=\"@drawable/shape_gray_corner_2\" app:layout_constraintBottom_toTopOf=\"@+id/bt_add_task_confirm\" app:layout_constraintEnd_toStartOf=\"@+id/v70\" app:layout_constraintStart_toStartOf=\"@+id/v40\" app:layout_constraintTop_toBottomOf=\"@+id/tv_add_task_startPosition\" /&gt; &lt;ListView android:id=\"@+id/lv_add_task_endName\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:layout_marginStart=\"10dp\" android:layout_marginTop=\"10dp\" android:layout_marginEnd=\"10dp\" android:layout_marginBottom=\"10dp\" android:background=\"@drawable/shape_gray_corner_2\" app:layout_constraintBottom_toTopOf=\"@+id/bt_add_task_cancel\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/v70\" app:layout_constraintTop_toBottomOf=\"@+id/tv_add_task_endPosition\" /&gt; &lt;Button android:id=\"@+id/bt_add_task_confirm\" android:layout_width=\"150dp\" android:layout_height=\"50dp\" android:layout_marginBottom=\"15dp\" android:background=\"@drawable/shape_blue_corner\" android:text=\"确 定\" android:textColor=\"@color/colorWhite\" android:textSize=\"30sp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@+id/v70\" app:layout_constraintStart_toStartOf=\"@+id/v40\" /&gt; &lt;Button android:id=\"@+id/bt_add_task_cancel\" android:layout_width=\"150dp\" android:layout_height=\"50dp\" android:layout_marginBottom=\"15dp\" android:background=\"@drawable/shape_blue_corner\" android:text=\"取 消\" android:textColor=\"@color/colorWhite\" android:textSize=\"30sp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/v70\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 适配器PositionNameAdapter&emsp;&emsp;界面实现adapter_position_name_item.xml:12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:id=\"@+id/tv_position_room_number\" android:layout_width=\"0dp\" android:layout_height=\"35dp\" android:layout_weight=\"1\" android:layout_gravity=\"center\" android:gravity=\"center\" android:textSize=\"20sp\" android:textColor=\"@color/colorBlack\" /&gt; &lt;TextView android:id=\"@+id/tv_position_name\" android:layout_width=\"0dp\" android:layout_height=\"35dp\" android:layout_weight=\"1\" android:layout_gravity=\"center\" android:gravity=\"center\" android:textSize=\"20sp\" android:textColor=\"@color/colorBlack\" /&gt;&lt;/LinearLayout&gt; &emsp;&emsp;逻辑功能实现PositionNameAdapter.java：123456789101112131415161718192021222324252627/** * 起始点目标点listView适配器 */public class PositionNameAdapter extends ArrayAdapter&lt;PositionName&gt; &#123; private int resourceId; // 构造函数 需要activity,layout和list数据 public PositionNameAdapter(Context context, int resourceId, List&lt;PositionName&gt; objects) &#123; super(context, resourceId, objects); this.resourceId = resourceId; &#125; @SuppressLint(\"SetTextI18n\") @Override public View getView(int position, View convertView, ViewGroup parent) &#123; PositionName positionName = getItem(position); View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); TextView tvPositionName = view.findViewById(R.id.tv_position_name); TextView tvPositionRoomNumber = view.findViewById(R.id.tv_position_room_number); tvPositionName.setText(positionName.getRoomName()); tvPositionRoomNumber.setText(positionName.getRoomNumber()); return view; &#125;&#125; 界面逻辑功能实现&emsp;&emsp;AddTaskActivity.java：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229public class AddTaskActivity extends AppCompatActivity implements CustomAdapt, View.OnClickListener &#123; private String robotName; private Button btAddTaskConfirm; private Button btAddTaskCancel; private TextView tvAddTaskRobotName; private ImageView ivAddTaskRobotImg; //起始点名字列表 private ListView lvAddTaskStartName; //起始点名字列表数据源 private List&lt;PositionName&gt; startNameList = new ArrayList&lt;&gt;(); //listView适配器 private PositionNameAdapter startNameAdapter; private String startNameSelect = \"\"; private String startNumberSelect = \"\"; private String[] startNameArrays; private String[] startNumberArrays; //目标点名字列表 private ListView lvAddTaskEndName; //目标点名字列表数据源 private List&lt;PositionName&gt; endNameList = new ArrayList&lt;&gt;(); //listView适配器 private PositionNameAdapter endNameAdapter; private String endNameSelect = \"\"; private String endNumberSelect = \"\"; private String[] endNameArrays; private String[] endNumberArrays; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //隐藏状态栏 View decorView = getWindow().getDecorView(); decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); getWindow().setStatusBarColor(Color.TRANSPARENT); setContentView(R.layout.activity_add_task); //从上一个界面中获取到车辆名称 Intent intent = getIntent(); robotName = intent.getStringExtra(\"robotName\"); // 初始化控件 initView(); // 初始化起始点listView initStartNameAdapter(); // 初始化目标点listView initEndNameAdapter(); &#125; private void initView() &#123; btAddTaskConfirm = findViewById(R.id.bt_add_task_confirm); btAddTaskCancel = findViewById(R.id.bt_add_task_cancel); btAddTaskConfirm.setOnClickListener(this); btAddTaskCancel.setOnClickListener(this); tvAddTaskRobotName = findViewById(R.id.tv_add_task_robotName); ivAddTaskRobotImg = findViewById(R.id.img_add_task_robotImg); switch (robotName)&#123; case \"AMB-01\": tvAddTaskRobotName.setText(\"蓝小运001号\"); ivAddTaskRobotImg.setBackgroundResource(R.drawable.tank008); break; case \"tank009\": tvAddTaskRobotName.setText(\"蓝小运002号\"); ivAddTaskRobotImg.setBackgroundResource(R.drawable.tank009); break; &#125; &#125; private void initStartNameAdapter() &#123; // 添加起始点 startNameArrays = getResources().getStringArray(R.array.startName); startNumberArrays = getResources().getStringArray(R.array.startNumber); // 起始点list列表 for (int i = 0; i &lt; startNameArrays.length;i++)&#123; startNameList.add(new PositionName(startNameArrays[i], startNumberArrays[i])); &#125; //初始化ListView lvAddTaskStartName = findViewById(R.id.lv_add_task_startName); startNameAdapter = new PositionNameAdapter(AddTaskActivity.this, R.layout.adapter_position_name_item, startNameList); lvAddTaskStartName.setAdapter(startNameAdapter); //listView设置监听器 lvAddTaskStartName.setOnItemClickListener((parent, view, position, id)-&gt;&#123; PositionName startName = startNameList.get(position); startNumberSelect = startName.getRoomNumber(); startNameSelect = startName.getRoomName(); // 设置颜色 Drawable drawable = getResources().getDrawable(R.color.colorXimenzi); lvAddTaskStartName.setSelector(drawable); // 添加提示信息 Toast.makeText(AddTaskActivity.this, \"你已选择 \" + startName.getRoomNumber() + \" \" + startName.getRoomName(), Toast.LENGTH_SHORT).show(); &#125;); &#125; private void initEndNameAdapter() &#123; // 添加目标点 endNameArrays = getResources().getStringArray(R.array.endName); endNumberArrays = getResources().getStringArray(R.array.endNumber); // 目标点list列表 for (int i = 0; i &lt; endNameArrays.length;i++)&#123; endNameList.add(new PositionName(endNameArrays[i], endNumberArrays[i])); &#125; //初始化ListView lvAddTaskEndName = findViewById(R.id.lv_add_task_endName); endNameAdapter = new PositionNameAdapter(AddTaskActivity.this, R.layout.adapter_position_name_item, endNameList); lvAddTaskEndName.setAdapter(endNameAdapter); //listView设置监听器 lvAddTaskEndName.setOnItemClickListener((parent, view, position, id)-&gt;&#123; PositionName endName = endNameList.get(position); endNumberSelect = endName.getRoomNumber(); endNameSelect = endName.getRoomName(); // 设置颜色 Drawable drawable = getResources().getDrawable(R.color.colorXimenzi); lvAddTaskEndName.setSelector(drawable); // 添加提示信息 Toast.makeText(AddTaskActivity.this, \"你已选择 \" + endName.getRoomNumber() + \" \" + endName.getRoomName(), Toast.LENGTH_SHORT).show(); &#125;); &#125; @Override public void onClick(View view) &#123; switch (view.getId())&#123; case R.id.bt_add_task_confirm: boolean isOK = checkTask(); // 成功则添加任务 if (isOK)&#123; addTask(); //添加任务 finish(); //返回上一个界面 &#125; else &#123; Toast.makeText(AddTaskActivity.this, \"任务未设置完成或任务设置失败！\", Toast.LENGTH_SHORT).show(); &#125; break; case R.id.bt_add_task_cancel: finish(); //取消按钮直接返回上个界面 break; &#125; &#125; private boolean checkTask() &#123; if(!startNumberSelect.equals(\"\") &amp;&amp; !endNumberSelect.equals(\"\"))&#123; switch (startNumberSelect)&#123; case \"LM1\": case \"LM2\": case \"LM3\": case \"LM4\": case \"LM5\": break; default: return false; &#125; switch (endNumberSelect)&#123; case \"LM1\": case \"LM2\": case \"LM3\": case \"LM4\": case \"LM5\": break; default: return false; &#125; return true; &#125;else &#123; return false; &#125; &#125; private void addTask() &#123; String robotIp = \"192.168.3.99\"; String taskId = \"12345678\"; RobotTask robotTask = new RobotTask(robotIp, startNumberSelect, endNumberSelect, taskId); // Log.d(\"hahaha\", robotTask.toString()); SeerService seerService = SeerServiceCreator.getInstance().create(SeerService.class); seerService.addTask(robotTask) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;RobotTaskResponse&gt;() &#123; @Override public void accept(RobotTaskResponse robotTaskResponse) throws Exception &#123; // Log.d(\"hahaha\", String.valueOf(robotTaskResponse.getMessage())); if (robotTaskResponse.isSuccess()) &#123; Toast.makeText(AddTaskActivity.this, \"下达任务成功！\", Toast.LENGTH_SHORT).show(); &#125; else &#123; // 无账号 Toast.makeText(AddTaskActivity.this, \"下达任务失败！\" + robotTaskResponse.getMessage(), Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; // Log.d(\"hahaha\", String.valueOf(throwable)); Toast.makeText(AddTaskActivity.this, \"下达任务失败！\" + throwable, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; /** * 屏幕适配 */ @Override public boolean isBaseOnWidth() &#123; return false; &#125; @Override public float getSizeInDp() &#123; return 375; &#125;&#125; 医疗运输机器人客户端APP实现(基于Socket协议)","categories":[{"name":"Web开发与应用","slug":"Web开发与应用","permalink":"http://cxx0822.github.io/categories/Web开发与应用/"}],"tags":[]},{"title":"基于SpringBoot和MyBatis框架的简单使用","slug":"基于SpringBoot和MyBatis框架的简单使用","date":"2020-08-23T03:42:48.000Z","updated":"2022-03-30T02:27:08.551Z","comments":true,"path":"2020/08/23/ji-yu-springboot-he-mybatis-kuang-jia-de-jian-dan-shi-yong/","link":"","permalink":"http://cxx0822.github.io/2020/08/23/ji-yu-springboot-he-mybatis-kuang-jia-de-jian-dan-shi-yong/","excerpt":"","text":"平台&emsp;&emsp;window10&emsp;&emsp;Intellij IDEA2020&emsp;&emsp;Spring Boot2.3.3&emsp;&emsp;Java SDK 1.8&emsp;&emsp;MySQL 8.0.19&emsp;&emsp;Navicat15 简介Swagger&emsp;&emsp;Swagger是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful风格的Web服务。&emsp;&emsp;Swagger的目标是对REST API定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。当通过Swagger进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。与为底层编程所实现的接口类似，Swagger消除了调用服务时可能会有的猜测。&emsp;&emsp;Swagger的优势： 支持API自动生成同步的在线文档：使用Swagger后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。 提供Web页面在线测试API：光有文档还不够，Swagger生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。 OAS&emsp;&emsp;OAS是OpenAPI Specification的简称，可以翻译为OpenAPI规范，它是定义API的一种规范，它的前身是Swagger规范。 OAS与Swagger&emsp;&emsp;OAS定义了一种书写API的一种格式，大家通过遵从同一种格式规范达到API文档的统一。狭义上理解，它用于描述一整套API接口，包括一个接口是GET还是POST请求，有哪些参数，哪些header等等，它在设计的时候通常是YAML格式，这种格式书写起来比较方便，而在网络中传输时又会以json形式居多，因为json的通用性比较强。OpenAPI Specification已经在2015年捐献给了Linux基金会，现在已经成为RESTful API的世界标准。&emsp;&emsp;Swagger是一个工具、一个项目、一个流行的API开发框架(当然，我们上面也说了Swagger是规范，但是后面演变成了OAS)，这个框架以OAS为基础，对整个API的开发周期都提供了相应的解决方案，是一个非常庞大的项目(包括Swagger Editor、Swagger UI、Swagger Codegen、Swagger Inspector)。 Springfox&emsp;&emsp;Springfox是践行OAS的一个项目，它将Swagger融合进流行的Spring框架，根据OpenAPI规范，帮助开发者自动生成API文档。Springfox是由Marty Pitt创建的项目swagger-springmvc发展而来。它其中有一个组件叫springfox-swagger2，springfox-swagger2是依赖OSA规范文档，也就是一个描述API的json文件，而这个组件的功能就是帮助我们自动生成这个json文件，我们会用到的另外一个组件springfox-swagger-ui就是将这个json文件解析出来，用一种更友好的方式呈现出来。 总结&emsp;&emsp;Swagger是一种规范。springfox-swagger是基于Spring生态系统的该规范的实现。springfox-swagger-ui是对swagger-ui的封装，使得其可以使用 Spring的服务。&emsp;&emsp;也就是Swagger是规范，协议，Spring是实现。(Spring是一个主流的Java Web`开发框架，该框架是一个轻量级的应用框架，具有很高的凝聚力和吸引力。) 参考博客&emsp;&emsp;OAS、Swagger和Springfox 建立数据库安装软件&emsp;&emsp;首先安装数据库和数据库可视工具(任意一个)，具体可参考：MySQL 8.0.19安装教程(windows 64位)+ Navicat破解安装教程 新建数据库&emsp;&emsp;首先建立一个连接，并设置好参数：&emsp;&emsp;这里的用户名和密码为建立数据库时的配置。&emsp;&emsp;然后在该连接上建立一个数据库，点击新建查询，并输入以下代码：1234567891011121314151617181920-- ------------------------------ Table structure for doctor_info-- ----------------------------DROP TABLE IF EXISTS `doctor_info`;CREATE TABLE `doctor_info` ( `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `gender` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `age` int(0) NULL DEFAULT NULL, `post` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `department` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `employeeID` int(0) NULL DEFAULT NULL) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of doctor_info-- ----------------------------INSERT INTO `doctor_info` VALUES ('Cxx', '男', 26, '医师', '检验科', 12345);INSERT INTO `doctor_info` VALUES ('Xll', '男', 25, '实习医生', '住院部', 23456);SET FOREIGN_KEY_CHECKS = 1; &emsp;&emsp;然后点击运行即可查看新建的表。 基于Spring Web和MyBatic框架的Swagger ui实现建立工程&emsp;&emsp;打开开发工具Intellij IDEA2020，选择New-&gt;Project，选择java sdk 1.8，然后选择自己的Group和Artifact，然后这里的依赖选择Web里面的Spring Web和SQL里面的JDBC API、MyBatic Framework和MySQL Driver。然后选择Next-&gt;Finish建立工程。 更改配置文件&emsp;&emsp;打开工程文件夹里面src\\resources下的配置文件application.properties，设置数据库的连接参数：12345spring.datasource.url=jdbc:mysql://localhost:3306/ruikedaqi?\\ serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 安装依赖库&emsp;&emsp;打开工程文件夹里面的pom.xml，在里面添加依赖文件：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!--添加spring boot依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql连接类--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--添加JDBC依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--添加druid依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.20&lt;/version&gt;&lt;/dependency&gt; &emsp;&emsp;点击右上角位置出现的更新按钮，即可下载更新。 建立工程文件目录包&emsp;&emsp;首先在工程文件中建立几个包1234bean // 使用实体类config // 配置类controller // 前端接口类mapper // 数据库映射关系类 &emsp;&emsp;最终的文件夹结构为： config包&emsp;&emsp;新建一个配置类MyConfig(名字任意，下同)1234567891011121314151617181920212223242526272829@Configuration@EnableSwagger2public class MyConfig &#123; //配置swagger2核心配置docket //修改默认配置bean @Bean public Docket myDocket()&#123; return new Docket(DocumentationType.SWAGGER_2) //指定API类型为swagger2 .apiInfo(apiInfo()) //用于定于api文档汇总信息 .select() .apis(RequestHandlerSelectors .basePackage(\"com.ruikedaqi.sql.controller\")) //指定controller包 .paths(PathSelectors.any()) // 所有controller .build(); &#125; private ApiInfo apiInfo()&#123; return new ApiInfoBuilder() .title(\"睿科大器医疗机器人\") // 文档页标题 .contact(new Contact(\"Cxx\", // 联系人信息 \"www.baidu.com\", \"@email\")) .description(\"睿科大器医疗机器人有限公司\") // 详细信息 .version(\"1.0.1\") // 文档版本号 .termsOfServiceUrl(\"www.baidu.com\") //网站地址 .build(); &#125;&#125; &emsp;&emsp;注意这里的basePackage为刚才的conntroller包的路径，要修改为自己的。&emsp;&emsp;Spring Boot框架是利用注解来表明类的作用。例如这里的@Configuration表明这是一个配置类，@EnableSwagger2表明使用的是Swagger2。&emsp;&emsp;编译运行后，在浏览器打开http://localhost:8080/swagger-ui.html#/即可看到生成的API文档： bean包DoctorInfo类&emsp;&emsp;首先建立一个DoctorInfo类，里面存放的是数据库里面的信息：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class DoctorInfo &#123; private String name; private String gender; private int age; private String post; private String department; private int employeeID; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getPost() &#123; return post; &#125; public void setPost(String post) &#123; this.post = post; &#125; public String getDepartment() &#123; return department; &#125; public void setDepartment(String department) &#123; this.department = department; &#125; public int getEmployeeID() &#123; return employeeID; &#125; public void setEmployeeID(int employeeID) &#123; this.employeeID = employeeID; &#125; @Override public String toString()&#123; return \"doctorInfo&#123;\" + \"name\" + name + \", gender='\" + gender + '\\'' + \", age='\" + age + '\\'' + \", post='\" + post + '\\'' + \", department='\" + department + '\\'' + \", employeeID='\" + employeeID + '\\'' + '&#125;'; &#125;&#125; &emsp;&emsp;这里的属性就是刚才建立的数据表里面的表头信息，并设置其get和set方法。 ResultMessage&emsp;&emsp;因为API获取的数据一般为json格式，因此还需要定义一个返回数据信息格式的类。12345678910111213141516171819202122232425262728293031323334public class ResultMessage implements Serializable &#123; private int code = 0; private String message; private Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); private ResultMessage()&#123; &#125; public static ResultMessage create()&#123; return new ResultMessage(); &#125; public int getCode()&#123; return this.code; &#125; public String getMessage()&#123; return this.message; &#125; public void raise(int code, String message)&#123; this.code = code; this.message = message; &#125; public void put(String key, Object obj)&#123; this.result.put(key, obj); &#125; public Map&lt;String, Object&gt; getAttr()&#123; return this.result; &#125;&#125; &emsp;&emsp;这里一共定义3个属性：code、message和result，分别代表正确/错误码、信息提示和结果。并分为定义2个方法：raise()和put用来显示信息提示和添加结果。 mapper包&emsp;&emsp;新建一个DoctorMapper的接口，在里面定义数据库的映射关系：123456789101112131415161718@Mapperpublic interface DoctorMapper &#123; /**通过姓名查询*/ @Select(\"SELECT * FROM ruikedaqi.doctor_info WHERE name = #&#123;name&#125;\") DoctorInfo getByName(@Param(\"name\") String name); /**插入表记录*/ @Insert(\"INSERT INTO ruikedaqi.doctor_info(name,gender,age,post,department,employeeID) VALUES(#&#123;name&#125;,#&#123;gender&#125;,#&#123;age&#125;,#&#123;post&#125;,#&#123;department&#125;,#&#123;employeeID&#125;)\") int create(DoctorInfo doctorInfo); /*删除记录*/ @Delete(\"DELETE FROM ruikedaqi.doctor_info where name=#&#123;name&#125;\") int deleteByName(@Param(\"name\") String name); /*根据姓名修改职务记录*/ @Update(\"UPDATE ruikedaqi.doctor_info SET department=#&#123;department&#125; where name=#&#123;name&#125;\") int updateDepartmentByName(@Param(\"name\") String name, @Param(\"department\") String department);&#125; &emsp;&emsp;这里注意要添加类注解@Mapper。&emsp;&emsp;每个方法均需要添加注解，表明是数据库中的哪种操作类型。本例中只提供了几个常用的增删改查操作。 controller包&emsp;&emsp;最后就是建立核心的controller包。&emsp;&emsp;建立DoctorInfoController类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//提示码//code -1 姓名不存在/不能为空//code 999 姓名已存在//code 101 增加成功//code 102 删除成功//code 103 修改成功//code 104 查询成功@RestControllerpublic class DoctorInfoController &#123; private boolean isNotNull(@RequestParam(value = \"name\", required = true) String name, ResultMessage resultMessage) &#123; if (name == null || name.equals(\"\"))&#123; resultMessage.raise(-1,\"姓名不能为空\"); return true; &#125; return false; &#125; @Autowired private DoctorMapper doctorMapper; /** * 插入数据 */ @PostMapping(value = \"/doctor/add\") public Object registerDoctor(@RequestParam(value = \"name\", required = true) String name, @RequestParam(value = \"gender\", required = true) String gender, @RequestParam(value = \"age\", required = true) int age, @RequestParam(value = \"post\", required = true) String post, @RequestParam(value = \"department\", required = true) String department, @RequestParam(value = \"employeeID\", required = true) int employeeID) &#123; ResultMessage resultMessage = ResultMessage.create(); //判断user name空值 if (isNotNull(name, resultMessage)) return resultMessage; DoctorInfo doctorInfo = this.doctorMapper.getByName(name); if (doctorInfo != null)&#123; resultMessage.raise(999, \"姓名已存在\"); return resultMessage; &#125;else&#123; resultMessage.put(\"name\",name); resultMessage.put(\"gender\",gender); resultMessage.put(\"age\",age); resultMessage.put(\"post\",post); resultMessage.put(\"department\",department); resultMessage.put(\"employeeID\",employeeID); resultMessage.raise(101,\"增加成功\"); doctorInfo = new DoctorInfo(); doctorInfo.setName(name); doctorInfo.setGender(gender); doctorInfo.setAge(age); doctorInfo.setPost(post); doctorInfo.setDepartment(department); doctorInfo.setEmployeeID(employeeID); int createName = this.doctorMapper.create(doctorInfo); return resultMessage; &#125; &#125; /** * 通过name查询信息 */ @GetMapping(value = \"doctor/getInfo/ByName/&#123;name&#125;\") public Object getInfoByName(@PathVariable String name) &#123; DoctorInfo doctorInfo = this.doctorMapper.getByName(name); ResultMessage resultMessage = ResultMessage.create(); if (doctorInfo == null)&#123; resultMessage.raise(-1,\"姓名不存在\"); return resultMessage; &#125; resultMessage.put(\"name\",doctorInfo.getName()); resultMessage.put(\"gender\",doctorInfo.getGender()); resultMessage.put(\"age\",doctorInfo.getAge()); resultMessage.put(\"post\",doctorInfo.getPost()); resultMessage.put(\"department\",doctorInfo.getDepartment()); resultMessage.put(\"employeeID\",doctorInfo.getEmployeeID()); resultMessage.raise(104,\"查询成功\"); return resultMessage; &#125; /** * 通过name删除信息 */ @PostMapping(value = \"doctor/deleteInfo/ByName/&#123;name&#125;\") public Object deleteInfoByName(@PathVariable String name) &#123; DoctorInfo doctorInfo = this.doctorMapper.getByName(name); ResultMessage resultMessage = ResultMessage.create(); if (doctorInfo == null)&#123; resultMessage.raise(-1,\"user不存在\"); return resultMessage; &#125; resultMessage.raise(102,\"删除成功\"); int deleteName = this.doctorMapper.deleteByName(name); return resultMessage; &#125; /** * 通过name修改职务信息D */ @PostMapping(value = \"doctor/updateDepartment/ByName/&#123;name&#125;,&#123;department&#125;\") public Object updateDepartmentByName(@PathVariable String name, @PathVariable String department) &#123; DoctorInfo doctorInfo = this.doctorMapper.getByName(name); ResultMessage resultMessage = ResultMessage.create(); if (doctorInfo == null)&#123; resultMessage.raise(-1,\"user不存在\"); return resultMessage; &#125; resultMessage.raise(103,\"修改成功\"); int updateDepartmentByName = this.doctorMapper.updateDepartmentByName(name,department); return resultMessage; &#125;&#125; &emsp;&emsp;@RestController表明这是一个控制类。@PostMapping表明这是一个post方法，@GetMapping表明这是一个get方法，后面的value就是具体的请求地址。 本地运行并测试&emsp;&emsp;点击build和run按钮，打开浏览器输入本地测试地址http://localhost:8080/swagger-ui.html：&emsp;&emsp;打开第3个/doctor/getInfo/ByName/{name}``API，并点击Try it out，输入内容即可进行简单的测试。 部署到服务器生成jar包&emsp;&emsp;点击右侧的Maven选项卡，打开Lifecycle，依次双击clean和package，生成的jar包在工程文件夹的target文件夹中。&emsp;&emsp;将生成的jar包放在ubuntu系统中，打开终端输入命令：1nohup java -jar ***.jar --server.port=8181 &gt;debug.log 2&gt;&amp;1 &amp; &emsp;&emsp;nohup表示一直运行，--server.port=8181表示开启服务器端的端口号，debug.log为日志文件，可以查看报错信息等。","categories":[{"name":"Web开发与应用","slug":"Web开发与应用","permalink":"http://cxx0822.github.io/categories/Web开发与应用/"}],"tags":[]},{"title":"基于SpringBoot和MyBatis框架的简单使用","slug":"基于SpringBoot和MyBatis框架的swaggerAPI数据库的简单使用","date":"2020-08-23T03:42:48.000Z","updated":"2022-03-21T06:19:12.782Z","comments":true,"path":"2020/08/23/ji-yu-springboot-he-mybatis-kuang-jia-de-swaggerapi-shu-ju-ku-de-jian-dan-shi-yong/","link":"","permalink":"http://cxx0822.github.io/2020/08/23/ji-yu-springboot-he-mybatis-kuang-jia-de-swaggerapi-shu-ju-ku-de-jian-dan-shi-yong/","excerpt":"","text":"平台&emsp;&emsp;window10&emsp;&emsp;Intellij IDEA2020&emsp;&emsp;Spring Boot2.3.3&emsp;&emsp;Java SDK 1.8&emsp;&emsp;MySQL 8.0.19&emsp;&emsp;Navicat15 简介Swagger&emsp;&emsp;Swagger是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful风格的Web服务。&emsp;&emsp;Swagger的目标是对REST API定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。当通过Swagger进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。与为底层编程所实现的接口类似，Swagger消除了调用服务时可能会有的猜测。&emsp;&emsp;Swagger的优势： 支持API自动生成同步的在线文档：使用Swagger后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。 提供Web页面在线测试API：光有文档还不够，Swagger生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。 OAS&emsp;&emsp;OAS是OpenAPI Specification的简称，可以翻译为OpenAPI规范，它是定义API的一种规范，它的前身是Swagger规范。 OAS与Swagger&emsp;&emsp;OAS定义了一种书写API的一种格式，大家通过遵从同一种格式规范达到API文档的统一。狭义上理解，它用于描述一整套API接口，包括一个接口是GET还是POST请求，有哪些参数，哪些header等等，它在设计的时候通常是YAML格式，这种格式书写起来比较方便，而在网络中传输时又会以json形式居多，因为json的通用性比较强。OpenAPI Specification已经在2015年捐献给了Linux基金会，现在已经成为RESTful API的世界标准。&emsp;&emsp;Swagger是一个工具、一个项目、一个流行的API开发框架(当然，我们上面也说了Swagger是规范，但是后面演变成了OAS)，这个框架以OAS为基础，对整个API的开发周期都提供了相应的解决方案，是一个非常庞大的项目(包括Swagger Editor、Swagger UI、Swagger Codegen、Swagger Inspector)。 Springfox&emsp;&emsp;Springfox是践行OAS的一个项目，它将Swagger融合进流行的Spring框架，根据OpenAPI规范，帮助开发者自动生成API文档。Springfox是由Marty Pitt创建的项目swagger-springmvc发展而来。它其中有一个组件叫springfox-swagger2，springfox-swagger2是依赖OSA规范文档，也就是一个描述API的json文件，而这个组件的功能就是帮助我们自动生成这个json文件，我们会用到的另外一个组件springfox-swagger-ui就是将这个json文件解析出来，用一种更友好的方式呈现出来。 总结&emsp;&emsp;Swagger是一种规范。springfox-swagger是基于Spring生态系统的该规范的实现。springfox-swagger-ui是对swagger-ui的封装，使得其可以使用 Spring的服务。&emsp;&emsp;也就是Swagger是规范，协议，Spring是实现。(Spring是一个主流的Java Web`开发框架，该框架是一个轻量级的应用框架，具有很高的凝聚力和吸引力。) 参考博客&emsp;&emsp;OAS、Swagger和Springfox 建立数据库安装软件&emsp;&emsp;首先安装数据库和数据库可视工具(任意一个)，具体可参考：MySQL 8.0.19安装教程(windows 64位)+ Navicat破解安装教程 新建数据库&emsp;&emsp;首先建立一个连接，并设置好参数：&emsp;&emsp;这里的用户名和密码为建立数据库时的配置。&emsp;&emsp;然后在该连接上建立一个数据库，点击新建查询，并输入以下代码：1234567891011121314151617181920-- ------------------------------ Table structure for doctor_info-- ----------------------------DROP TABLE IF EXISTS `doctor_info`;CREATE TABLE `doctor_info` ( `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `gender` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `age` int(0) NULL DEFAULT NULL, `post` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `department` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `employeeID` int(0) NULL DEFAULT NULL) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of doctor_info-- ----------------------------INSERT INTO `doctor_info` VALUES ('Cxx', '男', 26, '医师', '检验科', 12345);INSERT INTO `doctor_info` VALUES ('Xll', '男', 25, '实习医生', '住院部', 23456);SET FOREIGN_KEY_CHECKS = 1; &emsp;&emsp;然后点击运行即可查看新建的表。 基于Spring Web和MyBatic框架的Swagger ui实现建立工程&emsp;&emsp;打开开发工具Intellij IDEA2020，选择New-&gt;Project，选择java sdk 1.8，然后选择自己的Group和Artifact，然后这里的依赖选择Web里面的Spring Web和SQL里面的JDBC API、MyBatic Framework和MySQL Driver。然后选择Next-&gt;Finish建立工程。 更改配置文件&emsp;&emsp;打开工程文件夹里面src\\resources下的配置文件application.properties，设置数据库的连接参数：12345spring.datasource.url=jdbc:mysql://localhost:3306/ruikedaqi?\\ serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 安装依赖库&emsp;&emsp;打开工程文件夹里面的pom.xml，在里面添加依赖文件：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!--添加spring boot依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql连接类--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--添加JDBC依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--添加druid依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.20&lt;/version&gt;&lt;/dependency&gt; &emsp;&emsp;点击右上角位置出现的更新按钮，即可下载更新。 建立工程文件目录包&emsp;&emsp;首先在工程文件中建立几个包1234bean // 使用实体类config // 配置类controller // 前端接口类mapper // 数据库映射关系类 &emsp;&emsp;最终的文件夹结构为： config包&emsp;&emsp;新建一个配置类MyConfig(名字任意，下同)1234567891011121314151617181920212223242526272829@Configuration@EnableSwagger2public class MyConfig &#123; //配置swagger2核心配置docket //修改默认配置bean @Bean public Docket myDocket()&#123; return new Docket(DocumentationType.SWAGGER_2) //指定API类型为swagger2 .apiInfo(apiInfo()) //用于定于api文档汇总信息 .select() .apis(RequestHandlerSelectors .basePackage(\"com.ruikedaqi.sql.controller\")) //指定controller包 .paths(PathSelectors.any()) // 所有controller .build(); &#125; private ApiInfo apiInfo()&#123; return new ApiInfoBuilder() .title(\"睿科大器医疗机器人\") // 文档页标题 .contact(new Contact(\"Cxx\", // 联系人信息 \"www.baidu.com\", \"@email\")) .description(\"睿科大器医疗机器人有限公司\") // 详细信息 .version(\"1.0.1\") // 文档版本号 .termsOfServiceUrl(\"www.baidu.com\") //网站地址 .build(); &#125;&#125; &emsp;&emsp;注意这里的basePackage为刚才的conntroller包的路径，要修改为自己的。&emsp;&emsp;Spring Boot框架是利用注解来表明类的作用。例如这里的@Configuration表明这是一个配置类，@EnableSwagger2表明使用的是Swagger2。&emsp;&emsp;编译运行后，在浏览器打开http://localhost:8080/swagger-ui.html#/即可看到生成的API文档： bean包DoctorInfo类&emsp;&emsp;首先建立一个DoctorInfo类，里面存放的是数据库里面的信息：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class DoctorInfo &#123; private String name; private String gender; private int age; private String post; private String department; private int employeeID; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getPost() &#123; return post; &#125; public void setPost(String post) &#123; this.post = post; &#125; public String getDepartment() &#123; return department; &#125; public void setDepartment(String department) &#123; this.department = department; &#125; public int getEmployeeID() &#123; return employeeID; &#125; public void setEmployeeID(int employeeID) &#123; this.employeeID = employeeID; &#125; @Override public String toString()&#123; return \"doctorInfo&#123;\" + \"name\" + name + \", gender='\" + gender + '\\'' + \", age='\" + age + '\\'' + \", post='\" + post + '\\'' + \", department='\" + department + '\\'' + \", employeeID='\" + employeeID + '\\'' + '&#125;'; &#125;&#125; &emsp;&emsp;这里的属性就是刚才建立的数据表里面的表头信息，并设置其get和set方法。 ResultMessage&emsp;&emsp;因为API获取的数据一般为json格式，因此还需要定义一个返回数据信息格式的类。12345678910111213141516171819202122232425262728293031323334public class ResultMessage implements Serializable &#123; private int code = 0; private String message; private Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); private ResultMessage()&#123; &#125; public static ResultMessage create()&#123; return new ResultMessage(); &#125; public int getCode()&#123; return this.code; &#125; public String getMessage()&#123; return this.message; &#125; public void raise(int code, String message)&#123; this.code = code; this.message = message; &#125; public void put(String key, Object obj)&#123; this.result.put(key, obj); &#125; public Map&lt;String, Object&gt; getAttr()&#123; return this.result; &#125;&#125; &emsp;&emsp;这里一共定义3个属性：code、message和result，分别代表正确/错误码、信息提示和结果。并分为定义2个方法：raise()和put用来显示信息提示和添加结果。 mapper包&emsp;&emsp;新建一个DoctorMapper的接口，在里面定义数据库的映射关系：123456789101112131415161718@Mapperpublic interface DoctorMapper &#123; /**通过姓名查询*/ @Select(\"SELECT * FROM ruikedaqi.doctor_info WHERE name = #&#123;name&#125;\") DoctorInfo getByName(@Param(\"name\") String name); /**插入表记录*/ @Insert(\"INSERT INTO ruikedaqi.doctor_info(name,gender,age,post,department,employeeID) VALUES(#&#123;name&#125;,#&#123;gender&#125;,#&#123;age&#125;,#&#123;post&#125;,#&#123;department&#125;,#&#123;employeeID&#125;)\") int create(DoctorInfo doctorInfo); /*删除记录*/ @Delete(\"DELETE FROM ruikedaqi.doctor_info where name=#&#123;name&#125;\") int deleteByName(@Param(\"name\") String name); /*根据姓名修改职务记录*/ @Update(\"UPDATE ruikedaqi.doctor_info SET department=#&#123;department&#125; where name=#&#123;name&#125;\") int updateDepartmentByName(@Param(\"name\") String name, @Param(\"department\") String department);&#125; &emsp;&emsp;这里注意要添加类注解@Mapper。&emsp;&emsp;每个方法均需要添加注解，表明是数据库中的哪种操作类型。本例中只提供了几个常用的增删改查操作。 controller包&emsp;&emsp;最后就是建立核心的controller包。&emsp;&emsp;建立DoctorInfoController类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//提示码//code -1 姓名不存在/不能为空//code 999 姓名已存在//code 101 增加成功//code 102 删除成功//code 103 修改成功//code 104 查询成功@RestControllerpublic class DoctorInfoController &#123; private boolean isNotNull(@RequestParam(value = \"name\", required = true) String name, ResultMessage resultMessage) &#123; if (name == null || name.equals(\"\"))&#123; resultMessage.raise(-1,\"姓名不能为空\"); return true; &#125; return false; &#125; @Autowired private DoctorMapper doctorMapper; /** * 插入数据 */ @PostMapping(value = \"/doctor/add\") public Object registerDoctor(@RequestParam(value = \"name\", required = true) String name, @RequestParam(value = \"gender\", required = true) String gender, @RequestParam(value = \"age\", required = true) int age, @RequestParam(value = \"post\", required = true) String post, @RequestParam(value = \"department\", required = true) String department, @RequestParam(value = \"employeeID\", required = true) int employeeID) &#123; ResultMessage resultMessage = ResultMessage.create(); //判断user name空值 if (isNotNull(name, resultMessage)) return resultMessage; DoctorInfo doctorInfo = this.doctorMapper.getByName(name); if (doctorInfo != null)&#123; resultMessage.raise(999, \"姓名已存在\"); return resultMessage; &#125;else&#123; resultMessage.put(\"name\",name); resultMessage.put(\"gender\",gender); resultMessage.put(\"age\",age); resultMessage.put(\"post\",post); resultMessage.put(\"department\",department); resultMessage.put(\"employeeID\",employeeID); resultMessage.raise(101,\"增加成功\"); doctorInfo = new DoctorInfo(); doctorInfo.setName(name); doctorInfo.setGender(gender); doctorInfo.setAge(age); doctorInfo.setPost(post); doctorInfo.setDepartment(department); doctorInfo.setEmployeeID(employeeID); int createName = this.doctorMapper.create(doctorInfo); return resultMessage; &#125; &#125; /** * 通过name查询信息 */ @GetMapping(value = \"doctor/getInfo/ByName/&#123;name&#125;\") public Object getInfoByName(@PathVariable String name) &#123; DoctorInfo doctorInfo = this.doctorMapper.getByName(name); ResultMessage resultMessage = ResultMessage.create(); if (doctorInfo == null)&#123; resultMessage.raise(-1,\"姓名不存在\"); return resultMessage; &#125; resultMessage.put(\"name\",doctorInfo.getName()); resultMessage.put(\"gender\",doctorInfo.getGender()); resultMessage.put(\"age\",doctorInfo.getAge()); resultMessage.put(\"post\",doctorInfo.getPost()); resultMessage.put(\"department\",doctorInfo.getDepartment()); resultMessage.put(\"employeeID\",doctorInfo.getEmployeeID()); resultMessage.raise(104,\"查询成功\"); return resultMessage; &#125; /** * 通过name删除信息 */ @PostMapping(value = \"doctor/deleteInfo/ByName/&#123;name&#125;\") public Object deleteInfoByName(@PathVariable String name) &#123; DoctorInfo doctorInfo = this.doctorMapper.getByName(name); ResultMessage resultMessage = ResultMessage.create(); if (doctorInfo == null)&#123; resultMessage.raise(-1,\"user不存在\"); return resultMessage; &#125; resultMessage.raise(102,\"删除成功\"); int deleteName = this.doctorMapper.deleteByName(name); return resultMessage; &#125; /** * 通过name修改职务信息D */ @PostMapping(value = \"doctor/updateDepartment/ByName/&#123;name&#125;,&#123;department&#125;\") public Object updateDepartmentByName(@PathVariable String name, @PathVariable String department) &#123; DoctorInfo doctorInfo = this.doctorMapper.getByName(name); ResultMessage resultMessage = ResultMessage.create(); if (doctorInfo == null)&#123; resultMessage.raise(-1,\"user不存在\"); return resultMessage; &#125; resultMessage.raise(103,\"修改成功\"); int updateDepartmentByName = this.doctorMapper.updateDepartmentByName(name,department); return resultMessage; &#125;&#125; &emsp;&emsp;@RestController表明这是一个控制类。@PostMapping表明这是一个post方法，@GetMapping表明这是一个get方法，后面的value就是具体的请求地址。 本地运行并测试&emsp;&emsp;点击build和run按钮，打开浏览器输入本地测试地址http://localhost:8080/swagger-ui.html：&emsp;&emsp;打开第3个/doctor/getInfo/ByName/{name}``API，并点击Try it out，输入内容即可进行简单的测试。 部署到服务器生成jar包&emsp;&emsp;点击右侧的Maven选项卡，打开Lifecycle，依次双击clean和package，生成的jar包在工程文件夹的target文件夹中。&emsp;&emsp;将生成的jar包放在ubuntu系统中，打开终端输入命令：1nohup java -jar ***.jar --server.port=8181 &gt;debug.log 2&gt;&amp;1 &amp; &emsp;&emsp;nohup表示一直运行，--server.port=8181表示开启服务器端的端口号，debug.log为日志文件，可以查看报错信息等。","categories":[{"name":"Web开发与应用","slug":"Web开发与应用","permalink":"http://cxx0822.github.io/categories/Web开发与应用/"}],"tags":[]},{"title":"医疗机器人：语音系统","slug":"医疗机器人：语音系统","date":"2020-08-04T00:30:33.000Z","updated":"2022-03-30T00:57:41.927Z","comments":true,"path":"2020/08/04/yi-liao-ji-qi-ren-yu-yin-xi-tong/","link":"","permalink":"http://cxx0822.github.io/2020/08/04/yi-liao-ji-qi-ren-yu-yin-xi-tong/","excerpt":"","text":"平台&emsp;&emsp;Windows/Ubuntu系统&emsp;&emsp;科大讯飞开发套件iFLYOSMT8516开发套件&emsp;&emsp;讯飞开发平台&emsp;&emsp;python 开发套件iFLYOS MT8516&emsp;&emsp;MT8516开发套件是一款基于MTK平台MT8516处理器和科大讯飞环形 6麦阵列结构的语音整体解决方案。此外还提供红外、串口、ZigBee等多种接口，小巧易扩展，搭载iFLYOS生态，提供海量内容服务与定制化接口，满足多种远、近场语音交互场景。 硬件系统硬件构成和产品&emsp;&emsp;整个开发套件分为三部分，最上面一层为功能按键和LED灯板，主要提供MIC禁音键、播放/暂停键、音量键及LED灯效。中间一层为核心开发板，主要包括一个MT8516A芯片和环形6颗麦克风阵列。最下面一层主要包括一个扬声器、配网按键和电源接口(Type-C)。 核心板——MT8516A&emsp;&emsp;MT8516是联发科技在2017年5月推出的一款面向智能语音助手设备和智能音响的系统单芯片。支持多达8个TDM通道和2个PDM输入，以支持来自多个源的音频输入，适用于远场麦克风语音控制和智能音响设备。&emsp;&emsp;其系统设计框图为：&emsp;&emsp;蓝色部分为按键和LED灯模块。绿色部分为外设模块，主要包括6个麦克风和1个扬声器。其中AMIC为麦克风，4Ω5W为扬声器。黄色部分为电源模块。&emsp;&emsp;最下角的2个模块分别为外置128/256MB DDR3和外置128/256MB FLASH内存。 麦克风——环形6颗麦克风阵列&emsp;&emsp;产品特性： 远/近场拾音&emsp;&emsp;方案前端采用科大讯飞6麦克风阵列，能够实现家居场景5-10m左右的用户指令音频拾取，通过新一代神 经网络降噪算法对拾取音频进行处理，提供高品质降噪后音频给到后端，以保障唤醒、识别效果。 噪声抑制&emsp;&emsp;该功能基于科大讯飞6麦克风阵列中的声源定位和波束增强等算法特性，通过采集指令声源（控制设备 的发音人）所在波束范围内的声音，抑制或者不处理其它波束所接收的声音，以提升采集声音的效果，为后续唤醒和命令词识别效果提供保障。 回声消除&emsp;&emsp;支持用户交互过程中，实现一次唤醒，多轮交互的控制方式，即用户可以中断播报进程进行下一轮交互，让交互更加自然，流畅。 软件系统快速使用 下载小飞在线APP并登录，下载地址。 长按设备配网键5秒，听到语音和黄色呼吸灯提示后松手，进入配网模式。 在小飞在线APP点击添加设备，点击连接。(需要打开蓝牙、网络和定位) 输入网络账号密码，等待设备联网即可。 完成设备联网后，可以说蓝小飞，***进行语音交互。 二次开发环境搭建&emsp;&emsp;下载MTK8516交叉编译工具链&emsp;&emsp;解压缩工具链，如果系统没有7z，请先安装，安装方式：1sudo apt-get install p7zip &emsp;&emsp;解压：17z x yocto_toolchain_7.3.7z &emsp;&emsp;安装：1chmod +x oecore-x86_64-aarch64-toolchain-nodistro.0.sh 1./oecore-x86_64-aarch64-toolchain-nodistro.0.sh &emsp;&emsp;推荐安装目录为：/etc/iflyosBoards/mtk8516，等待安装完成。&emsp;&emsp;设置环境变量：1source /etc/iflyosBoards/mtk8516/environment-setup-aarch64-poky-linux &emsp;&emsp;安装第三方库：地址&emsp;&emsp;复制到安装目录下的sysroot目录：1mv /***/lib/* /etc/iflyosBoards/mtk8516/sysroots/aarch64-poky-linux/usr/lib/ 1mv /***/lib64/* /etc/iflyosBoards/mtk8516/sysroots/aarch64-poky-linux/usr/lib64/ 下载开源工程项目&emsp;&emsp;MTK8516开发套件已经内置了工程项目，可以不用下载，但如果想在电脑上看看也可以下载到本地。&emsp;&emsp;解压后目录如下：123build_mt8516.shjsruntimesmartSpeakerApp &emsp;&emsp;编译1source build_mt8516.sh &emsp;&emsp;目标文件目录: /etc/iflyosBoards/mtk8516-edu/install1234567/etc/iflyosBoards/mt8516-edu/install├── bin│ └── iotjs #jsruntime可执行程序├── iFLYOS.json #主程序启动配置文件├── lib│ └── libiotjs.so #jsruntime库├── smartSpeakerApp #js应用层文件目录 部署&emsp;&emsp;MTK8516开发套件本质上是一个Liunx系统，可以使用adb工具对其进行简单的调试。&emsp;&emsp;adb工具即Android Debug Bridge(安卓调试桥)tools。它就是一个命令行窗口，用于通过电脑端与模拟器或者真实设备交互。&emsp;&emsp;连接至电脑端并输入adb shell即可进入该设备。执行简单的cd和ls命令即可查看里面的文件。&emsp;&emsp;adb工具有2个比较重要的文件传输命令，即adb push sourcefile targetfile和adb pull sourcefile targetfile，一个是将本地文件发送至设备，一个是将设备文件拉取至本地。&emsp;&emsp;例如将设备里面的配置文件信息拉取至本地：1adb pull /data/iflyos/iFLYOS.json &lt;保存本地路径&gt; &emsp;&emsp;然后打开文件即可。&emsp;&emsp;通常，可以先将需要更改的文件先拉取至本地，然后再发送至设备即可。 自定义唤醒词 生成唤醒词资源&emsp;&emsp;登录唤醒词平台，输入唤醒词并下载，引擎版本为1566。 修改唤醒词资源&emsp;&emsp;将生成好的唤醒词，push到/usr/share/iflyos/ivw/目录下，并在/data/iflyos/iFLYOS.json里修改caeResPath的对应资源路径。&emsp;&emsp;替换完成后，执行adb shell sync生效。&emsp;&emsp;断点重开即可查看效果。 更换提示音&emsp;&emsp;在TTS合成页面选择对应的发音人，生成专属开机欢迎语，推送至设备即可替换。&emsp;&emsp;注： 设备的音频文件位置为：/usr/share/iflyos/ring 完成替换后需执行adb shell sync命令生效 注意音频文件需转换为m4a格式 替换ring目录下的音频后，需保持音频文件名前后一致 云端操作系统——iFLYOS&emsp;&emsp;iFLYOS MT8516套件是通过EVS协议与iFLYOS服务端通信实现语音交互和技能调用的。MTK8516套件基于iotjs开发平台实现了与硬件、网络与文件系统等进行交互的能力，并使用JS语言完成了EVS协议逻辑。&emsp;&emsp;iFLYOS是科大讯飞基于人机智能交互技术为广大开发者和第三方厂商开放的全新语音技术服务操作系统。通过先进的人工智能技术让用户的日常生活更方便，获取信息的方式更快捷。&emsp;&emsp;嵌入式协议(Embedded iFLYOS Voice Service， 简称EVS)是一个相对IVS更简单的协议，为厂商接入提供方便，降低设备运行要求，本协议采取websocket进行通讯。&emsp;&emsp;iotjs是三星开源的javascript物联网开发平台。它为javascript应用程序提供了访问硬件、网络、文件系统和异步化的能力，功能类似于nodejs，但无论是代码体积还是内存需求，iotjs都要小很多，是用javascript开发iot(Internet of Things)设备应用程序的首选。 创建设备&emsp;&emsp;打开并登录科大讯飞iFLYOS系统，选择设备接入并添加产品。这里选择linux平台和EVS网络协议。&emsp;&emsp;注：这里的产品信息为自定义名字。 新增技能&emsp;&emsp;选择云端配置-&gt;设备能力，找到更多能力，将持续交互能力和儿童模式打开即可。 发布到设备&emsp;&emsp;将MTK8516开发套件的配置文件(/data/iflyos/iFLYOS.json)拉取到本地，将里面的cliend_id和cliend_secret更改为新建设备的信息。并发送至开发套件。&emsp;&emsp;执行adb shell sync并断电重开。&emsp;&emsp;重新进入配网模式，打开手机小飞在线APP，重新配置，并打开里面的持续交互能力和儿童模式功能。&emsp;&emsp;注：第一次发布可能会出现需要授权的问题。选择产品发布-&gt;设备ID，找到鉴权失败设备，然后将设备导入授权即可。 自定义问答&emsp;&emsp;选择云端配置-&gt;语义理解找到自定义问答，再点击创建自定义问答，然后新建问答库。其模板格式如下：&emsp;&emsp;该技能不需要发布到设备，联网即可。 讯飞开发平台&emsp;&emsp;第一部分介绍的是MTK8516开发套件的使用，但其更多的是用于娱乐型的交互，如果需要任务型的交互，还需要使用科大讯飞的开发平台。&emsp;&emsp;打开讯飞开发平台，点击产品服务，可以看到讯飞开发平台提供了很多易操作的服务功能。 创建控制台&emsp;&emsp;点击控制台，创建新应用。 实时语音转写&emsp;&emsp;选择语音识别-&gt;实时语音转写，找到实时语音转写API，点击并打开文档。&emsp;&emsp;实时语音转写(Real-time ASR)基于深度全序列卷积神经网络框架，通过WebSocket协议，建立应用与语言转写核心引擎的长连接，开发者可实现将连续的音频流内容，实时识别返回对应的文字流内容。&emsp;&emsp;官方文档已经解释的很清楚了，这里就不多做介绍了。在接口demo里面可以下载官方代码。 AMR小车的语音控制程序逻辑&emsp;&emsp;整体逻辑比较简单，即语音输入控制指令-&gt;小车执行指令-&gt;显示任务信息，二者都是基于web实现通讯。 语音代码逻辑&emsp;&emsp;通过阅读官方文档可以看出，实时语音转写主要包含二个阶段：握手阶段和实时通讯阶段。 环境搭建&emsp;&emsp;本博客采用的python语言编写，需要的库为：websocket==0.2.1，websocket-client==0.56.0，requests等。 初始化12345678910111213141516171819202122232425262728293031323334# -*- encoding:utf-8 -*-# @copyright: Cxximport sys, time, threading# 握手阶段import hashlibimport base64import hmacimport websocketfrom websocket import create_connectionfrom urllib.parse import quote# 实时通讯import jsonimport pyaudioimport datetimefrom datetime import datetime#import logging#logging.basicConfig()class YunYinModule(object): def __init__(self, base_url, app_id, api_key): self.base_url = base_url self.app_id = app_id self.api_key = api_key self.end_tag = \"&#123;\\\"end\\\": true&#125;\" self.isSendByMicro_flag = True self.result_data = \"\" &emsp;&emsp;创建YunYinModule类，语音实时转写需要的设备参数为base_url,app_id和api_key。result_data存放的是处理的数据。 握手阶段12345678910111213141516171819202122232425262728def createSigna(self): # 对baseString进行MD5编码 self.ts = str(int(time.time())) baseString = (self.app_id + self.ts).encode('utf-8') md5 = hashlib.md5() # MD5 md5.update(baseString) baseString = md5.hexdigest() baseString = bytes(baseString, encoding='utf-8') # 进行HmacSHA1加密 apiKey = self.api_key.encode('utf-8') signa = hmac.new(apiKey, baseString, hashlib.sha1).digest() signa = base64.b64encode(signa) signa = str(signa, 'utf-8') return signa def handShake(self): \"\"\" 握手阶段 \"\"\" signa = self.createSigna() self.woShou = create_connection(self.base_url + \"?appid=\" + self.app_id + \"&amp;ts=\" + self.ts + \"&amp;signa=\" + quote(signa)) #result = str(self.woShou.recv()) #print(result) &emsp;&emsp;所谓握手就是网络通讯连接阶段。主要是生成一个signa。这里官方文档解释的很清楚，可自行学习。 实时通讯阶段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def receiveResult(self): \"\"\" 数据接收阶段 \"\"\" try: while (self.woShou.connect and self.isSendByMicro_flag): #while (self.isSendByMicro_flag): result = str(self.woShou.recv()) result_dict = json.loads(result) result_final_data = \"\" if len(result) == 0: print(\"receive result end.\") break else: # 解析结果 if result_dict[\"action\"] == \"started\": print(\"handShake Successfully\") if result_dict[\"action\"] == \"result\": result_json = json.loads(result_dict[\"data\"]) # we为0表示是中间结果 isEndFlag = bool(result_json[\"cn\"][\"st\"][\"rt\"][0][\"ws\"][0][\"we\"]) if isEndFlag is True: result_raw_data = result_json[\"cn\"][\"st\"][\"rt\"] #result_final_data = self.dealWithResultData(result_raw_data) self.dealWithResultData(result_raw_data) return self.result_data except websocket.WebSocketConnectionClosedException: print(\"Error. Receive Result End.\")def dealWithResultData(self, data): \"\"\" 处理数据阶段 \"\"\" self.result_data = \"\" # 清空字符串 for i in data: for x in i[\"ws\"]: w = x[\"cw\"][0][\"w\"] wp = x[\"cw\"][0][\"wp\"] if wp != \"s\": self.result_data += w #print(\"Final Result is\", datetime.now(), \"------&gt;\", self.result_data) if self.result_data.find(\"完毕\") != -1: self.isSendByMicro_flag = False &emsp;&emsp;实时通讯阶段也就是一个数据处理的阶段，WebSocket协议返回的是一个json格式的数据，也就是代码中的result变量，通过解析该变量得到可处理的result_dict数据。&emsp;&emsp;result_dict字典主要包括action、data等部分，其中当action为started时，表示数据开始接收，当action为result时，表示已经接收到数据，并存放在data中。result_json表示的是实际接收到的语音数据。&emsp;&emsp;通过分析该表格可知，当we不为0时，表示的是完整的句子(这里完整的意思是，在接收数据时，并不是说完一句完整的话才会显示结果，而是不间断的实时的输出结果，比如你说我要去南京，实际显示的是我，我要去，我要去南京等多个结果，而我们这里只需要最终的结果即可)。&emsp;&emsp;因此在这里添加了一个判断，确保是最后一个完整的句子，然后将原来打散的字符拼接在一起即可。(实际数据输出时，是按单词一个个打散输出的，可print调试观察)&emsp;&emsp;最后加了一个如果输入完毕，则停止交互。 麦克风输入123456789101112def sendByMicro(self): rate = 16000 # 采样率 format = pyaudio.paInt16 # 采样位数 channels = 1 # 通道数 单声道 chunks = 1280 # 一个缓冲区存放的音频数 p = pyaudio.PyAudio() stream = p.open(rate=rate, format=format, channels=channels, frames_per_buffer=chunks, input=True) # Input：输入流 本例是录制音频流 while self.isSendByMicro_flag: data = stream.read(chunks) self.woShou.send(data) &emsp;&emsp;按照官方文档说明，建议音频流每40ms发送1280字节，采样率为16K。这里需要while循环持续接收语音输入。 AMR小车代码逻辑初始化123456789101112131415161718192021#encoding:utf-8#CopyRight@Cxximport jsonimport requestsimport timeclass MedicalRobotOrder(object): def __init__(self, ServerIP, MapID): self.ServerIP = ServerIP self.MapID = MapID self.isTASK_RECEIVED = False self.isTASK_FINISHED = False self.initParam() def initParam(self): self.urlAddOrder = \"https://\" + self.ServerIP + \":8081/order/addOrder\" self.urlOnlineAmr = \"https://\" + self.ServerIP + \":8081/amr/onlineAmr\" &emsp;&emsp;这里主要涉及到swagger-ui的2个接口，即addOrder和onlineAmr，需要的参数为ServerIP和MapID。 addOrder接口12345678910111213141516171819202122232425262728293031323334353637383940414243def addOrder(self, amrID=\"zerg011\", targetPoint=\"P2\", times=1): \"\"\" 下达任务函数，到达目标点多少次，单目标点 参数： targetPoint：目标点 times：次数，默认为1 返回： True：下达任务成功 False：下达任务失败 \"\"\" headers = &#123; \"Content-Type\": \"application/json; charset=UTF-8\", \"Referer\": self.urlAddOrder, \"User-Agent\": \"Mozilla/5.0 (Windows NT 6.1; WOW64) \" \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36\", &#125; pyload = &#123; \"mapId\": self.MapID, \"amrId\": amrID, \"tasks\": [ #&#123; # \"target\":\"P1\", # \"actions\": [1] #&#125;, &#123; \"target\":targetPoint, \"actions\": [1] &#125;, ] &#125; for a in range(0,times): try: response = requests.post(self.urlAddOrder, data=json.dumps(pyload), headers=headers, timeout=3).text if eval(response)[\"message\"] == \"success\": return True else: return False except requests.exceptions.Timeout: print(\"连接超时，请检查网络\") &emsp;&emsp;该接口是通过web进行通讯，通过requests.pots进行接口调用。这里的heards不需要更改，target参数表示的是地图中的点名称。action表示的是任务类型。其中1指的是休息，2指是充电，4指的是上料，5指的是下料，6指的是拣货。 onlineAmr接口1234567891011121314151617181920212223242526272829303132def checkTaskState(self, amrID): \"\"\" 查看机器人TaskState状态 \"\"\" while(True): robotState = self.checkRobotState(amrID) #print(\"robotState: \", robotState) #time.sleep(1) if (robotState == \"TASK_RECEIVED\") or (self.isTASK_RECEIVED is True): self.isTASK_RECEIVED = True messageList = requests.get(self.urlOnlineAmr).json() amrList = messageList['amrList'] taskState = amrList[0]['taskState'] if taskState == \"TASK_FINISHED\": print(\"taskState:\", taskState) breakdef checkRobotState(self, amrID): \"\"\" 查看机器人RobotState状态 \"\"\" messageList = requests.get(self.urlOnlineAmr).json() amrList = messageList['amrList'] for i in range(len(amrList)): if amrList[i]['robotId'] == amrID: robotState = amrList[i]['robotState'] return robotState &emsp;&emsp;该接口查看的是当前调度信息中所有小车的信息。其参数如图所示： 总代码逻辑1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from mymoving import MedicalRobotOrderfrom myYuYin import YunYinModuleimport yamlimport threadingclass MyMedicalRobot(MedicalRobotOrder, YunYinModule): def __init__(self, ServerIP, MapID, app_id, api_key, base_url): MedicalRobotOrder.__init__(self, ServerIP, MapID) YunYinModule.__init__(self, base_url, app_id, api_key) self.placeToPoint = &#123;\"检验科\":\"P2\"&#125; self.isAddOrder = False yuYinData = \"\" def test(self): self.handShake() thread_send = threading.Thread(target=self.sendByMicro) thread_send.start() while True: yuYinData = self.receiveResult() #print(\"接收到的语音信息为：\", yuYinData) if yuYinData.find(\"完毕\") != -1: print(\"接收完毕，停止发送！\") break else: print(\"接收到的语音信息为：\", yuYinData) if yuYinData.find(\"检验科\") != -1: print(\"现在去检验科。\") targetPoint = self.placeToPoint[\"检验科\"] myAMRID = \"zerg009\" self.isAddOrder = self.addOrder(amrID=myAMRID, targetPoint=targetPoint) if self.isAddOrder: print(\"Add Order Successfully\", \"TargetPoint is: \", targetPoint) checkTaskState(myAmrID) else: print(\"Add Order Failed\") self.isSendByMicro_flag = False break &emsp;&emsp;这里的参数文件为：123456ServerIP : \"192.168.3.18\"MapID : \"213xll730\"app_id : \"5f1a39b3\"api_key : \"d66517a308ba753ebe879506cb95f0c7\"base_url : \"wss://rtasr.xfyun.cn/v1/ws\" &emsp;&emsp;主函数：1234567891011121314if __name__ == \"__main__\": with open(\"param.yml\") as stream: robotParam = yaml.load(stream, Loader=yaml.FullLoader) # python3.6 可能需要去掉 Loader=yaml.FullLoader ServerIP = robotParam['ServerIP'] MapID = robotParam['MapID'] app_id = robotParam['app_id'] api_key = robotParam['api_key'] base_url = robotParam['base_url'] myMedicalRobot = MyMedicalRobot(ServerIP, MapID, app_id, api_key, base_url) myMedicalRobot.test() &emsp;&emsp;首先通过解析参数文件获得参数，然后创建MyMedicalRobot类对象。&emsp;&emsp;由于用户需要不断的输入语音信息，因此需要单独给语音输入开启一个线程，保证能实时获取语音信息。然后通过receiveResult()得到用户输入的语音信息yuYinData，并通过解析语音信息的关键字转换为地图中的信息，最后将该信息发送给小车去执行。","categories":[{"name":"医疗服务机器人","slug":"医疗服务机器人","permalink":"http://cxx0822.github.io/categories/医疗服务机器人/"}],"tags":[]},{"title":"制作系统启动盘","slug":"制作系统启动盘","date":"2020-06-27T01:51:11.000Z","updated":"2022-03-21T06:19:12.738Z","comments":true,"path":"2020/06/27/zhi-zuo-xi-tong-qi-dong-pan/","link":"","permalink":"http://cxx0822.github.io/2020/06/27/zhi-zuo-xi-tong-qi-dong-pan/","excerpt":"","text":"软件&emsp;&emsp;镜像工具：UltraISO软碟通&emsp;&emsp;分区工具：Diskgenius&emsp;&emsp;制作多系统盘工具：WinSetupFromUSB 硬件&emsp;&emsp;空U盘，最好是USB3.0及以上，32G及以上的U盘。 U盘分区&emsp;&emsp;除了部分PE系统在制作时会自动将U盘分区，即将U盘分为系统盘和普通盘(不做系统时可以当普通U盘用，做系统时当系统盘用)，其他制作系统盘工具都是将整块U盘当系统盘使用，如果U盘空间很大势必会造成一定程度的浪费，因此，建议除了制作PE系统时，可以先将U盘分区。&emsp;&emsp;首先打开Diskgenius软件，找到U盘，并右击删除当前分区。&emsp;&emsp;然后右击选择建立新分区，这里选择NIFS格式，并自行选择容量。然后再重复执行操作，直到U盘分完为止。&emsp;&emsp;最后点击左上角保存更改即可。 制作单系统盘&emsp;&emsp;打开UltraISO软碟通工具，选择文件-&gt;打开，选择iso镜像文件，然后选择启动-&gt;写入硬盘映像，制作系统盘：&emsp;&emsp;这里的硬盘驱动器如果之前分过区的，可以选择系统盘那个分区。&emsp;&emsp;该方式适用于任何系统的制作，包括windows、Ubuntu和PE系统等，也是目前我觉得最稳定的一种方式。但是唯一的缺点就是比较费U盘，特别是需要安装多个系统的时候，得准备好几块U盘。 U盘启动&emsp;&emsp;系统盘做好后，就要选择U盘启动安装系统，这里要注意的是要先将电脑安全模式关闭，然后将启动项设置为U盘为第一启动项。&emsp;&emsp;常见电脑的启动项热键： Window镜像&emsp;&emsp;网上Window镜像非常多，但是纯净的镜像却比较少，一个好的镜像直接决定着系统的稳不稳定，这里推荐一个最官方最原始的镜像下载方式————直接从官网下载！&emsp;&emsp;打开官网地址：Windows官网镜像下载。打开网页后并不是原始镜像下载地址，而是Windows自带的系统启动盘制作工具，这种方式也是十分简单的，下载后按照步骤制作即可。&emsp;&emsp;如果想要下载官方的原始镜像，需要打开浏览器的开发模式，例如如果是谷歌浏览器，按下F12，并选择ipad Pro，然后刷新，即可看到下载选项： 制作PE系统&emsp;&emsp;如上所示，如果需要安装多系统，那么就需要准备好几块U盘，这势必是不能接受的。因此，我们可以安装一个PE系统，并将系统镜像都放在U盘非系统盘分区中，这样一块U盘就可以安装很多系统。&emsp;&emsp;网上的PE系统很多，但很多都自带很多插件，不是纯净版的。这里推荐一个比较好用且纯净的PE：微PE&emsp;&emsp;打开该软件，选择其他安装方式中的安装到U盘，然后选择u盘安装即可。&emsp;&emsp;注：这里的U盘就不要分区了，因为微PE会自动帮你分区。&emsp;&emsp;安装完我们可以发现，U盘被分为2个区，一个是系统盘，另一个是普通盘，因此，可以将windows系统的镜像文件放入普通盘中，然后在进入微PE安装系统时，选择相应的镜像文件即可安装不同系统，这样一块U盘就可以安装不同的操作系统。&emsp;&emsp;注1：微PE安装Windows操作系统&emsp;&emsp;注2：打开Windows镜像时，点击setup.exe直接安装即可，这种也是最纯净的安装方法。&emsp;&emsp;该方法适用于多Windows系统安装，因为Ubuntu系统并没有setup.exe文件，因此无法采用这种方式安装。 制作多PE，多启动系统&emsp;&emsp;那有没有一种方式，可以将很多个Windows、Ubuntu和PE系统安装在同一个U盘，还能平时做普通盘用呢？&emsp;&emsp;答案肯定是有的。操作方法也十分简单。&emsp;&emsp;打开WinSetupFromUSB，依次选择U盘和镜像即可。&emsp;&emsp;注1：第一次制作时，可以选择Auto Format进行格式化，如果镜像大于4G及以上，选择NIFS格式的，windows7及以上镜像选择第二个，Ubuntu及PE镜像选择第4个。制作完后如需添加就继续打开软件添加即可(每一次每一项只能添加一个)。&emsp;&emsp;注2：实际测试发现即使对U盘进行分区操作，该软件还是会将系统装到整块U盘里。因此需要对分区的U盘进行简单的处理：&emsp;&emsp;右击我的电脑-&gt;管理，找到磁盘管理，然后选择U盘的非系统盘分区，右击选择更改驱动器号及路径，点击删除，即可隐藏。然后再打开软件制作系统盘，最后再执行该操作，选择添加将其显示，并执行相同的操作将系统盘隐藏。(没看明白的可以百度下如何隐藏Windows盘符隐藏盘符)&emsp;&emsp;注3：当然除了该软件，还有类似于YUMI等其他多系统启动盘制作工具，经过大量的测试，还是这一款软件相对稳定一点。&emsp;&emsp;注4：安装win7时需要USB2.0的U盘。","categories":[{"name":"杂项","slug":"杂项","permalink":"http://cxx0822.github.io/categories/杂项/"}],"tags":[]},{"title":"深度学习配置GPU环境","slug":"深度学习配置GPU环境","date":"2020-06-13T01:16:57.000Z","updated":"2022-03-21T06:19:13.026Z","comments":true,"path":"2020/06/13/shen-du-xue-xi-pei-zhi-gpu-huan-jing/","link":"","permalink":"http://cxx0822.github.io/2020/06/13/shen-du-xue-xi-pei-zhi-gpu-huan-jing/","excerpt":"","text":"平台&emsp;&emsp;Ubuntu系统 注意事项&emsp;&emsp;配置环境前，请务必检查NVIDIA,CUDA,cudnn和pytorch(gpu),tensorflow(gpu)等之间的正确版本关系！ 安装NVIDIA驱动安装&emsp;&emsp;现在软件与更新-&gt;选择附加驱动中查找驱动，如果有满足的版本，直接安装重启即可。如果没有，按照以下步骤安装。 &emsp;&emsp;卸载已有的nvidia显卡驱动(如果已安装的话)1sudo apt remove --purge nvidia* &emsp;&emsp;添加ppa源1sudo add-apt-repository ppa:graphics-drivers/ppa &emsp;&emsp;更新源列表1sudo apt update &emsp;&emsp;查看可安装的驱动列表1ubuntu-drivers devices &emsp;&emsp;安装nvidia显卡驱动1sudo apt install nvidia-driver-430 # 驱动型号自己修改，要和下面的CUDN匹配！ &emsp;&emsp;重启电脑生效1sudo reboot 查看是否安装成功12nvidia-smi # 检查nvidia显卡的相关信息nvidia-settings # 查看nvidia设置面板 安装后存在的问题&emsp;&emsp;显卡安装后可能会存在一定的问题，可百度自行解决。 安装CUDA&emsp;&emsp;CUDA是NVIDIA推出的用于自家GPU的并行计算框架，也就是说CUDA只能在NVIDIA的GPU上运行，而且只有当要解决的计算问题是可以大量并行计算的时候才能发挥CUDA的作用。&emsp;&emsp;下载地址&emsp;&emsp;CUDA的版本要和NVIDIA版本一致，具体可参考官网说明 &emsp;&emsp;下载完成后，执行命令安装：1sudo sh cuda_**_linux.run # 换成自己的版本号 &emsp;&emsp;按住空格快读阅读。&emsp;&emsp;根据提示选择安装事项，注意询问是否安装显卡驱动(driver)时一定要选择no！(10.1更新了界面，没有X表示不安装)。实际安装时请稍微等待一会。&emsp;&emsp;添加环境变量：1sudo gedit ~/.bashrc &emsp;&emsp;在最后添加以下内容：12export PATH=/usr/local/cuda-10.1/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH &emsp;&emsp;刷新环境变量，使其生效：1source ~/.bashrc &emsp;&emsp;进入/usr/local/cuda-10.1/samples/1_Utilities/目录：123cd deviceQuerysudo make./deviceQuery &emsp;&emsp;不报错即可。 安装cudnn&emsp;&emsp;cuDNN(CUDA Deep Neural Network library)：是NVIDIA打造的针对深度神经网络的加速库，是一个用于深层神经网络的GPU加速库。如果你要用GPU训练模型，cuDNN不是必须的，但是一般会采用这个加速库。&emsp;&emsp;下载地址&emsp;&emsp;选择对应版本的Linux选项。&emsp;&emsp;下载后解压文件夹，如果后缀不是tgz，自己改一下。&emsp;&emsp;进入目录，依次执行以下命令：1234sudo cp cuda/include/cudnn.h /usr/local/cuda-10.1/includesudo cp cuda/lib64/libcudnn* /usr/local/cuda-10.1/lib64sudo chmod a+r /usr/local/cuda-10.1/include/cudnn.h sudo chmod a+r /usr/local/cuda-10.1/lib64/libcudnn* &emsp;&emsp;查看是否安装成功：1cat /usr/local/cuda-10.1/include/cudnn.h | grep CUDNN_MAJOR -A 2 参考博客NVIDIA驱动 配置mmdetection环境mmdetection&emsp;&emsp;mmdetection是商汤和港中文大学联合开源的基于PyTorch的对象检测工具包，属于香港中文大学多媒体实验室open-mmlab项目的一部分。该工具包提供了已公开发表的多种流行的检测组件，通过这些组件的组合可以迅速搭建出各种检测框架。 所需平台&emsp;&emsp;Annoconda3&emsp;&emsp;Ubuntu18.04&emsp;&emsp;python3.7&emsp;&emsp;pytorch1.4&emsp;&emsp;注：截至目前(2020.6.24)官网只支持1.4及以下的pytorch版本。 安装Annoconda&emsp;&emsp;下载Annoconda，清华大学开源软件镜像站&emsp;&emsp;安装Annoconda：1bash Anaconda3-5.2.0-Linux-x86_64.sh &emsp;&emsp;一路输入yes即可。最后一个提示信息Do you wish to proceed with the installation of Microsoft VSCode? [yes|no]，可以输入no。&emsp;&emsp;添加环境变量，依次执行：123sudo gedit ~/.bashrcexport PATH=\"/home/xupp/anaconda3/bin:$PATH\"source ~/.bashrc &emsp;&emsp;参考博客Ubuntu18.04安装Anaconda3 安装mmdetection&emsp;&emsp;官网安装步骤&emsp;&emsp;正式安装前，可以先把pip和conda的源换一下。 Ubuntu中pip换源&emsp;&emsp;创建目录：1sudo mkdir ~/.pip &emsp;&emsp;新建并打开文件：1sudo gedit ~/.pip/pip.conf &emsp;&emsp;输入以下内容：1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple/ [install]trusted-host = pypi.tuna.tsinghua.edu.cn Ubuntu中conda换源&emsp;&emsp;清华开源软件镜像站&emsp;&emsp;新建并打开文件：1sudo gedit ~/.condarc &emsp;&emsp;输入以下内容：1234567891011121314151617channels: - defaultsshow_channel_urls: truechannel_alias: https://mirrors.tuna.tsinghua.edu.cn/anacondadefault_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud &emsp;&emsp;清除索引缓存：1conda clean -i 创建conda虚拟环境并激活12conda create -n open-mmlab python=3.7 -yconda activate open-mmlab &emsp;&emsp;注意自己的python版本，open-mmlab可以更改为自己的名字。 安装PyTorch和torchvision&emsp;&emsp;这一步很关键，先确定好自己的cuda版本，然后一定要保证pytorch版本不能高于1.5。&emsp;&emsp;例如：1conda install pytorch=1.4 cudatoolkit=10.1 torchvision -c pytorch &emsp;&emsp;这里-c pytorch要加上。换完conda源后下载速度还是挺快的。(用有线或者手机热点试试，哪个快用哪个，下面的pip安装也是) 下载mmdetection源代码12git clone https://github.com/open-mmlab/mmdetection.gitcd mmdetection &emsp;&emsp;有线，手机热点哪个快用哪个，换过源的下载速度是很快的。 安装编译环境12pip install -r requirements/build.txtpip install \"git+https://github.com/open-mmlab/cocoapi.git#subdirectory=pycocotools\" 编译安装1pip install -v -e . # or \"python setup.py develop\" &emsp;&emsp;如果这里报错了，请检查自己的显卡驱动、cuda版本和pytorch版本是否匹配。(PyTorch需要1.4及以下)&emsp;&emsp;编译时间较长，耐心等待。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://cxx0822.github.io/categories/深度学习/"}],"tags":[]},{"title":"AMR小车简单使用","slug":"AMR小车简单使用","date":"2020-05-24T04:19:55.000Z","updated":"2022-03-21T06:19:12.405Z","comments":true,"path":"2020/05/24/amr-xiao-che-jian-dan-shi-yong/","link":"","permalink":"http://cxx0822.github.io/2020/05/24/amr-xiao-che-jian-dan-shi-yong/","excerpt":"","text":"平台&emsp;&emsp;AMR003&emsp;&emsp;Ubuntu18.04&emsp;&emsp;ROS Melodic&emsp;&emsp;PC 环境配置安装Ubuntu18.04&emsp;&emsp;详见其他博客。 安装ROS Melodic&emsp;&emsp;详见其他博客。 局域网配置&emsp;&emsp;AMR(工控机)需要和PC(服务器)(以下均使用英文简称)处在同一个局域网，如果是第一次连接，需要进行简单的配置。 安装串口通讯软件minicom&emsp;&emsp;没有局域网时，可以使用串口通讯进入AMR。&emsp;&emsp;minicom是一个串口通信工具，就像Windows下的超级终端，可用来与串口设备通信，并可以以root权限登录系统。 安装&emsp;&emsp;打开终端输入sudo apt-get install minicom即可。 配置&emsp;&emsp;第一次连接需要进行简单的串口配置。输入命令：1sudo minicom -s &emsp;&emsp;选择serial port setup：&emsp;&emsp;将Serial Device更改为/dev/ttyUSB0(可以通过命令确定是不是USB0)，Bps/Par/Bits更改为115200 8N1，将Hardware Flow Control更改为no。 登录&emsp;&emsp;输入指令即可进入AMR工控机：1sudo minicom &emsp;&emsp;按下确定，然后输入用户名和密码即可。&emsp;&emsp;注：如果出错或者没反映，请检查串口是否正确！ 退出&emsp;&emsp;依次输入ctrl+A，q即可退出。 修改局域网名称&emsp;&emsp;利用串口通讯软件进入AMR，并打开AMR的/etc/wpa_supplicant/wpa_supplicant.conf文件(没有则新建)，修改内容如下：12345678ctrl_interface=/var/run/wpa_supplicantupdate_config=1 # 自动读取配置network=&#123;ssid=\"WIFI-Name\" # WIFI名称psk=\"WIFI-Password\" # WIFI密码key_mgmt=WPA-PSK # 加密方式， 为NONE表示不加密&#125; &emsp;&emsp;然后重启AMR，并再次利用串口通讯软件进入AMR，查看IP信息，也可以进入局域网后台查看。&emsp;&emsp;注：zerg工控机里面一个局域网zerg，密码为123456789。 登录AMR&emsp;&emsp;后续进入AMR工控机则可以利用ssh远程命令登录：1ssh zerg@AMR_IP &emsp;&emsp;要保证AMR和PC在一个局域网。&emsp;&emsp;注：重装完系统后，要将之前建立的局域网信息清除掉：1ssh-keygen -R \"targetIP\" SLAM建图环境配置参数配置&emsp;&emsp;首先将hontai文件夹放置在PC的根目录下(不要放置在Home文件夹)，然后打开/hontai/params/studio.ini配置文件，修改uuid和IP地址：&emsp;&emsp;其中uuid为机器人型号，本博客使用的是zerg003，修改[Comm2]中的host为PC的IP地址。&emsp;&emsp;然后进入AMR终端，打开/hontai/params/config_site.ini配置文件，修改uuid和IP地址：&emsp;&emsp;其中uuid和PC保持一致，serverIp为PC的IP的地址。(这里图片地址错了)&emsp;&emsp;注：AMR中的文件只能用vim编译器打开编译。 开始建图&emsp;&emsp;ARM端在/hontai目录，执行start.sh脚本文件：1./start.sh &emsp;&emsp;此时，AMR会播放语音提示：正在重定位。&emsp;&emsp;同时PC端在/hontai目录，执行openStudio.sh脚本文件：1./openStudio.sh &emsp;&emsp;打开后会出现地图界面，会显示目前的点云数据。&emsp;&emsp;注：如果没有显示点云数据，请检查studio.ini和config_site.ini配置文中的IP地址是否正确！&emsp;&emsp;然后点击地图界面中的Slam按钮会正式开始建图，PC端的终端窗口也会有Start Slam信息提示。&emsp;&emsp;然后将左右两边的急停按钮关闭(向外拨开)，即可正式进入建图！&emsp;&emsp;按下shift会停止移动，上下左右控制方向，连续按下上下左右可以调整速度。&emsp;&emsp;扫描完区域后，再次点击Slam即可关闭建图，然后等2分钟左右，进入AMR的/hontai/log/mapBuilder/文件夹就可以看到刚才生成的地图(后缀为.map的文件)。 拷贝地图&emsp;&emsp;创建的地图是保存在AMR中，无法使用地图编辑软件编辑，需要将其复制到PC中。&emsp;&emsp;这里需要使用ssh中的scp命令，首先需要安装服务模块：1sudo apt-get install ssh openssh-server &emsp;&emsp;其使用方式为：1scp local_file remote_username@remote_ip:remote_file 编辑地图&emsp;&emsp;打开mapEditor中的index，选择文件-&gt;打开即可看到刚才建立的地图。&emsp;&emsp;地图的编辑主要分为2个部分，第一个是使用清除或者橡皮擦工具将建图中的杂质去掉，某些边界不清楚的地方可以使用绘制点云工具添加边界。第二个部分为确定工作路径。&emsp;&emsp;找到绘制点云工具下面的圆点，选择里面的路径点，然后在地图区域选择你所需要的位置，例如我在地图中设置一个来回跑的矩形路径，分别在相应位置设置了4个路径点，然后点击路径工具将两个路径点连接。&emsp;&emsp;一般情况下，任意两个路径点的间距要小于1.2米，因此如果大于此间距，需要在中间插入点，例如，我在路径A到B之间要插入点，选择选择工具，选中AB路径这条线，然后右击选择插入点，设置要插入点的个数，并选择双向路径。其余路径类似。最终设置的效果如图所示：&emsp;&emsp;最后点击文件-&gt;保存即可。&emsp;&emsp;保存完的地图需要复制到PC和AMR中的map文件夹中。(不是复制压缩包，是_.map*4个文件)&emsp;&emsp;注：打开Ubuntu超级文件夹管理器：sudo nautilus。 更改地图参数&emsp;&emsp;在PC的/hontai/params中的studio.ini文件和AMR端的/hontai/params中的config_site.ini文件中的地图参数部分更改为现在的地图名。 调度系统数据库部署数据库管理系统安装&emsp;&emsp;MySQL是一个关系型数据库管理系统，是最流行的关系型数据库管理系统之一，在WEB应用方面，MySQL是最好的RDBMS(Relational Database Management System，关系数据库管理系统) 应用软件之一。&emsp;&emsp;MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。&emsp;&emsp;MySQL所使用的SQL语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库。&emsp;&emsp;安装方法：直接终端安装即可：1sudo apt-get install mysql-server 更改密码&emsp;&emsp;通常默认的mysql的密码是随机的，且十分复杂，需要对其进行更改。&emsp;&emsp;首先输入指令，查看当前密码：1sudo cat /etc/mysql/debian.cnf &emsp;&emsp;其中，mysql_upgrade部分的password就是当前的密码。1mysql -u debian-sys-maint -p &emsp;&emsp;然后输入密码进入更改密码界面。&emsp;&emsp;然后依次输入以下指令：12345use mysql; update mysql.user set authentication_string=password('123') where user='root' and Host ='localhost';update user set plugin=\"mysql_native_password\";flush privileges;quit; &emsp;&emsp;注：指令依次输入，以逗号为分隔，其中123为新密码。&emsp;&emsp;最后重启mysql。1sudo service mysql restart 创建/更新数据库&emsp;&emsp;进入mysql：123mysql -uroot -pcreate database zegtank;quit &emsp;&emsp;导入表：1mysql -uroot -p zegtank &lt; zegtank.sql &emsp;&emsp;验证是否部署完成：1java -jar dis+Tab &emsp;&emsp;不报错即可。 javapro调度部署配置环境&emsp;&emsp;将javapro.zip解压到Home文件夹下，然后打开环境变量文件：1gedit ~/.bashrc &emsp;&emsp;在最后添加以下内容：1234export JAVA_HOME=/home/YourName/javapro/jdk1.8.0_151export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JAVA_HOME&#125;/jre/libexport PATH=.:$&#123;JAVA_HOME&#125;/bin:$PATHexport CATALINA_HOME=/home/YourName/javapro/apache-tomcat-8.5.29 &emsp;&emsp;注：这里的YourName需改为PC的用户名。&emsp;&emsp;刷新环境变量：1source ~/.bashrc &emsp;&emsp;确定安装好Java：1java -version 配置调度&emsp;&emsp;首先开启调度，在javapro文件夹下，输入开启命令：1sh start.sh &emsp;&emsp;然后打开浏览器，输入网址http://PC_IP:8081/swagger-ui.html#，选择/amr/register，将里面的参数设置为zerg小车的：12345678910&#123; \"ability\": 0, \"activate\": true, \"id\": \"uuid\", \"length\": 0.32, \"maxSpeed\": 150.13, \"radius\": 0.32, \"type\":0, \"width\": 0.24&#125; &emsp;&emsp;注意其中的id为之前的uuid。然后点击execute即可。&emsp;&emsp;最后重启调度即可：1sh stop.sh 1sh start.sh &emsp;&emsp;注：实际过程中如果出错，可以使用ps aux | grep java查看是否开启进程：&emsp;&emsp;这里stop.sh的脚本文件可能会出现错误，只要关闭后，ps aux | grep java显示一个即可。 Web apps部署&emsp;&emsp;将apps.zip解压到Home文件夹下，然后输入开启命令：1sh start.sh &emsp;&emsp;然后打开网址http://PC_IP:5000/#/index，进入Web部署。&emsp;&emsp;注：和javapro类似，apps也可以通过命令查看是否开启： 上传地图&emsp;&emsp;打开mapEditor中的index，进入地图编辑工具，选择文件-&gt;发布至调度，上传至调度中心：&emsp;&emsp;更改其中的调度地址和地图名称，其中调度地址的IP为PC的IP。&emsp;&emsp;打开javapro的调度中心，即可看到地图已经发布至调度中心： 定位&emsp;&emsp;建图完成后，需要重新定位。首先进入AMR端的hontai文件夹，开启激光雷达：1./start.sh &emsp;&emsp;然后进入PC端的hontai文件夹，开启界面：1./openstudio &emsp;&emsp;在界面中点击reloc，并选择重定位点，然后移动小车，使激光雷达的点云数据和地图中一致即可：&emsp;&emsp;同时在AMR中，进入/hontai/param文件夹，修改config_site.ini文件，将里面的relocate_pose数值改为PC中的Robot Pose数值。 发布任务&emsp;&emsp;刷新之前的2个网页界面，在apps调度中心可以看到当前的地图和小车：&emsp;&emsp;点击可以看到小车当前的状态和路径点位置。&emsp;&emsp;注：如果看不到小车或小车位置明显不对，请检查地图位置和重定位点！&emsp;&emsp;点击小车并新建任务，并选择任务并提交，即可看到小车运动。&emsp;&emsp;注：电量不足30%时，小车不会运动。 重装AMR系统制作系统盘准备工具&emsp;&emsp;HDMI显示器及HDMI连接线&emsp;&emsp;键盘鼠标&emsp;&emsp; 正式安装&emsp;&emsp;将启动盘插入AMR的USB口，打开电源，并按Del或F9进入BIOS界面。&emsp;&emsp;进入Boot选项，并选择U盘做为启动项。&emsp;&emsp;重启后会自动进入systemback工具进行镜像制作，选择Boot system installer。&emsp;&emsp;输入用户名：zerg，密码123456，进入U盘系统。&emsp;&emsp;输入startx进入界面。&emsp;&emsp;输入新工控机的用户名和密码。&emsp;&emsp;这里的密码均为123456，用户名除了第一个为Zerg，其他为zerg。&emsp;&emsp;选中原来的盘，将原来的数据删除。&emsp;&emsp;正常应该有2个盘，一个是AMR的硬盘，一个是u盘，选中AMR的硬盘，将数据删除。(实际上只有1个盘点击后会有Delete标记)。&emsp;&emsp;选中新盘(带问号的)，点击add new按钮。&emsp;&emsp;选中新盘，并将Mount point :选择在根目录/下，将左下角勾选后，点击change partition。&emsp;&emsp;点击next进入下一步，选择start镜像拷贝，进入拷贝界面。 安装完操作配置网络配置激光雷达IP","categories":[{"name":"医疗服务机器人","slug":"医疗服务机器人","permalink":"http://cxx0822.github.io/categories/医疗服务机器人/"}],"tags":[]},{"title":"仿人手臂系统设计","slug":"仿人手臂系统设计","date":"2020-05-11T01:15:19.000Z","updated":"2022-03-21T06:19:12.673Z","comments":true,"path":"2020/05/11/fang-ren-shou-bi-xi-tong-she-ji/","link":"","permalink":"http://cxx0822.github.io/2020/05/11/fang-ren-shou-bi-xi-tong-she-ji/","excerpt":"","text":"概述平台硬件平台&emsp;&emsp;Festo气动人工肌肉&emsp;&emsp;NI数据采集卡及其配套硬件 软件平台&emsp;&emsp;LabVIEW2018 主要硬件介绍&emsp;&emsp;整套系统所需硬件如下： &emsp;&emsp;其中比较重要的有：Festo气动人工肌肉、LabVIEW数据采集卡及其配套硬件和电气比例阀等。 Festo气动人工肌肉&emsp;&emsp;气动人工肌肉驱动器Pneumatic Muscle Actuator, PMA，简称为气动肌肉，是一种以空气为驱动力的拉伸型驱动器。McKibben型的PMA由于其和生物肌肉的运动具有高度的相似性，一直是气动肌肉研究者的首选类型。其中，McKibben型中比较典型的有德国的Festor气动人工肌肉和英国的Shadow气动人工肌肉，本项目主要采用的Festor气动人工肌肉。该气动人工肌肉具有结构紧凑，响应速度快，输出拉力大等优点，可以很好的模拟人体肌肉的性能。详细信息可参考官网Festo气动肌腱。&emsp;&emsp;本项目采用的型号为：DMSP-10-300-AM-AM，即直径为10mm，长度为300mm，两端连接方式均为：Axial connection(轴向连接)，理论最大承受压力为8bar(0.8MPa)。 NI数据采集卡及其配套硬件&emsp;&emsp;数据采集(DAQ)是使用计算机测量电压、电流、温度、压力或声音等电子、物理现象的过程。DAQ系统由传感器、DAQ测量硬件和带有可编程软件的计算机组成。与传统的测量系统相比，基于PC的DAQ系统利用行业标准计算机的处理、生产、显示和连通能力，提供更强大、灵活且具有成本效益的测量解决方案。其系统结构图如图所示： &emsp;&emsp;目前，NI DAQ经过30多年的不断发展，提供了5千万个I/O通道，是最值得用户信赖的基于计算机的测量硬件。创新的DAQ硬件和NI-DAQmx驱动技术提供了更高的精确度和最优的性能(就是太贵了)。&emsp;&emsp;详细信息可参考NI官网：数据采集 &emsp;&emsp;目前，本系统所采用的NI数据采集卡型号为：PXI-6281和PXIe-6353，分别具有2个模拟输出通道和4个模拟输出通道，详细信息可参考官网采集卡型号。&emsp;&emsp;安装方法：将其插入计算机中的PXI或PXIe插槽即可。&emsp;&emsp;除了数据采集卡，还需要缆线和接线盒配套使用，接线盒也叫I/O接线盒，用于将I/O信号连接至插入式DAQ设备(这里指NI采集卡)，而线缆就是连接接线盒和采集卡的屏蔽线。具体如图所示：&emsp;&emsp;详细信息可参考NI官网：接线盒，线缆 电气比例阀&emsp;&emsp;电气比例阀可以通过电气比例信号，实现对压缩空气的无级控制(相对于水龙头的作用)。&emsp;&emsp;本项目采用的是日本电气比例阀，型号为：ITV0050-3ML：&emsp;&emsp;其具体含义为：&emsp;&emsp;由于本项目所需电气比例阀较多，所以使用集装式安装，即堆叠在一起，通过上下汇流板固定。&emsp;&emsp;图中①指的是Supply(输入口)，②指的是output(输出口)，③指的是Exhaust(排气口)。 仿人手臂系统设计思想&emsp;&emsp;本系统的主要设计思想来源于实际的人体手臂系统。 人体手臂结构&emsp;&emsp;人体手臂由两骨骼三关节的组织结构构成，即上肢带骨(上臂)和自由上肢骨(下臂)，肩关节、肘关节和腕关节组成。手臂肌肉都统称为人体的上肢肌，其中又具体细分为肩肌、臂肌、前臂肌和手肌四个。&emsp;&emsp;人体手臂肌肉的原理为：首先由神经系统发出一定的控制信号，当肌肉组织接收到该信号后会立即产生一定的效应力，并通过该效应力使得肌肉周围附着的骨骼组织做出相应的运动。 人体手臂运动机理&emsp;&emsp;人体的大部分运动都是通过肌肉的收缩和舒张产生的，而肌肉的收缩运动一般都是发生在关节上的。因此，在人体关节的两侧会存在着两组彼此分离、作用不同的肌肉，一般称为主动肌和拮抗肌，它们彼此相互配合才能实现一个完整的关节动作。&emsp;&emsp;当神经系统产生关节运动的信号时，主动肌会收缩并带动关节肢体产生相应方向的运动，而此时拮抗肌也会同时产生一个与主动肌相反的收缩运动，其作用就是为了克制住主动肌带来的力度和速度，以保证关节肢体能够平稳并适时地停止运动。&emsp;&emsp;例如如上图所示的肱二头肌和肱三头肌就是肱骨两侧的屈伸肌对。这些屈伸肌对通常会以某个复合关节为支点，以杠杆的形式实现相应的内收和伸展动作。&emsp;&emsp;通常会将手臂模型简化为上臂，前臂和手三个部分。而由于手的长度占整体手臂的比例很小，所以一般来说，也可以将前臂和手当成一个部分，最终可以简化为一个二关节的手臂肌肉骨骼模型，如上图左所示。在整个手臂中，存在着若干对肌肉对，为了便于模型的分析与计算，同样可以将其简化为三组比较重要的肌肉对，即分别位于肩关节、肘关节和同时位于两个关节的肌肉对，最终简化的手臂肌肉模型如上图右所示。 仿人手臂系统结构设计&emsp;&emsp;受到上述理论的启发，本系统采用6根Festo气动人工肌肉模拟人体手臂肌肉的输出特性并为关节提供驱动扭矩。由Pro/Engineer三维软件绘制的模具设计图如图所示： 机械结构&emsp;&emsp;该仿人手臂系统一共具有3个关节，即肩关节，肘关节和手臂末端点（手和手腕忽略为末端点）。其中肩关节半固定在金属支架上，中间采用金属法兰盘与气动人工肌肉组相连接，肘关节也采用同样类似的结构搭建而成，但相比肩关节，中间会有2层金属薄片，主要是考虑到要放置相应的传感器。&emsp;&emsp;其中每个金属法兰盘有5个开孔，最中间的开孔通过1根细金属两杆上下穿过以固定气动手臂系统，剩下的位于金属法兰盘周围的4个开孔用于气动肌肉的连接。 运动过程&emsp;&emsp;仿人系统采用纯气动的方式驱动。当系统实际运行时，通过每对气动肌肉的充气和放气来模拟人体手臂的主动-拮抗作用。例如大臂系统通过4根气动肌肉实现肘关节1自由度的旋转运动，其中4根气动肌肉分为2组，分别模拟人体手臂的肱二头肌和肱三头肌的屈伸肌对。每对肌肉中的1根气动肌肉产生拉伸/收缩运动，同时另一根进行相反的收缩/拉伸以防止主动肌过度伸缩。而且每个气动人工肌肉都可以由气动比例阀精确控制进气量，以实现关节的伸展或内收。通过各个关节的相互配合，最终模拟出人体手臂的肌肉协同作用，实现相应的抓取等动作。 仿人手臂系统实际搭建手臂模型系统&emsp;&emsp;实际搭建的仿人手臂系统如图所示。 电路系统&emsp;&emsp;电路系统连接主要指的是电气比例阀、气压传感器、开关电源和接线盒等之间的连接方式。 电路系统总图&emsp;&emsp;电路系统总图如图所示：&emsp;&emsp;首先将气压传感器、压力传感器和气动比例阀的一端分别接入LabVIEW接线盒的模拟输入端和输出端，另一端接入仿人手臂系统，并分别通过电源接线盒供电。然后将LabVIEW接线盒与PC机中的LabVIEW数据采集卡相连，以实现气压传感器、压力传感器的数据通讯。最后将接入仿人手臂系统的角度传感器通过USB连接线接入PC机，以实现角度传感器的数据通讯。&emsp;&emsp;当系统运行时，首先通过气缸给气动比例阀供气，然后运行LabVIEW控制程序，并通过LabVIEW数据采集卡和接线盒将控制信号传入气动比例阀，并使其工作。此时角度传感器、气压传感器和压力传感器会实时检测到仿人手臂系统的工作状态，并通过LabVIEW数据采集卡和接线盒反馈给LabVIEW控制程序，如此循环往复，最终达到期望的效果。&emsp;&emsp;注：目前压力传感器未接入实际系统。(电气比例阀，气动比例阀指的是一个意思，懒得改了) 模拟输入端&emsp;&emsp;模拟输入端和气压传感器相连。接线盒的输入端采用单端接入，即连接AI+和GND。气压传感器的白色接线端为信号线，棕色接线端为正极，蓝色接线端为负极。&emsp;&emsp;连接方式：将AI+(接线盒中的任意一个模拟输入端)与气压传感器的白色接线端相接，GND和下一个待接的GND相接(保证接线盒内的所有的地线都连通即可)。气压传感器的棕色接线端和蓝色接线端分别接入电源接线盒的正极和负极，给气压传感器供电。&emsp;&emsp;注：每个LabVIEW接线盒内要有1根地线与电源接线盒的地线(-V)相接。 模拟输出端&emsp;&emsp;模拟输出端和气动比例阀相连。气动比例阀的白色接线端为信号线，棕色接线端为正极，蓝色接线端为负极。&emsp;&emsp;连接方式：将AO(接线盒中的任意一个模拟输出端)与气动比例阀的白色接线端相接，GND和下一个待接的GND相接(保证接线盒内的所有的地线都连通即可)。气动比例阀的棕色接线端和蓝色接线端分别接入电源接线盒的正极和负极，给气动比例阀供电。 实际接线图&emsp;&emsp;这里的硬件指的是电气比例阀和气压传感器，下同。&emsp;&emsp;这里比较重要的是，每个接线盒内的地线一定要和开关电源的-V相连！不是零地火的地线！&emsp;&emsp;注：开关电源的开关需要购买插头和零地火导线制作。除了信号线建议使用较粗的导线，并注意使用颜色区分。 气动系统&emsp;&emsp;气动系统连接主要指的是气缸、电气比例阀和气动人工肌肉等之间的连接方式。&emsp;&emsp;上面的汇流板中，1口为总输入口，接气缸，3为排气口，不用接。下面的汇流板的1和3口需要堵上。2口为输出口，接每根气动人工肌肉，并用三通阀接入气压传感器。其余部分需堵上。 气缸&emsp;&emsp;开启：①将抽气开关按下，阀门开关闭合。②接通电源。③打开抽气开关(提上去)，气缸开始充气，待气压显示表到达指定气压值时(0.4~0.6MPa)，按下开关。④打开阀门开关，即可出气。&emsp;&emsp;关闭：①关闭阀门开关，停止出气。②拔掉电源，气缸每隔一段时间自动漏气。 传感器系统&emsp;&emsp;目前接入系统的传感器有角度传感器： 基于LabVIEW的PID角度跟踪控制LabVIEW软件安装&emsp;&emsp;本项目采用的是LabVIEW2018，所有程序均在2018下调试通过。&emsp;&emsp;LabVIEW软件下载：LabVIEW2018及其工具包下载(全网最快)。LabVIEW2018 点击即可下载。(下载完需要激活，百度即可)&emsp;&emsp;NI驱动下载，驱动主要包括2个，即与DAQ通讯的NI-DAQmx和与USB通讯的NI-VISA。官网下载地址：NI驱动下载。注：NI的驱动要和LabVIEW的版本号对应，建议安装2018及以上版本。&emsp;&emsp;驱动测试：打开LabVIEW2018启动界面，选择工具-&gt;Measurement &amp; Automation Explorer，点击我的系统-&gt;设备和接口，如果能找到相应的采集卡，则说明配置成功。 LabVIEW前面板设计 LabVIEW程序框图设计控制程序原理&emsp;&emsp;当控制系统每执行一次循环时，首先通过实际的角度值和期望的角度值计算得出控制误差，然后将此误差经过控制器得出其控制律，再将此控制律经过实际控制模型得出各个气动人工肌肉的实际输出力值，并通过气动比例阀精确调整各气动人工肌肉的气压输出，如此循环往复，直至满足期望的控制效果。 手臂模型&emsp;&emsp; $O$点为上臂运动的主动关节。假设整个上臂受到分别沿着$A{1}A{2},B{1}B{2},C{1}C{2},D{1}D{2}$四个方向的拉伸力$F{1},F{2},F{3},F{4}$，则由图可以看出，由气动人工肌肉提供的拉伸力$F{1},F{2},F{3},F{4}$会在以主动关节点$O$处，形成驱动力矩来带动整个上臂的运动。因此，上臂肘关节的旋转运动可以看成是四根拮抗式的气动人工肌肉直线拉伸运动合成而来。通过给定四根气动人工肌肉的输入气压来实时调节其拉伸力和有效长度，在合成的驱动力矩作用下实现关节的转动。&emsp;&emsp;由力矩的计算公式可知，力矩等于转动轴到着力点之间的距离乘上矢量力，即$\\tau =F\\cdot d$ 。因此，上臂肘关节的动力学方程可以表示为： \\tau =F_{2}d_{2}-F_{1}d_{1}+F_{4}d_{4}-F_{3}d_{3}&emsp;&emsp;其中$\\tau$为控制力矩，即控制律，下文的控制器设计部分会解释。$F{i}$为单根气动人工肌肉的输出力，$d{i}$为$F_{i}$对关节转动中心$O$的力臂。具体分别为： F_{i} = P_{i}\\left [ a\\left ( 1-\\epsilon_{i} \\right )^{2} -b \\right ]&emsp;&emsp;其中$P{i}$为输出气压值，$\\epsilon{i}$为收缩率，$a$，$b$为常数，分别为：$a=\\frac{3\\pi D{0}^{2}}{4tan^{2}\\theta {0}}$，$b=\\frac{\\pi D{0}^{2}}{4sin^{2}\\theta {0}}$，$\\theta {0}$，$D {0}$为常数。 d_{i}=rcos\\theta&emsp;&emsp;注：具体公式推导这里不做解释，有兴趣可以看我的论文。 输出气压的理论计算&emsp;&emsp;输出力公式由气压$P$和收缩率$\\epsilon$决定，为了体现仿人手臂系统的拮抗性和仿人性，本项目采用拮抗式运动方式分配气动肌肉的输入气压，即： P_{i}=P_{0}\\pm \\Delta P_{i}&emsp;&emsp;其中$P{i}$为每个气动肌肉的输出气压，$P{0}$为初始气压，$\\Delta P_{i}$为待定偏置气压，$\\pm$表示该气动肌肉是拉伸还是收缩作用。&emsp;&emsp;因此每个气压值可以计算为(这里偷懒直接截图了)：&emsp;&emsp;注：这里这是上臂的推导过程，下臂原理和其类似。 输出气压的实际编程&emsp;&emsp;对于这种设计到大量公式的编程，使用LabVIEW里面的MathScript模块最好不过了(需要单独下载，下载链接见上文)。对于实际的控制系统而已，$P{1}$和$P{3}$应该是随着时间的增加越来越大，也就是不断叠加$\\Delta P{i}$的过程，但增加的幅度会慢慢减小，因为控制律$\\tau$在慢慢减小，然后直到趋于稳定。&emsp;&emsp;实际的LabVIEW程序图如下图所示：&emsp;&emsp;上图表示的是$P{1}$和$P{2}$的输出气压计算过程，其余类似。其中初始气压为0.4MPa。叠加$\\Delta P{i}$的过程通过while循环的移位寄存器实现。具体公式在中间的MathScrip节点中实现。&emsp;&emsp;为了保证气动人工肌肉的安全性，通过设置上下限来保证各个气压的有效范围。其中，由于$\\Delta P{2}$会随着时间会越来越小，甚至趋于0，因此本项目通过设置系数来保证$\\Delta P{2}$减小的趋势。 收缩率的理论计算&emsp;&emsp;收缩率由$\\epsilon =1-\\frac{L}{L_{0}}$，具体公式如下： 收缩率的实际编程&emsp;&emsp;具体编程细节和输出气压类似。 力臂的理论计算&emsp;&emsp;力臂的计算公式比较简单，通过简单的几何分析可知：$d=r \\dot cos\\theta$。 力臂的实际编程 控制器设计离散PID的理论计算&emsp;&emsp;由于整个系统是1000ms运行一次，因此可以看作是一个离散的控制系统，控制变量为肘关节的角度，控制误差为实际角度和期望角之差。其中位置式PID算法控制律如下： u\\left ( t \\right )=K_{p}\\cdot e\\left ( t \\right )+K_{I}\\cdot \\sum_{i=0}^{}e\\left ( i \\right )+K_{D}\\left [ e\\left ( k \\right ) \\right - e\\left ( k-1 \\right )]&emsp;&emsp;这里的$u\\left ( t \\right )$就是上文模型的控制力矩$\\tau$。 离散PID的实际编程&emsp;&emsp;这里的输入有3个，即期望值，第一次实际值和第二次实际值。实际的编程并没有加入积分控制，有兴趣可以自行编写积分控制程序。 传感器设置","categories":[{"name":"毕业论文","slug":"毕业论文","permalink":"http://cxx0822.github.io/categories/毕业论文/"}],"tags":[]},{"title":"Gmapping算法原理及源代码解析","slug":"Gmapping算法原理及源代码解析","date":"2020-05-05T11:15:30.000Z","updated":"2022-03-21T06:19:12.443Z","comments":true,"path":"2020/05/05/gmapping-suan-fa-yuan-li-ji-yuan-dai-ma-jie-xi/","link":"","permalink":"http://cxx0822.github.io/2020/05/05/gmapping-suan-fa-yuan-li-ji-yuan-dai-ma-jie-xi/","excerpt":"","text":"平台&emsp;&emsp;Ubuntu 16.04&emsp;&emsp;ROS Kinetic Kame 建图算法概述&emsp;&emsp;在机器人领域中，比较常见的研究问题包括：建图Mapping、定位Localization和路径规划Path Planning。而同时定位与地图构建Simultaneous Localization and Mapping属于位于定位和建图的交集部分。 建图算法分类&emsp;&emsp;SLAM的具体含义为：搭建特定传感器的主体，在没有环境先验信息的情况下，与运动过程中建立环境的模型，同时估计自己的运动。由此可见，SLAM主要解决两个问题：1.定位：估计传感器自身的位置；2.地图构建：建立周围环境的模型。目前SLAM按照传感器类型可以分为基于视觉传感器的视觉SLAM和基于激光雷达传感器的激光SLAM。由于视觉传感器很受光照的影响，目前主流的建图算法还是基于激光雷达传感器。但不管是哪种传感器，其基本框架大致相同：&emsp;&emsp;由图可见，在传感器信息读取、前端、回环检测和建图这几个模块，目前主流的建图算法都大致相同，而针对后端模块的处理大致可以分为两类：一类是基于滤波器的算法，例如高斯滤波器、直方图滤波器和粒子滤波器等，其基本原理为：通过估计后验概率，递推贝叶斯状态估计来求解机器人路径和地图。另一类为基于图优化的算法，例如非线性最小二乘法、随机梯度下降法等，其基本原理为：将数学模型转化为因子图的方式来求解，通过将位姿描述成节点和将约束关系描述成边以使问题可视化。本博客所探讨的Gmapping建图算法属于基于滤波器的粒子滤波器算法。另一种比较主流的建图算法Cartographer属于基于图优化的算法。 地图&emsp;&emsp;由上图可见，SLAM中的地图有很多种，一般2D的建图算法生成的均为栅格地图。&emsp;&emsp;栅格地图很好理解，就是一张普通的灰度图像，通常为pgm格式。这张图像上的黑色像素表示障碍物，白色像素表示可行区域，灰色是未探索的区域。&emsp;&emsp;在SLAM建图的过程中，你可以在RViz里看到一张地图被逐渐建立起来的过程，类似于一块块拼图被拼接成一张完整的地图。这张地图对于我们定位、路径规划都是不可缺少的信息。事实上，地图在ROS中是以Topic的形式维护和呈现的，这个Topic名称就叫做/map，它的消息类型是nav_msgs/OccupancyGrid。&emsp;&emsp;由于/map中实际上存储的是一张图片，为了减少不必要的开销，这个Topic往往采用锁存(latched)的方式来发布。什么是锁存？其实就是：地图如果没有更新，就维持着上次发布的内容不变，此时如果有新的订阅者订阅消息，这时只会收到一个/map的消息，也就是上次发布的消息；只有地图更新了(比如SLAM又建出来新的地图)，这时/map才会发布新的内容。锁存器的作用就是，将发布者最后一次发布的消息保存下来，然后把它自动发送给后来的订阅者。这种方式非常适合变动较慢、相对固定的数据(例如地图)，然后只发布一次，相比于同样的消息不定的发布，锁存的方式既可以减少通信中对带宽的占用，也可以减少消息资源维护的开销。&emsp;&emsp;注：参考中国大学MOOC—-《机器人操作系统入门》课程讲义，下载地址。 Gmapping算法原理理解Gmapping算法概述&emsp;&emsp;论文下载地址&emsp;&emsp;Gmapping是基于滤波SLAM框架的常用开源SLAM算法。其基本原理基于RBpf粒子滤波算法，即将定位和建图过程分离，先进行定位再进行建图。粒子滤波算法是早期的一种建图算法，其基本原理为机器人不断地通过运动、观测的方式，获取周围环境信息，逐步降低自身位置的不确定度，最终得到准确的定位结果。用上一时刻的地图和运动模型预测当前时刻的位姿，然后计算权重，重采样，更新粒子的地图，如此往复。&emsp;&emsp;Gmapping可以实时构建室内地图，在构建小场景地图所需的计算量较小且精度较高。相比Cartographer在构建小场景地图时，Gmapping不需要太多的粒子并且没有回环检测因此计算量小于Cartographer而精度并没有差太多。Gmapping有效利用了车轮里程计信息，这也是Gmapping对激光雷达频率要求低的原因：里程计可以提供机器人的位姿先验。&emsp;&emsp;随着场景增大所需的粒子增加，因为每个粒子都携带一幅地图，因此在构建大地图时所需内存和计算量都会增加。因此不适合构建大场景地图。并且没有回环检测，因此在回环闭合时可能会造成地图错位，虽然增加粒子数目可以使地图闭合但是以增加计算量和内存为代价。所以不能像Cartographer那样构建大的地图。Gmapping和Cartographer一个是基于滤波框架SLAM另一个是基于优化框架的SLAM，两种算法都涉及到时间复杂度和空间复杂度的权衡。Gmapping牺牲空间复杂度保证时间复杂度，这就造成Gmapping不适合构建大场景地图。 RBpf粒子滤波算法——先定位再建图&emsp;&emsp;SLAM需要解决的是定位与建图问题，而定位需要建图，建图也需要先定位，如何平衡这两者关系就是解决SLAM问题的关键。为此，基于RBpf(Rao-Blackwellized)粒子滤波算法提供了一个思路：先定位再建图，具体如下： P\\left ( x_{1:t},m|z_{1:t},u_{1:t-1} \\right )=P\\left ( x_{1:t}|z_{1:t},u_{1:t-1} \\right ) \\cdot P\\left ( m|x_{1:t} ,z_{1:t}\\right )&emsp;&emsp;其中，$x{1:t}$表示1到t时刻的位姿，m表示地图，$z{1:t}$表示观测值，这里就是激光雷达的值，$u_{1:t-1}$表示运动值，这里就是里程计(IMU)的值。&emsp;&emsp;一般的，SLAM的数学模型可以用上式表示。第一部分表示已知运动值和观测值求出地图和机器人位姿，第二部分表示已知运动值和观测值求出机器人位姿，第三部分为已知位姿和观测值求出地图信息。根据概率论的知识，上式是一个条件联合概率分布，即通过观测值和里程计的值得出位姿和地图，但如果把这2个值都作为条件去求概率会十分困难，而由概率论的知识可知，联合概率可以转换成条件概率，即$P\\left ( x,y \\right )=P\\left ( y|x \\right )\\cdot p\\left ( x \\right )$。因此可以将上式转换为先根据观测值和运动值求出位姿，然后根据观测值和位姿求出地图。这就大大降低了求解的难度。&emsp;&emsp;这看起好像很好，但基于粒子滤波器的算法会存在一些问题：1.精确的地图需要更多的粒子，但同时也会增加计算量和内存消耗；2.频繁执行重采样会造成粒子退化(正确的粒子被丢弃，粒子多样性减小)。&emsp;&emsp;因此，Gmapping算法针对这两个问题，分别进行了改进：改进的提议分布和选择性重采样。 附：SIR(Samping Importance Resampling)粒子滤波算法流程 预测阶段：粒子滤波首先根据状态转移函数预测生成大量的采样，这些采样就称之为粒子，利用这些粒子的加权和来逼近后验概率密度。 校正阶段：随着观测值的依次到达，为每个粒子计算相应的重要性权值。这个权值代表了预测的位姿取第个粒子时获得观测的概率。如此这般下来，对所有粒子都进行这样一个评价，越有可能获得观测的粒子，获得的权重越高。 重采样阶段：根据权值的比例重新分布采样粒子。由于近似逼近连续分布的粒子数量有限，因此这个步骤非常重要。下一轮滤波中，再将重采样过后的粒子集输入到状态转移方程中，就能够获得新的预测粒子了。 地图估计：对于每个采样的粒子，通过其采样的轨迹与观测计算出相应的地图估计。 &emsp;&emsp;SIR算法需要在新的观测值到达时从头评估粒子的权重。当轨迹的长度随着时间的推移而增加时，这个过程的计算复杂度将越来越高。因此Doucet等学者通过式(2)限制重要性概率密度函数来获得递归公式去计算重要性权值。 改进的提议分布参考博客博客1博客2博客3 Gmapping源代码理解&emsp;&emsp;下载完成后，进入src/slam_gmapping/gmapping/src文件夹，打开main.cpp，可以看到gmapping在ros下面定义的一个节点slam_gmapping，该节点也是上节中rosrun命令下的节点。&emsp;&emsp;mian函数比较简单，只是声明了一个节点和一个SlamGMapping类，并调用了该类下面的startLiveSlam()函数，该函数的声明在该文件夹下的slam_gmapping.cpp文件中。下面则正式进入源代码的分析。&emsp;&emsp;注：在正式进入前，需要有一定的ROS基础，具体可参考我的另一篇博客ROS功能包及其应用，也可以百度其他博客学习。 Gmapping源代码框架 startLiveSlam()&emsp;&emsp;该函数的功能为正式开始Slam进程。其代码如下：12345678910111213void SlamGMapping::startLiveSlam()&#123; entropy_publisher_ = private_nh_.advertise&lt;std_msgs::Float64&gt;(\"entropy\", 1, true); sst_ = node_.advertise&lt;nav_msgs::OccupancyGrid&gt;(\"map\", 1, true); sstm_ = node_.advertise&lt;nav_msgs::MapMetaData&gt;(\"map_metadata\", 1, true); ss_ = node_.advertiseService(\"dynamic_map\", &amp;SlamGMapping::mapCallback, this); scan_filter_sub_ = new message_filters::Subscriber&lt;sensor_msgs::LaserScan&gt;(node_, \"scan\", 5); scan_filter_ = new tf::MessageFilter&lt;sensor_msgs::LaserScan&gt;(*scan_filter_sub_, tf_, odom_frame_, 5); scan_filter_-&gt;registerCallback(boost::bind(&amp;SlamGMapping::laserCallback, this, _1)); transform_thread_ = new boost::thread(boost::bind(&amp;SlamGMapping::publishLoop, this, transform_publish_period_));&#125; &emsp;&emsp;该函数整体上为ros中的通讯部分，大致可以分为三部分，第一部分为消息的发布，主要有&lt;std_msgs::Float64&gt;：激光雷达数据序号，&lt;nav_msgs::OccupancyGrid&gt; ：2D栅格图信息， &lt;nav_msgs::MapMetaData&gt;：栅格图特征信息这3个topic信息(具体可以参考官方文档：nav_msgs)和一个服务器信息：dynamic_map：不断更新的动态地图。&emsp;&emsp;第二部分为消息的订阅，这里都是对激光雷达消息&lt;sensor_msgs::LaserScan&gt;的订阅，其中message_filters表示消息过滤器，类似一个消息缓存，当消息到达消息过滤器的时候，可能并不会立即输出，而是在稍后的时间点里满足一定条件下输出。而tf::MessageFilter可以订阅任何的ROS消息，然后将其缓存，直到这些消息可以转换到目标坐标系，然后进行相应的处理(进入回调函数)。tf::MessageFilter的初始化需要message_filters::Subscriber，tf转换，目标坐标系，等待时间。&emsp;&emsp;第三部分为回调函数和线程的启动，其中处理激光雷达和坐标变换的回调函数为laserCallback()，处理完之后会启动发布转换关系的线程publishLoop()。&emsp;&emsp;总而言之，就是发布地图消息，订阅激光雷达数据，并通过回调函数对其进行坐标转换，并启动线程发布该坐标转换，更新地图。因此比较重要的有2个函数：laserCallback()和publishLoop()。 laserCallback()12345678910111213141516171819202122232425262728293031323334353637383940414243444546voidSlamGMapping::laserCallback(const sensor_msgs::LaserScan::ConstPtr&amp; scan)&#123; laser_count_++; if ((laser_count_ % throttle_scans_) != 0) // 判断是否降频 return; static ros::Time last_map_update(0,0); // We can't initialize the mapper until we've got the first scan if(!got_first_scan_) // 判断是否为第一帧，是则进入初始化地图 &#123; if(!initMapper(*scan)) return; got_first_scan_ = true; &#125; GMapping::OrientedPoint odom_pose; if(addScan(*scan, odom_pose)) // 第二帧及以后的数据 &#123; ROS_DEBUG(\"scan processed\"); GMapping::OrientedPoint mpose = gsp_-&gt;getParticles()[gsp_-&gt;getBestParticleIndex()].pose; ROS_DEBUG(\"new best pose: %.3f %.3f %.3f\", mpose.x, mpose.y, mpose.theta); ROS_DEBUG(\"odom pose: %.3f %.3f %.3f\", odom_pose.x, odom_pose.y, odom_pose.theta); ROS_DEBUG(\"correction: %.3f %.3f %.3f\", mpose.x - odom_pose.x, mpose.y - odom_pose.y, mpose.theta - odom_pose.theta); // Transform坐标变换 tf::Transform laser_to_map = tf::Transform(tf::createQuaternionFromRPY(0, 0, mpose.theta), tf::Vector3(mpose.x, mpose.y, 0.0)).inverse(); tf::Transform odom_to_laser = tf::Transform(tf::createQuaternionFromRPY(0, 0, odom_pose.theta), tf::Vector3(odom_pose.x, odom_pose.y, 0.0)); map_to_odom_mutex_.lock(); map_to_odom_ = (odom_to_laser * laser_to_map).inverse(); map_to_odom_mutex_.unlock(); // 如果没有地图则直接更新地图，如果有地图则需要到时间了，才更新地图 if(!got_map_ || (scan-&gt;header.stamp - last_map_update) &gt; map_update_interval_) &#123; updateMap(*scan); last_map_update = scan-&gt;header.stamp; ROS_DEBUG(\"Updated the map\"); &#125; &#125; else ROS_DEBUG(\"cannot process scan\");&#125; &emsp;&emsp;该函数输入参数为之前订阅的消息&lt;sensor_msgs::LaserScan&gt;，没有返回值。&emsp;&emsp;该函数为处理激光雷达数据的回调函数，首先当接收到一帧激光雷达数据时，判断是否为第一帧数据，如果是则调用initMapper()初始化地图，否则调用addScan()将其数据插入到当前的地图中，如果到了地图更新的时间，则会调用updateMap()进行地图更新。 initMapper()&emsp;&emsp;该函数为gmapping算法的初始化，该函数在收到的第一帧激光雷达数据的时候会被调用一次，之后就再也不会被调用了。该函数的功能主要就是对gmapping算法中需要的一些参数进行赋值，即： 判断激光雷达是否是水平放置的，如果不是则报错。 设激光雷达数据的角度是对称的&amp;递增的，为每个激光束分配角度。 为gmapping算法设置各种需要的参数。 &emsp;&emsp;这里代码较长，且大部分为判断激光雷达的初始设置，有兴趣可以阅读参考博客[1-2]。 addScan()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263boolSlamGMapping::addScan(const sensor_msgs::LaserScan&amp; scan, GMapping::OrientedPoint&amp; gmap_pose)&#123; // 得到与激光雷达时间戳相对应的机器人里程计位姿 if(!getOdomPose(gmap_pose, scan.header.stamp)) return false; if(scan.ranges.size() != gsp_laser_beam_count_) return false; // GMapping wants an array of doubles... double* ranges_double = new double[scan.ranges.size()]; // If the angle increment is negative, we have to invert the order of the readings. // 如果激光是反着装的，则激光的顺序需要反过来 if (do_reverse_range_) &#123; ROS_DEBUG(\"Inverting scan\"); int num_ranges = scan.ranges.size(); for(int i=0; i &lt; num_ranges; i++) &#123; // Must filter out short readings, because the mapper won't if(scan.ranges[num_ranges - i - 1] &lt; scan.range_min) ranges_double[i] = (double)scan.range_max; else ranges_double[i] = (double)scan.ranges[num_ranges - i - 1]; &#125; &#125; else &#123; for(unsigned int i=0; i &lt; scan.ranges.size(); i++) &#123; // Must filter out short readings, because the mapper won't if(scan.ranges[i] &lt; scan.range_min) ranges_double[i] = (double)scan.range_max; else ranges_double[i] = (double)scan.ranges[i]; &#125; &#125; // 将ROS的激光雷达的数据信息转换为GMapping算法中的数据格式 GMapping::RangeReading reading(scan.ranges.size(), ranges_double, gsp_laser_, scan.header.stamp.toSec()); // ...but it deep copies them in RangeReading constructor, so we don't // need to keep our array around. delete[] ranges_double; // 设置和激光雷达数据时间戳相匹配的机器人位姿 reading.setPose(gmap_pose); /* ROS_DEBUG(\"scanpose (%.3f): %.3f %.3f %.3f\\n\", scan.header.stamp.toSec(), gmap_pose.x, gmap_pose.y, gmap_pose.theta); */ ROS_DEBUG(\"processing scan\"); // 调用GMapping算法进行处理 return gsp_-&gt;processScan(reading);&#125; &emsp;&emsp;该函数输入参数为之前订阅的消息&lt;sensor_msgs::LaserScan&gt;和自定义的数据类型OrientedPoint，具体定义在openslam_gmapping/include/gmapping/utils/point.h中，表示的是(x,y,$\\theta$)，即当前点的x,y和偏航角。&emsp;&emsp;首先通过getOdomPose()得到与激光雷达时间戳相对应的机器人里程计的位姿，然后将ROS中的激光雷达数据信息转换为Gmapping算法的数据格式，并调用setPose()设置其位姿，最后通过processScan()函数进行处理。&emsp;&emsp;这里除了getOdomPose()是该.cpp文件中的函数，其余均是底层算法openslam_gmapping中的函数。&emsp;&emsp;reading.setPose(gmap_pose);中的reading是GMapping::RangeReading类的实例化，该类的定义位于openslam_gmapping/include/gmapping/sensor/sensor_range/rangereading.h中。&emsp;&emsp;gsp_-&gt;processScan(reading)中的gsp_的声明在slam_gmapping.h中，是GMapping::GridSlamProcessor类的实例化，该类的定义位于openslam_gmapping/include/gmapping/gridfastslam/gridslamprocessor.h。&emsp;&emsp;这里最重要的当然是processScan()这个函数了，这也是整个Gmapping算法最核心的一个函数，这里先暂时跳过该函数，后面再详细介绍。 UpdateMap()processScan()参考博客博客1博客2","categories":[{"name":"SLAM建图算法","slug":"SLAM建图算法","permalink":"http://cxx0822.github.io/categories/SLAM建图算法/"}],"tags":[]},{"title":"ROS功能包及其应用","slug":"ROS功能包及其应用","date":"2020-04-30T05:40:02.000Z","updated":"2022-03-21T06:19:12.545Z","comments":true,"path":"2020/04/30/ros-gong-neng-bao-ji-qi-ying-yong/","link":"","permalink":"http://cxx0822.github.io/2020/04/30/ros-gong-neng-bao-ji-qi-ying-yong/","excerpt":"","text":"平台&emsp;&emsp;Ubuntu16.04&emsp;&emsp;ROS Kinetic Kame 环境配置&emsp;&emsp;具体详见该博客 创建工作空间Work Space&emsp;&emsp;首先创建ROS的工作空间，一般创建在Home目录下，使用命令行或者右击创建文件夹均可。例如，我在Home文件夹下创建一个名为cxx_ws(也可以是其他名字)的工作空间。&emsp;&emsp;然后创建src文件夹，并初始化。123mkdir src cd src catkin_init_workspace &emsp;&emsp;然后回到工作空间，并编译。12cd ..catkin_make &emsp;&emsp;编译完成后，工作空间会新增2个文件夹，build和devel。其中build文件夹为编译空间Build Space，devel为开发空间Development Space。 &emsp;&emsp;注：catkin_make含义：CMake(cross platform make)是一个跨平台的安装(编译)工具，可以用简单的语句来描述所有平台的安装(编译过程)，能够输出各种各样的makefile或者project文件。而catkin_make是cmake的升级版，可以认为是对cmake进一步封装的高级命令。&emsp;&emsp;附：ROS工程文件结构： &emsp;&emsp;添加环境变量1234source devel/setup.bash # 该文件定义了工作空间所需要的环境变量gedit ~/.bashrc # .bashrc类似于windows下的环境变量# source ~/cxx_ws/devel/setup.bash # 在打开的文件中添加该命令source ~/.bashrc 创建功能包package&emsp;&emsp;ROS功能包package指的是一种特定的文件结构和文件夹组成。工程文件夹下的src文件夹由一个个package功能包组成，一个功能包中可以包含一个或多个节点的文件。 创建package&emsp;&emsp;创建功能包的指令为：1catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] &emsp;&emsp;package_name为包名，depend为依赖包名。&emsp;&emsp;进入src文件夹，创建hello功能包。12cd srccatkin_create_pkg hello std_msgs roscpp &emsp;&emsp;回到工作空间并编译：12cd ..catkin_make &emsp;&emsp;注：同一个工作空间下，不允许存在同名功能包，不同工作空间下，允许存在同名功能包。功能包名字只能使用小写字母、数字和下划线，首字符必须是小写字母。&emsp;&emsp;std_msgs包含了常见消息类型。roscpp使用C++实现ROS的各种功能，提供了一个客户端库。&emsp;&emsp;创建完成的功能包一般会自带include、src、CMakeList.txt和package.xml文件。 package详解&emsp;&emsp;通常，一个完整的package由以下几个部分组成： CMakeLists.txt：定义package的包名、依赖、源文件、目标文件等编译规则。 package.xml：描述package的包名、版本号、作者、依赖等信息。 src：存放ROS的源代码，包括.cpp和.py。 include：存放C++源代码对应的头文件。 scirpts：存放可执行脚本文件。 msg：存放自定义格式的消息(.msg)。 srv：存放自定义格式的服务(.srv)。 models：存放机器人或仿真场景的3D模型(.sda,.stl,.dae)。 urdf：存放机器人的模型描述(.urdf,.xacro)。 launch：存放launch文件(.launch,.xml)。通常除了CMakeLists.txt和package.xml是必须的，其他根据需求添加，实际建立工程文件时，都要遵守以上的命名规则。 package.xml&emsp;&emsp;package.xml包含了package的名称、版本号、内容描述、维护人员、软件许可、编译构建工具、编译依赖、运行依赖等信息。文件写法遵循XML标签文本的写法，目前存在两种格式，但内容大致一样。（红色字体的是必备标签） CMakeLists.txt&emsp;&emsp;CMakeList.txt原本是Cmake编译系统的规则文件，ROS的构建系统catkin基本上使用CMake，只是针对ROS工程添加了一些宏定义。因此在写法上CMakeList.txt和Cmake基本一致。CMakeList.txt文件规定了catkin的编译规则，直接规定这个包需要依赖那些package，要编译生成那些目标，如何编译等等流程写法。该文件的基本语法都是按照CMake，只是在其基础上添加了一些宏。 package编译过程&emsp;&emsp;功能包的编译过程也就是catkin的编译过程。 首先在工作空间的src目录下递归的查找每一个ros的package。 因为每一个package中都有package.xml和CMakeList.txt文件，所以catkin编译系统依据CMakeList.txt文件，生成makefile文件，放在工作空间的build文件夹中。 然后make刚刚生成的makefiles等文件，编译链接生成可执行文件，放在工作空间下的devel文件夹中。简而言之，catkin就是将camke和make指令做了一个封装从而完成整个编译过程的工具。 创建ROS节点&emsp;&emsp;一个节点就是ROS下面一个可执行程序，使用ROS可以与其他节点进行通信。 编写Node&emsp;&emsp;Node文件通常放在package下的src文件夹中。&emsp;&emsp;例如在本例中，进入hello文件夹的src文件夹，右击创建一个cpp文件：hello_node.cpp。&emsp;&emsp;打开hello_node.cpp文件，并输入代码：12345678#include &lt;ros/ros.h&gt;int main (int argc, char **argv) &#123; ros::init(argc, argv, \"hello_node\") ; ros::NodeHandle nh; ROS_INFO_STREAM(\"Hello, ROS!\") ;&#125; &emsp;&emsp;#include &lt;ros/ros.h&gt;为声明ROS的标准库。&emsp;&emsp;ros::init(argc, argv, &quot;hello_node&quot;)为ROS初始化节点函数，其调用形式一般为：ros::init(argc, argv, &quot;my_node_name&quot;);。本例中，将node_name取名为hello_node，当然也可以是其他名字。&emsp;&emsp;ros::NodeHandle nh;为ROS启动节点函数。一个ROS的node只有一个NodeHandle，它提供这个node的对于topic的收发功能。&emsp;&emsp;ROS_INFO_STREAM(&quot;Hello, ROS!&quot;) ;打印日志信息，相对于print。 编译Node声明依赖库&emsp;&emsp;依赖库的声明在package.xml中，打开该文件，检查是否所有的依赖库都已安装。(通常，创建package时都会声明好的) 声明可执行文件&emsp;&emsp;打开CMakeLists.txt文件，找到注释掉的Declare a C++ executable声明C++可执行文件这一行，在这一段的最后，按照注释添加声明，在本例中，添加如下命令：(hello_node为可执行文件名字，可以换成其他的，下同)1add_executable(hello_node src/hello_node.cpp) &emsp;&emsp;再往下找到注释掉的Specify libraries to link a library or executable target aginst指定链接库这一行，在这一段的最后，按照注释添加声明，在本例中，添加如下指令：1target_link_libraries(hello_node $&#123;catkin_LIBRARIES&#125;) &emsp;&emsp;修改完成后，回到工作空间文件夹，重新catkin_make编译即可。&emsp;&emsp;编译完成后，会在devel/lib/hello文件夹下生成hello_node可执行文件。&emsp;&emsp;注：这里的hello_node也就是后面rosrun命令中调用的节点名称，也就是CMakeLists文件中 add_executable和target_link_libraries中的名字(这2个名字必须一致)，但和hello_node.cpp文件中定义的节点名称可以不一致。 运行Node&emsp;&emsp;运行指令为：rosrun package-name executable-name，其中package-name为功能包名称，本例中为hello，executable-name为可执行文件名称，即在上文声明可执行文件中的可执行文件名字，在本例中为hello_node，也可以在lib文件夹中找到可执行文件名字(可以反过来使用这个规则，即当程序报错找不到节点时，可以去lib文件夹看一下有没有生成的可执行文件)。&emsp;&emsp;Node节点不能单独单独运行，需要一个节点管理器才能正常运行。&emsp;&emsp;首先在终端输入roscore：启动节点管理器。&emsp;&emsp;然后再打开一个终端，输入运行节点命令：rosrun hello hello_node即可看到打印出来的信息。 创建launch文件&emsp;&emsp;launch文件即启动文件，可以编写很多节点一起启动(rosrun一次只能启动一个节点)，而且也会自动启动roscore命令，在大型工程中使用起来非常方便。 编写launch文件&emsp;&emsp;launch文件一般放在包文件下的launch文件夹下(如没有则新建)，在本例中，在hello包文件夹下新建一个launch文件夹，然后进入该文件夹，新建hello_launch.launch文件。打开并输入以下内容：123&lt;launch&gt; &lt;node pkg=\"hello\" type=\"hello_node\" name=\"hello_launch\" output=\"screen\"/&gt;&lt;/launch&gt; &emsp;&emsp;pkg为package name，即功能包名，本例中为hello，type为executable name，即指向节点的可执行文件的名称，本例中为hello_node。这两个参数也相当于rosrun命令中的2个参数。name为node name，即节点运行的名字，这里会覆盖节点定义中的init()的节点的名称。本例中定义为hello_launch，当然也可以是其他名字。 运行launch文件&emsp;&emsp;启动命令为：roslaunch package-name launch-name，其中package-name为功能包名称，本例中为hello，launch-name为launch文件名称(包括后缀)，在本例中为hello_launch.launch。&emsp;&emsp;打开终端输入rosluanch hello hello_launch.launch即可。&emsp;&emsp;可以看到输出的日志信息。 launch文件解读&emsp;&emsp;launch文件中常用的参数为：&emsp;&emsp;参考博客：解析 roslaunch 文件 ROS中的通讯&emsp;&emsp;ROS是以节点的形式开发的，而节点是根据其目的细分的可执行程序的最小单位。节点通过消息(message)与其他的节点交换数据，最终成为一个大型的程序。这里的关键概念是节点之间的消息通信，它分为三种。单向消息发送/接收方式的话题(topic)；双向消息请求/响应方式的服务(service)；双向消息目标(goal)/结果(result)/反馈(feedback)方式的动作(action)。 Topic in roscpp&emsp;&emsp;Topic(话题)是ROS里一种异步通信的模型，节点间分工明确，有的只负责发送，有的只负责接收处理。对于绝大多数的机器人应用场景，比如传感器数据收发，速度控制指令的收发，Topic模型是最适合的通信方式。ROS中的通信方式中，topic是常用的一种。对于实时性、周期性的消息，使用topic来传输是最佳的选择。topic是一种点对点的单向通信方式，这里的“点”指的是node，也就是说node之间可以通过topic方式来传递信息。&emsp;&emsp;topic要经历下面几步的初始化过程：首先，publisher节点和subscriber节点都要到节点管理器进行注册，然后publisher会发布topic，subscriber在master的指挥下会订阅该topic，从而建立起sub-pub之间的通信。注意整个过程是单向的。 创建Topic消息类型&emsp;&emsp;ros中自带很多种topic类型(可以在/ros/kinect/share中带_msg的文件夹中查看，例如查看标准消息类型，找到ros/kinect/share/std_msg/msg，里面定义了大量的topic类型数据。)，也可以自己新建topic类型。例如在工程文件夹下的功能包hello下面，创建msg文件夹，并在新建hello_msg.msg：12string stateint32 num &emsp;&emsp;上述命令相对于创建了一个类似于C语言中的结构体，其中包含了string类型的state变量和int32类型的num变量。 编译工程&emsp;&emsp;打开该功能包下的CMakeLists.txt文件，找到fin_package，add_message_files和generate_messages这几行，添加如下内容： &emsp;&emsp;打开该功能包下的package.xml文件，在里面添加以下内容： &emsp;&emsp;回到工程文件夹目录，进行catkin_make编译，打开工程文件夹下的devel/include/hello文件夹，可以看到新生成的hello_msg.h文件，后续需要该消息类型只需在添加该头文件即可。 编写发送文件&emsp;&emsp;进入功能包下的src文件夹，创建hello_talker.cpp，其内容如下：12345678910111213141516171819202122232425262728293031#include &lt;ros/ros.h&gt;#include &lt;hello/hello_msg.h&gt; //devel文件夹下面的hello_msg.h文件int main(int argc, char **argv)&#123; ros::init(argc, argv, \"hello_talker\"); // 初始化节点，hello_talker为节点名称 ros::NodeHandle nh; hello::hello_msg msg; // 初始化消息值 msg.state = \"working\"; msg.num = 1; ros::Publisher pub = nh.advertise&lt;hello::hello_msg&gt;(\"hello_info\", 1); // 创建发送者 ros::Rate loop_rate(1); // 定义发布的频率，1HZ while(ros::ok()) &#123; ROS_INFO(\"hello_talker: Hello %d\", msg.num); // 打印消息 msg.num += 1; // 消息类型数据处理 pub.publish(msg); // 发布消息 loop_rate.sleep(); // 根据前面的定义的loop_rate,设置1s的暂停 &#125; return 0;&#125; &emsp;&emsp;其中最重要的函数为topic消息发布函数advertise()，其调用格式为：ros::Publisher pub = nh.advertise&lt;[msg_type]&gt;([msgName], [msgCountLimit])。在本例中，消息格式为自定义的hello_msg，消息名称为hello_info(也可以是其他名字)。1表示每次只发送一次。在本例中，发送者会一直以1Hz的频率循环+1发送信息。publish()函数会向所有订阅该节点的接收者发送消息。&emsp;&emsp;在ROS中，消息有组织地存放在话题里。topic消息传递的理念是：当一个节点想要分享信息时，它就会发布(publish)消息到对应的一个或者多个话题；当一个节点想要接收信息时，它就会订阅(subscribe)它所需要的一个或者多个话题。ROS节点管理器负责确保发布节点和订阅节点能找到对方；而且消息是直接地从发布节点传递到订阅节点，中间并不经过节点管理器转交。 编写接收文件&emsp;&emsp;进入功能包下的src文件夹，创建hello_listener.cpp，其内容如下：12345678910111213141516171819202122232425#include &lt;ros/ros.h&gt;#include &lt;hello/hello_msg.h&gt; // 添加消息头文件#include &lt;std_msgs/Int32.h&gt; // 添加标准消息的int32头文件void helloCallback(const hello::hello_msg::ConstPtr &amp;msg)&#123; std_msgs::Int32 helloNum; // 定义int32消息类型变量 helloNum.data = msg-&gt;num + 1; // 注意这里只能是指针引用方式 ROS_INFO(\"listener: hello %d, state = %s\", helloNum.data, msg-&gt;state.c_str()); // 打印信息&#125;int main(int argc, char ** argv)&#123; ros::init(argc, argv, \"hello_listener\"); // 初始化节点，hello_listener为节点名称 ros::NodeHandle nh; ros::Subscriber sub = nh.subscribe(\"hello_info\", 1, helloCallback); // 创建接收者 ros::spin(); // ros::spin()用于调用所有可触发的回调函数，将进入循环，不会返回，类似于在循环里反复 // 调用spinOnce()只会发送一次 return 0;&#125; &emsp;&emsp;其中最重要的函数为topic消息接收函数subscribe()，其调用格式为：ros::Subscriber sub = node_handle.subscribe(topic_name,queue_size, pointer_to_callback_function);。前2个参数和advertise()的参数一致，第三个参数为回调函数的指针(这里是指针，所以只需写函数名即可，不需要加小括号())。当接收者接收到消息时，则会进入到回调函数中处理数据。本例中，接收者会将接收到的消息数值+1并打印输出状态信息。 编译运行&emsp;&emsp;打开功能包下的CMakeLists.txt文件，修改内容如下：&emsp;&emsp;进入工程文件夹下，使用catkin_make编译。编译完成后，可以进入devel/lib/hello文件夹下面看到新生成的hello_talker和hello_listener可执行文件。&emsp;&emsp;首先打开节点管理器roscore，然后分别打开2个终端，运行指令：1rosrun hello hello_talker 1rosrun hello hello_listener &emsp;&emsp;此时可以再打开1个终端，并输入rqt_graph查看当前的节点及消息。&emsp;&emsp;由图可见，当前共有2个节点和1个消息(椭圆为节点，矩形为消息)，即hello_talker和hello_listener通过消息(话题)hello_info来实现通讯。 Service in roscpp&emsp;&emsp;Service是一种请求-反馈的通信机制。请求的一方通常被称为客户端client，提供服务的一方叫做服务器端 server。Service机制相比于Topic的不同之处在于： 消息的传输是双向的，有反馈的，而不是单一的流向。 消息往往不会以固定频率传输，不连续，而是在需要时才会向服务器发起请求。 创建Service消息类型&emsp;&emsp;和topci消息类型类似，ros也自带很多service消息类型，存放位置和topic一致，只是有的_msg类型不一定有service消息类型的数据。例如std_msg中就没有service类型的，而sensor_msg中存在srv文件夹，里面就有定义好的service消息类型数据。&emsp;&emsp;同样的，本例中也创建一个自己的service消息类型。在工程文件夹下的hello包中创建一个srv文件夹，新建hello_srv.srv：1234string name int32 age ---string feedback &emsp;&emsp;横线上面的部分为服务请求的数据，即client数据，横向下面是服务器回传的内容，即server数据。类似于topic数据类型，service数据包含了2个结构体数据。 编译工程&emsp;&emsp;打开该功能包下的CMakeLists.txt文件，找到add_service_files这一行，根据注释添加以下内容： &emsp;&emsp;该部分内容一定要在generate_messages这一行之上，否则会编译报错。&emsp;&emsp;package.xml文件的添加内容如topic部分一致(如果在topic部分做过了就不需要再添加了)。&emsp;&emsp;回到工程文件夹目录，进行catkin_make编译，打开工程文件夹下的devel/include/hello文件夹，可以看到新生成的hello_srvRequest.h和hello_srvResponse.h文件，其中Request.h为client的，Response.h为server的。 编写服务器端文件&emsp;&emsp;进入功能包下的src文件夹，创建hello_server.cpp，其内容如下：123456789101112131415161718#include &lt;ros/ros.h&gt;#include &lt;hello/hello_srv.h&gt;bool handle_function(hello::hello_srv::Request &amp;req, hello::hello_srv::Response &amp;res)&#123; ROS_INFO(\"Request from client %s with age %d\", req.name.c_str(),req.age); res.feedback = \"Hi \" + req.name + \". I'm server!\"; return true;&#125;int main(int argc, char **argv)&#123; ros::init(argc, argv, \"hello_server\"); ros::NodeHandle nh; ros::ServiceServer service = nh.advertiseService(\"hello_server\", handle_function); ros::spin(); return 0;&#125; 编写客户端文件&emsp;&emsp;进入功能包下的src文件夹，创建hello_client.cpp，其内容如下：1234567891011121314151617181920212223#include &lt;ros/ros.h&gt;#include &lt;hello/hello_srv.h&gt;int main(int argc, char **argv)&#123; ros::init(argc, argv, \"hello_client\"); ros::NodeHandle nh; ros::ServiceClient client = nh.serviceClient&lt;hello::hello_srv&gt;(\"hello_server\"); hello::hello_srv srv; srv.request.name = \"Cxx\"; srv.request.age = 18; if(client.call(srv)) &#123; ROS_INFO(\"Response from service: %s\", srv.response.feedback.c_str()); &#125; else &#123; ROS_ERROR(\"Failed to call service hello_service\"); return 1; &#125; return 0;&#125; 编译运行&emsp;&emsp;打开功能包下的CMakeLists.txt文件，修改内容如下： &emsp;&emsp;进入工程文件夹下，使用catkin_make编译。编译完成后，可以进入devel/lib/hello文件夹下面看到新生成的hello_server和hello_client可执行文件。&emsp;&emsp;首先打开节点管理器roscore，然后分别打开2个终端，运行指令：1rosrun hello hello_server 1rosrun hello hello_client &emsp;&emsp;要先打开server节点程序，然后再打开client节点。&emsp;&emsp;service消息只会在client开启时才会调用，且调用完后立即结束，而topic会一直发送消息。 个人理解 ros中node是最基本也是最小的一个单元，一个node就是一个main()函数，也就是一个可执行文件，而每个package则是由若干个node组成的一个功能包，最后一个个package组成了整个工程文件。因此，实际的工程项目最基础的还是基本功能的编写，ros系统只是一个上层的封装，可以更便于操纵传感器等硬件，是硬件和软件之间的一层系统，所以叫做机器人操作系统，但其本身又不像windows或者Ubuntu那样强大，只是针对机器人硬件进行了封装，所以还必须要依附在Ubuntu上面(据说现在也可以在windows上面安装了，具体还没有试过)。 创建完任何一个ROS工程空间，首先要做2件事情，1.编译工作空间；2.添加环境。环境变量添加一次即可，每次修改包里面的内容时都要重新回到工作空间编译，使其生效。编译工作空间的本质就是生成一些库文件、可执行文件，而其工具就是CMake这个交叉编译工具，也就是说通过CMake这个工具(在ros里面就是输入catkin_make)，根据一定的规则和说明文件(在ros里面就是CMakeLists.txt文件)，将package里面的文件转换为其他文件，例如将src里面的.cpp文件转为.exe文件(因为计算机最终执行的是二进制文件，也就是.exe文件，而.cpp文件属于高级语言，是人看的)，将msg里面的文件转为lib里面的文件，等等。在通俗的讲，就是将我们看的东西转换为计算机看的东西。 个人觉得ros中有2个概念非常重要，一个是消息通讯，一个是launch文件，其余的概念接触过C++或者python都可以很快的理解。 参考博客ROS—catkin编译系统、package.xml和CMakeList.txt文件ros系统入门笔记（一）ROS学习笔记三：编写第一个ROS节点程序ROS 中的 launch 文件ROS环境下launch文件格式说明ROS Topic in roscpp 通信（简介+实例+测试）ROS入门机器人操作系统——Robot Operating System(ROS)","categories":[{"name":"ROS开发与应用","slug":"ROS开发与应用","permalink":"http://cxx0822.github.io/categories/ROS开发与应用/"}],"tags":[]},{"title":"基于turtlebot的定位与建图","slug":"基于turtlebot的定位与建图","date":"2020-04-25T10:46:37.000Z","updated":"2022-03-21T06:19:12.902Z","comments":true,"path":"2020/04/25/ji-yu-turtlebot-de-ding-wei-yu-jian-tu/","link":"","permalink":"http://cxx0822.github.io/2020/04/25/ji-yu-turtlebot-de-ding-wei-yu-jian-tu/","excerpt":"","text":"平台&emsp;&emsp;Ubuntu16.04&emsp;&emsp;turtlebot2&emsp;&emsp;RPLIDAR A1/2(思岚) Ubuntu与ROS系统安装&emsp;&emsp;具体详见另一篇博客Ubuntu安装，ROS安装 turtlebot配置安装turtlebot库&emsp;&emsp;升级软件版本1sudo apt-get update &emsp;&emsp;安装依赖库：1sudo apt-get install ros-kinetic-turtlebot &emsp;&emsp;安装turtlebot下的功能包(也可以根据需要安装)：1sudo apt-get install ros-kinetic-turtlebot-* 测试检查硬件连接&emsp;&emsp;打开turtlebot2电源，将turtlebot2的USB线接入工控机(PC机)的USB口(最好是USB3.0)，然后打开终端，启动ROS。1roscore &emsp;&emsp;再打开一个终端，输入检测命令：1ls /dev/kobuki &emsp;&emsp;显示相应设备即可。&emsp;&emsp;如果没有显示，则执行：1rosrun kobuki_ftdi create_udev_rules 检查底盘及电机&emsp;&emsp;打开电源，再打开一个终端，输入启动底盘命令：1roslaunch turtlebot_bringup minimal.launch &emsp;&emsp;不报错，听到声音即可。&emsp;&emsp;再打开一个终端，输入键盘操作底盘命令：1roslaunch turtlebot_teleop keyboard_teleop.launch &emsp;&emsp;根据提示信息，输入指令字母，turtlebot能动即可。 激光雷达配置安装驱动&emsp;&emsp;需要下载思岚官网提供的激光雷达驱动包。 创建工程文件夹1234mkdir catkin_ws # 可以是其他名字cd catkin_wsmkdir srccd src 下载并编译123git clone https://github.com/Slamtec/rplidar_ros.gitcd ..catkin_make 添加环境变量1234source devel/setup.bashgedit ~/.bashrc # 打开环境变量文件source ~/catkin_ws/devel/setup.bash # 在文档最下面添加该命令source ~/.bashrc # 生效 设置串口权限&emsp;&emsp;使激光雷达串口可以读和写。 检查端口号1dmesg | grep ttyUSB* &emsp;&emsp;有cp210x对应的USB口即可。(RPLIDAR A系列激光雷达使用的是cp210x串口驱动)。 设置权限1sudo gedit /etc/udev/rules.d/70-ttyusb.rules &emsp;&emsp;打开后，输入：1KERNEL==\"ttyUSB[0-9]*\", MODE=\"0666\" &emsp;&emsp;运行如下程序，查看权限，有两个rw即可。1ls -l /dev |grep ttyUSB* &emsp;&emsp;设置激光雷达串口的权限：1sudo chmod 777 /dev/ttyUSB0 &emsp;&emsp;注意这里的USB0和之前显示的要保持一致，如果下次更换USB接口可能需要更改数字。 添加环境变量&emsp;&emsp;添加别名：1echo \"export TURTLEBOT_LASER_SENSOR=rplidar\" &gt;&gt; ~/.bashrc &emsp;&emsp;转至rplidar_ros文件夹，输入命令：1./scripts/create_udev_rules.sh 测试激光雷达1roslaunch rplidar_ros rplidar.launch &emsp;&emsp;无错误，激光雷达正常运转即可。 激光雷达再分析&emsp;&emsp;学而不思则罔，思而不学则殆。&emsp;&emsp;打开src/rplidar_ros/launch/rplidar.launch，可以看到里面调用了一个rplidarNode的节点，并为其设置了一些参数。打开src/rplidar_ros/文件夹下的CMakeLists.txt文件夹，可以找到add_executable()中的rplidarNode节点，而该节点真正的定义是在src/rplidar_ros/src文件夹下的node.cpp文件，找到main函数即可看到该节点的定义。&emsp;&emsp;从这段代码中可以看出，该节点订阅了一个sensor_msgs::LaserScan的消息类型，该消息类型也是ros中自带的激光雷达数据类型。打开/opt/ros/kinetic/share/sensor_msgs/msg/LaserScan.msg即可查看该数据类型。然后紧跟着定义了一些参数，这也是rplidar.launch里面的参数。对该数据类型的具体处理在pubulish_scan()函数中。&emsp;&emsp;运行roslaunch rplidar_ros rplidar.launch，并通过简单的指令可以查看当前节点、话题和消息的内容：&emsp;&emsp;rosnode list：显示所有节点。&emsp;&emsp;rostopic list：显示所有话题。&emsp;&emsp;rqt_graph：图形化显示节点和话题之间的关系。&emsp;&emsp;rostopic info topic名称：查看话题信息。&emsp;&emsp;rostopic type topic名称：查看话题的消息类型。&emsp;&emsp;rosmsg show message名称 查看消息数据结构。&emsp;&emsp;rostopic echo topic名称：显示话题上发布的具体消息。&emsp;&emsp;如果想在rviz界面中显示激光雷达数据，先在终端输入rviz打开界面，然后点击Add添加LaserScan话题，并在Topic里面选择目前的laser话题。但是现在仍然看不到激光雷达数据，因为目前的坐标系是map，而激光雷达需要的是laser坐标系，所以在Global Options中的Fixed Frame选项手动输入laser，最终的设置及效果如下：&emsp;&emsp;当然也可以直接输入rplidar官方配置好的launch文件：1roslaunch rplidar_ros view_rplidar.launch 基于hector-slam的定位与建图平台&emsp;&emsp;硬件：RPLIDAR A1，算法：hector-slam。 安装算法包&emsp;&emsp;具体操作见上(注意一定要编译)。算法包网址：1git clone https://github.com/NickL77/RPLidar_Hector_SLAM &emsp;&emsp;注：hector-slam软件包中自带rplidar_ros包，为了避免因为2个同名的包导致错误产生，可以在环境变量中将之前的激光雷达环境注释掉，后续的建图算法也建议这么操作。 定位与建图&emsp;&emsp;打开激光雷达：1roslaunch rplidar_ros rplidar.launch &emsp;&emsp;运行建图算法：1roslaunch hector_slam_launch tutorial.launch &emsp;&emsp;然后手推turtlebot或使用之前的键盘控制指令使其移动，在rviz界面中可以看到地图的更新。 基于Gmapping的定位与建图Gmapping简介&emsp;&emsp;Gmapping的程序框架是依托Open_slam(OpenSLAM.org的目标是为SLAM研究人员提供一个平台，使他们能够发布自己的算法。OpenSLAM.org成立于2006年，并于2018年移至github。目前开源的项目有：OpenSLAM.org)，该框架主要分成slam_gmapping和openslam_gmapping。slam_gmapping是openslam_gampping在ros下的二次封装，真正的核心代码实现都在openslam_gampping里面。 平台&emsp;&emsp;硬件：RPLIDAR A2，算法：Gmapping。 下载源代码&emsp;&emsp;Gmapping算法在安装ros时已经安装好，当然也可以通过下载源代码编译安装。&emsp;&emsp;首先新建工作空间gmapping_ws(也可以是其他名字)，然后新建src文件夹，并下载gmapping源代码：12git clone https://github.com/ros-perception/openslam_gmapping.gitgit clone https://github.com/ros-perception/slam_gmapping.git &emsp;&emsp;然后下载rplidar源代码：1git clone https://github.com/Slamtec/rplidar_ros.git &emsp;&emsp;最后下载turtlebot底盘驱动源代码：1git clone https://github.com/Cxx0822/turtlebot_move_base.git 编译&emsp;&emsp;首先打开src/rplidar_ros/launch文件夹，新建my_rplidar.launch文件：1234567891011&lt;launch&gt; &lt;node name=\"rplidarNode\" pkg=\"rplidar_ros\" type=\"rplidarNode\" output=\"screen\"&gt; &lt;param name=\"serial_port\" type=\"string\" value=\"/dev/ttyUSB0\"/&gt; &lt;param name=\"serial_baudrate\" type=\"int\" value=\"115200\"/&gt;&lt;!--A1/A2 --&gt; &lt;!--param name=\"serial_baudrate\" type=\"int\" value=\"256000\"--&gt;&lt;!--A3 --&gt; &lt;param name=\"frame_id\" type=\"string\" value=\"laser\"/&gt; &lt;param name=\"inverted\" type=\"bool\" value=\"false\"/&gt; &lt;param name=\"angle_compensate\" type=\"bool\" value=\"true\"/&gt; &lt;/node&gt; &lt;node pkg=\"tf\" type=\"static_transform_publisher\" name=\"base_to_laser\" args=\"0.0 0.0 0.4 0 0.0 0.0 base_link laser 100\"/&gt;&lt;/launch&gt; &emsp;&emsp;该launch文件一共包含2个ros节点，一个是启动雷达节点rplidarNode，一个是tf坐标变换节点static_transform_publisher。其参数为：1static_transform_publisher x y z yaw pitch roll frame_id child_frame_id period_in_ms &emsp;&emsp;在这里表示的是turtlebot基坐标到雷达坐标的转换，这里的0.4指的是安装高度。 &emsp;&emsp;然后打开src/slam_gmapping/gmapping/launch文件夹，现建my_gmapping_rplidar.launch文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=\"1.0\"?&gt;&lt;launch&gt; &lt;arg name=\"scan_topic\" default=\"scan\" /&gt; &lt;arg name=\"base_frame\" default=\"base_footprint\"/&gt; &lt;arg name=\"odom_frame\" default=\"odom\"/&gt; &lt;node pkg=\"gmapping\" type=\"slam_gmapping\" name=\"slam_gmapping\" output=\"screen\"&gt; &lt;param name=\"base_frame\" value=\"$(arg base_frame)\"/&gt; &lt;param name=\"odom_frame\" value=\"$(arg odom_frame)\"/&gt; &lt;param name=\"map_update_interval\" value=\"0.01\"/&gt; &lt;param name=\"maxUrange\" value=\"4.0\"/&gt; &lt;param name=\"maxRange\" value=\"5.0\"/&gt; &lt;param name=\"sigma\" value=\"0.05\"/&gt; &lt;param name=\"kernelSize\" value=\"3\"/&gt; &lt;param name=\"lstep\" value=\"0.05\"/&gt; &lt;param name=\"astep\" value=\"0.05\"/&gt; &lt;param name=\"iterations\" value=\"5\"/&gt; &lt;param name=\"lsigma\" value=\"0.075\"/&gt; &lt;param name=\"ogain\" value=\"3.0\"/&gt; &lt;param name=\"lskip\" value=\"0\"/&gt; &lt;param name=\"minimumScore\" value=\"30\"/&gt; &lt;param name=\"srr\" value=\"0.01\"/&gt; &lt;param name=\"srt\" value=\"0.02\"/&gt; &lt;param name=\"str\" value=\"0.01\"/&gt; &lt;param name=\"stt\" value=\"0.02\"/&gt; &lt;param name=\"linearUpdate\" value=\"0.05\"/&gt; &lt;param name=\"angularUpdate\" value=\"0.0436\"/&gt; &lt;param name=\"temporalUpdate\" value=\"-1.0\"/&gt; &lt;param name=\"resampleThreshold\" value=\"0.5\"/&gt; &lt;param name=\"particles\" value=\"8\"/&gt; &lt;!-- &lt;param name=\"xmin\" value=\"-50.0\"/&gt; &lt;param name=\"ymin\" value=\"-50.0\"/&gt; &lt;param name=\"xmax\" value=\"50.0\"/&gt; &lt;param name=\"ymax\" value=\"50.0\"/&gt; make the starting size small for the benefit of the Android client's memory... --&gt; &lt;param name=\"xmin\" value=\"-1.0\"/&gt; &lt;param name=\"ymin\" value=\"-1.0\"/&gt; &lt;param name=\"xmax\" value=\"1.0\"/&gt; &lt;param name=\"ymax\" value=\"1.0\"/&gt; &lt;param name=\"delta\" value=\"0.05\"/&gt; &lt;param name=\"llsamplerange\" value=\"0.01\"/&gt; &lt;param name=\"llsamplestep\" value=\"0.01\"/&gt; &lt;param name=\"lasamplerange\" value=\"0.005\"/&gt; &lt;param name=\"lasamplestep\" value=\"0.005\"/&gt; &lt;remap from=\"scan\" to=\"$(arg scan_topic)\"/&gt; &lt;/node&gt;&lt;/launch&gt; &emsp;&emsp;该文件主要包含一个slam_gmapping节点，并设置了参数，最后将scan话题重映射到scan_topic中。具体参数解释可参考：GMAPPING的参数设置 &emsp;&emsp;turtlebot_move_base部分已经修改好，直接用即可。&emsp;&emsp;最后创建一个功能包：turtlebot_gmapping：1catkin_create_pkg turtlebot_gmapping std_msgs roscpp rospy &emsp;&emsp;然后进入该功能包，新建launch文件夹，并新建my_gmapping.launch文件：1234567891011121314151617&lt;?xml version=\"1.0\"?&gt;&lt;launch&gt; &lt;!-- Define laser type--&gt; &lt;arg name=\"laser_type\" default=\"rplidar\" /&gt; &lt;!-- laser driver --&gt; &lt;include file=\"$(find rplidar_ros)/launch/my_$(arg laser_type).launch\" /&gt; &lt;!-- Gmapping --&gt; &lt;include file=\"$(find gmapping)/launch/my_gmapping_$(arg laser_type).launch\"/&gt; &lt;!-- Move base --&gt; &lt;include file=\"$(find turtlebot_move_base)/launch/includes/move_base.launch.xml\"/&gt; &lt;!-- Rviz--&gt; &lt;include file=\"$(find turtlebot_rviz_launchers)/launch/view_navigation.launch\"/&gt;&lt;/launch&gt; &emsp;&emsp;该launch文件相当于是之前的一个整合。一共包含四个部分：启动雷达，启动建图，启动底盘控制和启动rviz。&emsp;&emsp;然后回到工作空间编译，添加环境变量即可。 测试&emsp;&emsp;首先打开turtlebot底盘：1roslaunch turtlebot_bringup minimal.launch &emsp;&emsp;然后打开gmapping建图算法：1roslaunch turtlebot_gmapping my_gmapping.launch &emsp;&emsp;最后启动键盘控制程序，开始建图：1roslaunch turtlebot_teletop keyboard_teletop.launch &emsp;&emsp;同样的，我们也可以使用ros自带的工具rqt_graph查看整个流程。&emsp;&emsp;其中单独的底盘节点状态图如图所示：&emsp;&emsp;单独的gmapping节点状态图如图所示：&emsp;&emsp;所有节点状态图如图所示：&emsp;&emsp;这里椭圆表示节点名字，也就是launch文件启动节点的name值，矩形表示话题。 附：&emsp;&emsp;turtlebot有一个官方的工具包，里面包含了大量的建图等算法，可以直接使用。&emsp;&emsp;新建工作空间，并下载源代码：123mkdir -p ~/turbot_ws/srccd ~/turbot_ws/srcgit clone https://github.com/ncnynl/turtlebot_apps &emsp;&emsp;然后下载turbot工具包：1git clone https://github.com/ncnynl/turbot &emsp;&emsp;回到工作空间编译并添加至环境变量。&emsp;&emsp;依次执行以下命令建图：1234roslaunch turbot_bringup minimal.launchroslaunch turbot_slam laser_gmapping_demo.launchroslaunch turbot_rviz nav.launchroslaunch turbot_teleop keyboard.launch &emsp;&emsp;参考博客：Turtlebot + Rplidar A2使用Gmapping建图与导航 基于Cartographer的定位与建图平台&emsp;&emsp;硬件：RPLIDAR A2，算法：Cartographer。 Cartographer简介&emsp;&emsp;2016年10月5日，谷歌宣布开放一个名为cartographer的即时定位与地图建模库，开发人员可以使用该库实现机器人在二维或三维条件下的定位及建图功能。cartograhper的设计目的是在计算资源有限的情况下，实时获取相对较高精度的2D地图。考虑到基于模拟策略的粒子滤波方法在较大环境下对内存和计算资源的需求较高，cartographer采用基于图网络的优化方法。目前cartographer主要基于激光雷达来实现SLAM，谷歌希望通过后续的开发及社区的贡献支持更多的传感器和机器人平台，同时不断增加新的功能。 Cartographer的安装安装依赖库protobuf3&emsp;&emsp;注：这里需要安装3.6以上的版本。1234567891011sudo apt-get install autoconf autogengit clone https://github.com/protocolbuffers/protobuf.gitcd protobufgit submodule update --init --recursive./autogen.sh./configuremake# 这一步可能会报错，无视就好make checksudo make installsudo ldconfig &emsp;&emsp;注：需要分开依次执行，下同。&emsp;&emsp;检查安装的版本号：1protoc --version 安装Cartographer&emsp;&emsp;安装wstool,rosdep,ninja工具：12sudo apt-get updatesudo apt-get install python-wstool python-rosdep ninja-build &emsp;&emsp;创建工作空间carto_ws(可以是其他名字)，并初始化。123mkdir carto_wscd carto_wswstool init src 12wstool merge -t src https://raw.githubusercontent.com/googlecartographer/cartographer_ros/master/cartographer_ros.rosinstallwstool update -t src &emsp;&emsp;如果报错或长时间未安装，则更改下载地址：cd src/，gedit .rosinstall。 &emsp;&emsp;将最后一个git来源网址由https://ceres-solver.googlesource.com/ceres-solver.git改为https://github.com/ceres-solver/ceres-solver.git。 &emsp;&emsp;回到工作空间，重新执行：1wstool update -t src 123sudo rosdep init # 报错可忽视rosdep update # 报错则重新执行(网络原因)rosdep install --from-paths src --ignore-src --rosdistro=$&#123;ROS_DISTRO&#125; -y &emsp;&emsp;注：如果报错，未设置环境变量，则执行以下命令：12echo \"source /opt/ros/kinetic/setup.bash\" &gt;&gt; ~/.bashrcsource ~/.bashrc &emsp;&emsp;重新执行：1rosdep install --from-paths src --ignore-src --rosdistro=$&#123;ROS_DISTRO&#125; -y &emsp;&emsp;最终出现：#All required rosdeps installed successfully。 编译1234catkin_make_isolated --install --use-ninjasource install_isolated/setup.bashecho \"source ~/carto_ws/install_isolated/setup.bash\" &gt;&gt; ~/.bashrcsource ~/.bashrc &emsp;&emsp;注：如果这里报错，检查一下protoc的版本，至少是3.6的，如果不是，按照上文重新安装protoc依赖库。安装时间较长，和系统性能有关，约10-15分钟。 测试1234567891011# Download the 2D backpack example bag.wget -P ~/Downloads https://storage.googleapis.com/cartographer-public-data/bags/backpack_2d/cartographer_paper_deutsches_museum.bag # Launch the 2D backpack demo.roslaunch cartographer_ros demo_backpack_2d.launch bag_filename:=$&#123;HOME&#125;/Downloads/cartographer_paper_deutsches_museum.bag # Download the 3D backpack example bag.wget -P ~/Downloads https://storage.googleapis.com/cartographer-public-data/bags/backpack_3d/with_intensities/b3-2016-04-05-14-14-00.bag # Launch the 3D backpack demo.roslaunch cartographer_ros demo_backpack_3d.launch bag_filename:=$&#123;HOME&#125;/Downloads/b3-2016-04-05-14-14-00.bag &emsp;&emsp;如果报错，检查下是否刷新了环境变量(source ~/carto_ws/install_isolated/setup.bash)。 参考博客&emsp;&emsp;博客1，博客2 安装cartographer_turtlebot&emsp;&emsp;首先下载rplidar驱动：1git clone https://github.com/Slamtec/rplidar_ros.git &emsp;&emsp;然后和gmapping类似，添加坐标变换节点。(参考上文gmapping部分)&emsp;&emsp;然后下载cartographer_turtlebot源代码：1git clone https://github.com/cartographer-project/cartographer_turtlebot 修改配置文件&emsp;&emsp;首先打开src/cartographer_ros/cartographer_ros/configuration_files/revo_lds.lua，将tracking_frame和published_frame改为rplidar的frame_id，即将原来的替换成laser。&emsp;&emsp;注：实际测试时发现，运行时会报错，需要将里面的 use_pose_extrapolator的true改为on。&emsp;&emsp;然后打开src/cartographer_turtlebot/cartographer_turtlebot/launch，新建turtlebot_lidar.launch文件：12345678910111213141516171819202122232425&lt;launch&gt; &lt;arg name=\"configuration_basename\"/&gt; &lt;include file=\"$(find turtlebot_bringup)/launch/minimal.launch\" /&gt; &lt;node name=\"cartographer_node\" pkg=\"cartographer_ros\" type=\"cartographer_node\" args=\" -configuration_directory $(find cartographer_turtlebot)/configuration_files -configuration_basename $(arg configuration_basename)\" output=\"screen\"&gt; &lt;remap from=\"scan\" to=\"/scan\" /&gt; &lt;/node&gt; &lt;node name=\"flat_world_imu_node\" pkg=\"cartographer_turtlebot\" type=\"cartographer_flat_world_imu_node\" output=\"screen\"&gt; &lt;remap from=\"imu_in\" to=\"/mobile_base/sensors/imu_data_raw\" /&gt; &lt;remap from=\"imu_out\" to=\"/imu\" /&gt; &lt;/node&gt; &lt;node name=\"rviz\" pkg=\"rviz\" type=\"rviz\" required=\"true\" args=\"-d $(find cartographer_turtlebot )/configuration_files/demo_turtlebot.rviz\" /&gt;&lt;/launch&gt; &emsp;&emsp;再新增启动文件：turtlebot_carto.launch12345&lt;launch&gt; &lt;include file=\"$(find cartographer_turtlebot)/launch/turtlebot_lidar.launch\"&gt; &lt;arg name=\"configuration_basename\" value=\"turtlebot_urg_lidar_2d.lua\" /&gt; &lt;/include&gt;&lt;/launch&gt; &emsp;&emsp;然后回到工作空间，编译(catkin_make_isolated --install –use-ninja)并刷新环境变量即可。 测试&emsp;&emsp;首先运行激光雷达：1roslaunch rplidar_ros rplidar.launch &emsp;&emsp;然后启动建图程序：1roslaunch cartographer_turtlebot turtlebot_carto.launch 参考博客使用Turtlebot 2和Rplidar A2实现CartographerJetson TX2 使用 Rplidar A2 实现 Cartographer","categories":[{"name":"ROS开发与应用","slug":"ROS开发与应用","permalink":"http://cxx0822.github.io/categories/ROS开发与应用/"}],"tags":[]},{"title":"无人清洁车","slug":"无人清洁车","date":"2020-03-13T01:13:39.000Z","updated":"2022-03-21T06:19:12.988Z","comments":true,"path":"2020/03/13/wu-ren-qing-ji-che/","link":"","permalink":"http://cxx0822.github.io/2020/03/13/wu-ren-qing-ji-che/","excerpt":"","text":"ROS基础知识roslaunch命令命令格式1roslaunch 功能包名称 launch文件 [参数设置(arg:=value)] &emsp;&emsp;这里roslaunch命令会在对应的功能包中找到名称匹配的launch文件，并执行这个launch文件。如果设置了参数的话，会将参数传入到launch文件中赋给对应的参数。 功能及作用&emsp;&emsp;roslaunch可以运行多个节点。并且roslaunch命令在运行节点时，还可以附加一些ROS命令选项，比如修改参数或节点的名称,设置节点的命名空间,设置ROS_ROOT及ROS_PACKAGE_PATH,以及环境变量修改等选项的ROS命令。 rosrun命令命令格式1rosrun 功能包名称 节点名称 功能及作用&emsp;&emsp;rosrun是执行指定的功能包中的一个节点的命令。 rostopic命令格式1rostopic pub 话题名称 消息类型 参数 功能及作用&emsp;&emsp;rostopic向正在广播的话题发布数据消息。 使用步骤1.打开电源，启动Ubuntu系统，连接工控机局域网/外接路由器。&emsp;&emsp;工控机局域网为：Wideora-5f92。注：挪动清洁车时，一定要打开电源，小距离移动除外。 2.手推/键盘操作移动清洁车，移动区域覆盖目标区域。ROS命令：1roslaunch anbot_bringup anbot_bringup.launch 启动键盘ROS命令：1rosrun teleop_twist_keyboard teleop_twist_keyboard.py &emsp;&emsp;实际建图时，可以通过Rviz观察当前建图信息，并调整清洁车位置。&emsp;&emsp;彩色表示当前激光雷达扫描区域，黑色表示墙等障碍物，灰白色表示空白作业区域。外圈白色线条状表示因地面等其他因素激光照射出去的范围。 3.保存地图，人工修图。ROS命令：1rostopic pub /robot_map_save std_msgs/String \"data: ''\" &emsp;&emsp;注：实际操作时，按Tab键自动补全。&emsp;&emsp;图片位于1SweepRobotManger/robot/install/share/robot_config/map/sweepmap.jpg &emsp;&emsp;注：map中sweepmap是导航实际用的地图，mymap是导航时可视化界面rviz中的地图。 &emsp;&emsp;未修之前地图：&emsp;&emsp;修图工具：Pinta，功能界面类似于画图，普通画图编辑器。&emsp;&emsp;修图目标：1.确保场景为封闭环境。2.确保边界清晰。3.确保作业区域无杂质。&emsp;&emsp;操作方法：使用画笔工具添加或加粗边界，使用橡皮擦工具清除杂质。&emsp;&emsp;修改之后地图： 4.启动导航，手动定位。ROS命令：1roslaunch anbot_bringup anbot_navigation.launch &emsp;&emsp;注：启动前按住急停按钮，确保清洁车不能移动，定位后在按下急停按钮，使其作业。&emsp;&emsp;启动该命令后，自动进入Rviz界面，手动调整机器人位姿，使其在正确的地图位置中。&emsp;&emsp;定位校准前：&emsp;&emsp;具体操作：点击2D Pose Estimate，拖动鼠标，确定方向，使激光雷达扫描区域(彩色区域)和实际地图中墙壁重合。&emsp;&emsp;定位校准后：&emsp;&emsp;注：绿色线条区域为导航算法自动生成。红色为机器人位置。 5.自动导航，启动刷盘等，开始作业。ROS命令：1rostopic pub /agent anbot_msgs/Agent \"&#123;太多了 不一一写了，tab补全即可&#125;\" &emsp;&emsp;通过键盘将brushUpDown和squeegeUpDown数值改为1即可。&emsp;&emsp;注：启动该命令前，确保清洁车处于急停不可移动状态。 附录调整激光雷达参数&emsp;&emsp;目前清洁车搭载的激光雷达型号为sick激光雷达，具体型号有561,571等。其中561款的射程为10米，571款的射程为25米。两款型号不一致，IP端口、参数配置也不一样。 硬件配置&emsp;&emsp;需要更改其IP地址，目前清洁车局域网内，激光雷达的IP地址为192.168.8.100。具体方法参考博客：地址。 软件配置&emsp;&emsp;在/share/sick_tim/launch文件夹中找到571的配置文件，将range_max参数更改为相应的射程。&emsp;&emsp;在/share/robot_config/slam_config找到gmapping_param.yaml配置文件，将maxRange参数更改为相应的射程。","categories":[{"name":"医疗服务机器人","slug":"医疗服务机器人","permalink":"http://cxx0822.github.io/categories/医疗服务机器人/"}],"tags":[]},{"title":"视觉系统界面设计","slug":"视觉系统界面设计","date":"2020-01-07T02:01:53.000Z","updated":"2022-03-21T06:19:13.102Z","comments":true,"path":"2020/01/07/shi-jue-xi-tong-jie-mian-she-ji/","link":"","permalink":"http://cxx0822.github.io/2020/01/07/shi-jue-xi-tong-jie-mian-she-ji/","excerpt":"","text":"平台&emsp;&emsp;界面设计软件：Qt&emsp;&emsp;编程语言：C++ 界面设计整体界面&emsp;&emsp;整体分为标题栏，菜单栏，状态栏和功能区，图像区，信息区和参数区等。采用灰白色主色调，华为楷体字体。 设计原则&emsp;&emsp;采用界面布局和控件功能分开设计的原则，即界面布局在Qt Creator中的设计窗口中设计。控件功能通过槽函数在编辑窗口中设计。 界面布局&emsp;&emsp;控件通过拖拽产生，其位置大小图标等信息在设计窗口的右下角部分直接编辑其属性即可。控件样式通过右击控件选择改变样式表设计。最终使用其布局工具栏对界面快速布局。&emsp;&emsp;注： 所有控件必须布局，否则无法产生效果。 可以利用其minimumSize和maximumSize属性控制控件的大小。 &emsp;&emsp;附： 2","categories":[{"name":"工业机器人视觉","slug":"工业机器人视觉","permalink":"http://cxx0822.github.io/categories/工业机器人视觉/"}],"tags":[]},{"title":"C++动态库的实现与调用","slug":"C++动态库的实现与调用","date":"2019-12-23T02:52:06.000Z","updated":"2022-03-21T06:19:12.430Z","comments":true,"path":"2019/12/23/c-dong-tai-ku-de-shi-xian-yu-diao-yong/","link":"","permalink":"http://cxx0822.github.io/2019/12/23/c-dong-tai-ku-de-shi-xian-yu-diao-yong/","excerpt":"","text":"平台&emsp;&emsp;Visual Studio 2015&emsp;&emsp;Qt Creator 概述&emsp;&emsp;动态链接库(Dynamic Link Library)DLL文件与exe文件一样也是可执行文件，但是DLL也被称之为库，因为里面封装了各种类和函数等，就像是一个库一样，存储着很多东西，主要是用来调用的。调用方式主要分为两种：隐式(通过lib文件与头文件)与显式(只通过DLL文件)。&emsp;&emsp;代码复用是提高软件开发效率的重要途径。一般而言，只要某部分代码具有通用性，就可将它构造成相对独立的功能模块并在之后的项目中重复使用。比较常见的例子是各种应用程序框架，ATL、MFC等，它们都以源代码的形式发布。由于这种复用是源码级别的，源代码完全暴露给了程序员，因而称之为白盒复用。为了弥补白盒复用的不足，就提出了二进制级别的代码复用。使用二进制级别的代码复用一定程度上隐藏了源代码，对于缓解代码耦合现象起到了一定的作用。这样的复用被称为黑盒复用。&emsp;&emsp;注：实现黑盒复用的途径不只dll一种，静态链接库甚至更高级的COM组件都是。 Visual Studio实现C++的动态链接库创建动态链接库新建工程项目CreateDLL&emsp;&emsp;打开Visual Studio 2015新建工程，并选择DLL应用程序类型。 创建.cpp和.h文件&emsp;&emsp;右击项目工程，添加-&gt;新建项，依次建立createDLL.cpp和createDLL.h文件。 编写文件createDLL.h1__declspec(dllexport) void test_fun(); createDLL.cpp&emsp;&emsp;这里写了一个简单的hello world测试程序。123456789#include \"createDLL.h\"#include &lt;iostream&gt;using namespace std;void test_fun()&#123; cout &lt;&lt; \"hello world\" &lt;&lt; endl;&#125; 编译&emsp;&emsp;重新生成解决方案 文件位置&emsp;&emsp;在Debug文件夹下，有新生成的动态链接库文件。 使用动态链接库新建工程UseDLL&emsp;&emsp;这里选择控制台应用程序。 添加文件&emsp;&emsp;将刚才的createDLL.dll,createDLL.lib和createDLL.h文件放到工程文件目录下。 &emsp;&emsp;将刚才的`createDLL.dll`,`createDLL.lib`和`createDLL.h`文件分别放到工程文件目录下的头文件和资源文件中。 新建.cpp&emsp;&emsp;调用之前的函数即可。1234567#include \"createDLL.h\"int main()&#123; test_fun(); return 0;&#125; QT实现C++的动态链接库创建动态链接库新建工程项目CreateDLL&emsp;&emsp;打开Qt Creator新建工程，并选择Library模板中的C++库。&emsp;&emsp;重命名为Qt Creator，后续操作直接下一步即可。&emsp;&emsp;创建完成后，工程文件夹下会有3个文件。 编写类&emsp;&emsp;在createdll.h和createdll.cpp文件中编写该类。如添加一个显示hello world的函数。 createdll.h1234567891011121314#ifndef CREATEDLL_H#define CREATEDLL_H#include \"createdll_global.h\"class CREATEDLLSHARED_EXPORT CreateDLL&#123;public: CreateDLL(); void test_fun(); // 添加的内容&#125;;#endif // CREATEDLL_H createdll.cpp1234567891011121314#include \"createdll.h\"#include &lt;iostream&gt; // 添加的内容using namespace std; // 添加的内容CreateDLL::CreateDLL()&#123;&#125;// 添加的内容void CreateDLL::test_fun()&#123; cout &lt;&lt; \"hello world\" &lt;&lt; endl;&#125; 编译&emsp;&emsp;构建-&gt;运行即可。如果没有报错，则在项目的同级文件夹下会产生一个名为build-CreateDLL-Desktop_Qt_5_8_0_MSVC2015_64bit-Debug文件夹(如果没有更改的话)。 文件位置&emsp;&emsp;打开其Debug文件夹，里面有新生成的dll库文件。 使用动态链接库新建工程UseDLL&emsp;&emsp;打开Qt Creator新建工程，并选择Application模板中的Qt Console Application。其次和之前类似。 添加文件&emsp;&emsp;将刚才的createdll.h和createdll.cpp文件放入到该工程的文件夹下。并添加至该工程项目中。&emsp;&emsp;除此之外，还有一个很重要的步骤！将刚才生成的CreateDLL.dll库文件(位于Debug文件夹下)添加至工程文件.pro中。语法规则为：LIBS += -L路径 -l库名(不需要加后缀)。 编写.cpp12345678910111213#include &lt;QCoreApplication&gt;#include \"createdll.h\" // 添加的内容int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); //添加的内容 CreateDLL cdll; cdll.test_fun(); return a.exec();&#125; &emsp;&emsp;运行结果为：","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://cxx0822.github.io/categories/C-学习/"}],"tags":[]},{"title":"模板匹配算法简介","slug":"模板匹配算法简介","date":"2019-12-16T03:27:23.000Z","updated":"2022-03-21T06:19:13.013Z","comments":true,"path":"2019/12/16/mo-ban-pi-pei-suan-fa-jian-jie/","link":"","permalink":"http://cxx0822.github.io/2019/12/16/mo-ban-pi-pei-suan-fa-jian-jie/","excerpt":"","text":"基本概念&emsp;&emsp;在图像中寻找目标图像（模板），或者说，就是在图像中寻找与模板图像相似部分的一种图像处理技术。依赖于选择的方法不同，模板匹配可以处理各种情形下的变换，如照明、杂点、大小、位置以及旋转，甚至模板内部的相对移动。 分类&emsp;&emsp;HDevelop开发环境中提供的匹配的方法主要有三种，即Component-Based、Gray-Value-Based、Shape-Based,分别是基于组件（或成分、元素）的匹配，基于灰度值的匹配和基于形状的匹配。 总体流程 形状匹配基本流程 详细步骤 读取图像，这里一定要是灰度图，如果是彩色图，先用rgb1_to_gray()转成灰度图像； 确定ROI的区域。例如确定矩形，只需要确定矩形的左上点和右下点的坐标即可，利用gen_rectangle1()生成一个矩形，利用area_center()找到这个矩形的中心； 从图像中获取这个ROI区域的图像，利用reduce_domain()可以得到这个ROI。在建立模板之前，可以先对这个区域进行一些预处理，方便以后的建模，比如阈值分割，形态学的一些处理等等（后续匹配时，也需要执行预处理操作）； 利用create_shape_model()创建模板。这个函数有许多参数，具体见下文分析; 创建好模板后，这时还需要使用inspect_shape_model()来监视模板，它检查参数的适用性，还能帮助找到合适的参数；然后在使用get_shape_model_contours()获得这个模板的轮廓，用于后面的匹配； 创建好模板后，就可以打开另一幅图像，进行模板匹配了。这个过程就是在新图像中寻找与模板匹配的图像部分，利用find_shape_model()进行模板匹配，具体参数含义见下文分析； 最后利用vector_angle_to_rigid()和affine_trans_contour_xld()将其转化并显示。前一个是从一个点和角度计算一个刚体仿射变换，这个函数从匹配函数的结果中对构造一个刚体仿射变换（平移，旋转和缩放）很有用，把参考图像变为当前图像。 参数含义create_shape_model()1234567891011create_shape_model(const Hobject&amp; Template , //reduce_domain后的模板图像Hlong NumLevels, //金字塔的层数，可设为“auto”或0—10的整数Double AngleStart, //模板旋转的起始角度Double AngleExtent, //模板旋转角度范围, &gt;=0Double AngleStep, //旋转角度的步长， &gt;=0 and &lt;=pi/16const char* Optimization, //设置模板优化和模板创建方法const char* Metric, //匹配方法设置Hlong Contrast, //设置对比度Hlong MinContrast , //设置最小对比度Hlong* ModelID ) //输出模板句柄 &emsp;&emsp;NumLevels越大，找到匹配使用的时间就越小。如果金字塔的层数太大，模板不容易识别出来，这是需要将find_shape_model函数中MinScore和Greediness参数设置的低一些。如果金字塔层数太少找到模板的时间会增加。&emsp;&emsp;AngleStart和AngleExtent决定可能的旋转范围，AngleStep指定角度范围搜索的步长；&emsp;&emsp;Optimization：模板定位时使用的特征点的数量，模板点储存模式，设为none时，全点储存。当模板较小时，较少点数并不会降低模板匹配时间。在模板数据量大时有必要降低数据量(point_reduction_high)，以提高定位速度。&emsp;&emsp;Metric定义了在图像中匹配模板的条件，如果Metric=use_polarity，图像中的目标必须和模型具有一样的对比度。例如，如果模型是一个亮的目标在一个暗的背景上，那么仅仅那些比背景亮的目标可以找到。如果Metric=ignore_global_polarity,在两者对比度完全相反时也能找到目标。在上面的例子中，如果目标是比背景暗的也能将目标找到。&emsp;&emsp;Contras决定着模型点的对比度。对比度是用来测量目标与背景之间和目标不同部分之间局部的灰度值差异。Contrast的选择应该确保模板中的主要特征用于模型中。Contrast也可以是两个数值，这时模板使用近似edges_image函数中滞后阈值的算法进行分割。这里第一个数值是比较低的阈值，第二个数值是比较高的阈值。Contrast也可以包含第三个，这个数值是在基于组件尺寸选择重要模型组件时所设置的阈值，比如，比指定的最小尺寸的点数还少的组件将被抑制。这个最小尺寸的阈值会在每相邻的金字塔层之间除以2。如果一个小的模型组件被抑制，但是不使用滞后阈值，然而在Contrast中必须指定三个数值，在这种情况下前两个数值设置成相同的数值。这个参数的设置可以在inspect_shape_model函数中查看效果。如果Contrast设置为auto，create_shape_model将会自动确定三个上面描述的数值。或者仅仅自动设置对比度(auto_contrast)，滞后阈值(auto_contrast_hyst)或是 最小尺寸(auto_min_size)中一个。其他没有自动设置的数值可以按照上面的格式再进行设置。可以允许各种组合，例如：如果设置 [‘auto_contrast’,’auto_min_size’]，对比度和最小尺寸自动确定；如果设置 [‘auto_min_size’,20,30]，最小尺寸会自动设定，而滞后阈值被设为20和30。有时候可能对比度阈值自动设置的结果是不满意的，例 如，由于一些具体应用的原因当某一个模型组件是被包含或是被抑制时，或是目标包含几种不同的对比度时，手动设置这些参数效果会更好。&emsp;&emsp;MinContrast用来确定在执行find_shape_model函数进行识别时模型的哪一个对比度必须存在，也就是说，这个参数将模型从噪声图像中分离出来。因此一个好的选择应该是在图像中噪声所引起的灰度变化范围。例如，如果灰度浮动在10个灰度级内，MinContrast应该设置成10。如果模板和搜索图像是多通道图像，Metric参数设置成ignore_color_polarity，在一个通道中的噪声必须乘以通道个数的平方根再去设置MinContrast。例如，如果灰度值在一个通道的浮动范围是10个灰度级，图像是三通道的，那么MinContrast应该设置为17。很显然，MinContrast必须小于Contrast。如果要在对比度较低的图像中识别模板，MinContrast必须设置为一个相对较小的数值。如果要是模板即使严重遮挡(occluded)也能识别出来，MinContrast应该设置成一个比噪声引起的灰度浮动范围略大的数值，这样才能确保在find_shape_model函数中提取出模板准确的位置和旋转角度。如果MinContrast设置为auto，最小对比度会基于模板图像中的噪声自动定义。因此自动设定仅仅在搜索图像和模板图像噪声近似时才可以使用。 find_shape_model()1234567891011121314151617find_shape_model(const Hobject&amp; Image, //搜索图像Hlong ModelID, //模板句柄Double AngleStart, // 搜索时的起始角度Double AngleExtent, //搜索时的角度范围，必须与创建模板时的有交集。Double MinScore, // 输出的匹配的质量系数Score 都得大于该值Hlong NumMatches, // 定义要输出的匹配的最大个数Double MaxOverlap, // 当找到的目标存在重叠时，且重叠大于该值时选//择一个好的输出const char* SubPixel, // 计算精度的设置，五种模式，多选2，3Hlong NumLevels, // 搜索时金字塔的层数Double Greediness , //贪婪度，搜索启发式，一般都设为0.9，越高速度快//容易出现找不到的情况Halcon::HTuple* Row, //输出匹配位置的行坐标Halcon::HTuple* Column, //输出匹配位置的列坐标Halcon::HTuple* Angle, //输出匹配角度Halcon::HTuple* Score ) //输出匹配质量 &emsp;&emsp;Score是一个0到1之间的数，是模板在搜索图像中可见比例的近似测量。如果模板的一半被遮挡，该值就不能超过0.5。&emsp;&emsp;Image的domain定义了模型参考点的搜索区域，参数AngleStart和AngleExtent确定了模型搜索的旋转角度，参数MinScore定义模板匹配时至少有个什么样的质量系数才算是在图像中找到模板。MinScore设置的越大,搜索的就越快。如果模板在图像中没有被遮挡， MinScore可以设置为0.8这么高甚至0.9。&emsp;&emsp;NumMatches定义了在图像上找到模板的最大的个数。如果匹配时的质量系数大于MinScore的目标个数多于NumMatches，仅仅返回质量系数最好的NumMatches个目标位置。如果找的匹配目标不足NumMatches，那么就只返回找到的这几个。参数MinScore优于NumMatches。&emsp;&emsp;如果模型具有对称性，会在搜索图像的同一位置和不同角度上找到多个与目标匹配的区域。参数MaxOverlap是0到1之间的，定义了找到的两个目标区域最多重叠的系数，以便于把他们作为两个不同的目标区域分别返回。如果找到的两个目标区域彼此重叠并且大于MaxOverlap，仅仅返回效果最好的一个。重叠的计算方法是基于找到的目标区域的任意方向的最小外接矩形(看smallest_rectangle2)。如果MaxOverlap=0, 找到的目标区域不能存在重叠, 如果MaxOverla p=1，所有找到的目标区域都要返回。&emsp;&emsp;SubPixel确定找到的目标是否使用亚像素精度提取。如果SubPixel设置为none(或者false背景兼容)，模型的位置仅仅是一个像素精度和在create_shape_model中定义的角度分辨率。如果SubPixel设置为interpolation(或true)，位置和角度都是亚像素精度的。在这种模式下模型的位置是在质量系数函数中插入的，这种模式几乎不花费计算时间，并且能达到足够高的精度，被广泛使用。&emsp;&emsp;NumLevels是在搜索时使用的金字塔层数，如有必要，层数截成创建模型时的范围。如果NumLevels=0，使用创建模板时金字塔的层数。另外NumLevels还可以包含第二个参数，这个参数定义了找到匹配模板的最低金字塔层数。NumLevels=[4,2]表示匹配在第四层金字塔开始，在第二层金字塔找到匹配（最低的设为1）。可以使用这种方法降低匹配的运行时间，但是这种模式下位置精度是比正常模式下低的，所谓正常模式是在金字塔最底层匹配。因此如果需要较高的精度，应该设置SubPixel至少为least_squares。如果金字塔最底层设置的过大，可能不会达到期望的精度，或者找到一个不正确的匹配区域。这是因为在较高层的金字塔上模板是不够具体的，不足以找到可靠的模板最佳匹配。在这种情况下最低金字塔层数应设为最小值。&emsp;&emsp;参数Greediness确定在搜索时的“贪婪程度”。如果Greediness=0，使用一个安全的搜索启发式，只要模板在图像中存在就一定能找到模板，然而这种方式下搜索是相对浪费时间的。如果Greediness=1，使用不安全的搜索启发式，这样即使模板存在于图像中，也有可能找不到模板，但只是少数情况。如果设置Greediness=0.9，在几乎所有的情况下，总能找到模型的匹配。 实战代码解释读取图像12345read_image (Image, 'C:/Users/Cxx/Desktop/Image.jpg') //读取图像get_image_size (Image, Width, Height)//获取图像的大小dev_close_window ()//关闭窗口dev_open_window (0, 0, Width, Height, 'black', WindowHandle)//打开一个新窗口dev_display (Image)//显示图像 创建ROI区域（人为给定取值）123gen_circle (Circle, 270, 280, 90)//创建圆形区域 reduce_domain (Image, Circle, ImageReduced)//获得ROI区域的图像area_center (Circle, Area, Row1, Column1)//求出中心坐标 创建模板并监视模板12345create_scaled_shape_model (ImageReduced, 5, rad(-45), rad(90), 'auto', 0.8, 1.1, 'auto', 'auto', 'ignore_global_polarity', 'auto', 'auto', ModelID)// 准备一个可缩放比例的匹配轮廓模型inspect_shape_model (ImageReduced, ModelImages, ModelRegions, 4, 20)//创建一个轮廓匹配模型基于金字塔的图像 get_shape_model_params (ModelID, NumLevels, AngleStart, AngleExtent, AngleStep, ScaleMin, ScaleMax, ScaleStep, Metric, MinContrast)//返回一个轮廓匹配模型的参数get_shape_model_contours (ModelContours, ModelID, 1)write_shape_model (ModelID, 'C:/Users/Cxx/Desktop/img_model3.shm')//保存模板 仿射变换12345dev_set_color ('red')//设置颜色dev_set_line_width (2)//设置线宽vector_angle_to_rigid (0, 0, 0, Row1, Column1, 0, HomMat2D)//通过点和角度方面来计算一个放射变换矩阵affine_trans_contour_xld (ModelContours, ContoursAffineTrans, HomMat2D)//通过任意2D放射变换转换为XLD轮廓 stop () 模板匹配12345678910111213141516read_image (Image1, 'C:/Users/Cxx/Desktop/Image1.jpg')//读取另一张图片dev_display (Image1)//显示图像find_scaled_shape_model (Image1, ModelID, rad(-45), rad(90), 0.8, 1.1, 0.5, 0, 0.5, 'least_squares', 5, 0.8, Row2, Column2, Angle, Scale, Score)//模板匹配for I := 0 to |Score| - 1 by 1 *生成一个单位矩阵 hom_mat2d_identity (HomMat2DIdentity) *平移 hom_mat2d_translate (HomMat2DIdentity, Row2[I], Column2[I], HomMat2DTranslate) *旋转 hom_mat2d_rotate (HomMat2DTranslate, Angle[I], Row2[I], Column2[I], HomMat2DRotate) *放缩，得到最终的仿射变换矩阵 hom_mat2d_scale (HomMat2DRotate, Scale[I], Scale[I], Row2[I], Column2[I], HomMat2DScale) *仿射变换 affine_trans_contour_xld (ModelContours, ModelTrans, HomMat2DScale) dev_display (ModelTrans)endfor &emsp;&emsp;最终显示的模板匹配结果为： 其他形态学 膨胀：通过结构元素（正方形，圆形等），对原图像进行对应法则处理，增加像素 腐蚀：减少像素 开运算：先腐蚀后膨胀，减少像素 闭运算：先膨胀后腐蚀，增加像素 注： 膨胀&gt;闭运算，腐蚀&gt;开运算 对二值化图像：腐蚀，膨胀等：改变形状；对灰度图像：腐蚀：变暗，膨胀：变亮，开闭运算同理。 Bloab分析&emsp;&emsp;二值化-&gt;形态学-&gt;特征选择 预处理 中值滤波：求中间值，消除过亮或过暗的点，即消除椒盐噪声； 均值滤波：求均值 高斯滤波：加权值 参考博客 基于HALCON的模板匹配方法总结 Halcon 模板匹配参数详解 halcon第十四讲：基于形状的模板匹配","categories":[{"name":"工业机器人视觉","slug":"工业机器人视觉","permalink":"http://cxx0822.github.io/categories/工业机器人视觉/"}],"tags":[]},{"title":"Cartographer的原理与应用","slug":"Cartographer的原理与应用","date":"2019-11-11T05:01:32.000Z","updated":"2022-03-21T06:19:12.443Z","comments":true,"path":"2019/11/11/cartographer-de-yuan-li-yu-ying-yong/","link":"","permalink":"http://cxx0822.github.io/2019/11/11/cartographer-de-yuan-li-yu-ying-yong/","excerpt":"","text":"平台&emsp;&emsp;Ubuntu 16.04&emsp;&emsp;ROS kinect&emsp;&emsp;Cartographer Cartographer的安装安装依赖库protobuf3&emsp;&emsp;注：这里需要安装3.6以上的版本。1234567891011sudo apt-get install autoconf autogengit clone https://github.com/protocolbuffers/protobuf.gitcd protobufgit submodule update --init --recursive./autogen.sh./configuremake# 这一步可能会报错，无视就好make checksudo make installsudo ldconfig &emsp;&emsp;注：需要分开依次执行，下同。&emsp;&emsp;检查安装的版本号：1protoc --version 安装Cartographer&emsp;&emsp;安装wstool,rosdep,ninja工具：12sudo apt-get updatesudo apt-get install python-wstool python-rosdep ninja-build &emsp;&emsp;创建工作空间carto_ws(可以是其他名字)，并初始化。123mkdir carto_wscd carto_wswstool init src 12wstool merge -t src https://raw.githubusercontent.com/googlecartographer/cartographer_ros/master/cartographer_ros.rosinstallwstool update -t src &emsp;&emsp;如果报错或长时间未安装，则更改下载地址：cd src/，gedit .rosinstall。 &emsp;&emsp;将最后一个git来源网址由https://ceres-solver.googlesource.com/ceres-solver.git改为https://github.com/ceres-solver/ceres-solver.git。 &emsp;&emsp;回到工作空间，重新执行：1wstool update -t src 123sudo rosdep init # 报错可忽视rosdep update # 报错则重新执行(网络原因)rosdep install --from-paths src --ignore-src --rosdistro=$&#123;ROS_DISTRO&#125; -y &emsp;&emsp;注：如果报错，未设置环境变量，则执行以下命令：12echo \"source /opt/ros/kinetic/setup.bash\" &gt;&gt; ~/.bashrcsource ~/.bashrc &emsp;&emsp;重新执行：1rosdep install --from-paths src --ignore-src --rosdistro=$&#123;ROS_DISTRO&#125; -y &emsp;&emsp;最终出现：#All required rosdeps installed successfully。 编译12catkin_make_isolated --install --use-ninjasource install_isolated/setup.bash &emsp;&emsp;注：如果这里报错，检查一下protoc的版本，至少是3.6的，如果不是，按照上文重新安装protoc依赖库。 测试1234567891011# Download the 2D backpack example bag.wget -P ~/Downloads https://storage.googleapis.com/cartographer-public-data/bags/backpack_2d/cartographer_paper_deutsches_museum.bag # Launch the 2D backpack demo.roslaunch cartographer_ros demo_backpack_2d.launch bag_filename:=$&#123;HOME&#125;/Downloads/cartographer_paper_deutsches_museum.bag # Download the 3D backpack example bag.wget -P ~/Downloads https://storage.googleapis.com/cartographer-public-data/bags/backpack_3d/with_intensities/b3-2016-04-05-14-14-00.bag # Launch the 3D backpack demo.roslaunch cartographer_ros demo_backpack_3d.launch bag_filename:=$&#123;HOME&#125;/Downloads/b3-2016-04-05-14-14-00.bag &emsp;&emsp;测试前，需打开roscore节点管理器，如果报错，检查下是否刷新了环境变量(source ~/carto_ws/install_isolated/setup.bash)。 参考博客&emsp;&emsp;博客1，博客2","categories":[{"name":"SLAM建图算法","slug":"SLAM建图算法","permalink":"http://cxx0822.github.io/categories/SLAM建图算法/"}],"tags":[]},{"title":"基于ROS的视觉SLAM","slug":"基于ROS的视觉SLAM","date":"2019-10-24T01:13:20.000Z","updated":"2022-03-21T06:19:12.781Z","comments":true,"path":"2019/10/24/ji-yu-ros-de-shi-jue-slam/","link":"","permalink":"http://cxx0822.github.io/2019/10/24/ji-yu-ros-de-shi-jue-slam/","excerpt":"","text":"平台&emsp;&emsp;Ubuntu16.04(两台计算机)&emsp;&emsp;ROS Kinetic Kame&emsp;&emsp;turtlebot2&emsp;&emsp;Kinectv2 硬件安装 打开电源打开turtlebot2机器人的电源开关(确定电池有电)，此时底座的状态指示灯status常亮绿灯。 连接笔记本用usb转接线将底座的usb接口和电脑的笔记本usb接口接上。 连接kinectv2kinect的一端接turtlebot底座的12V 5A的接口，另一端接笔记本的usb接口。 软件安装——turtlebot更新软件源1sudo apt-get update 安装包文件(自动安装)12sudo apt-get install ros-kinetic-turtlebot ros-kinetic-turtlebot-apps ros-kinetic-turtlebot-interactions 12sudo apt-get install ros-kinetic-kobuki-ftdi ros-kinetic-ar-track-alvar-msgs ros-kinetic-turtlebot-simulator 安装包文件(手动安装)&emsp;&emsp;注：这一步可以先跳过，如果测试不成功再执行。&emsp;&emsp;先安装依赖库 12sudo apt-get install pyqt4-dev-toolssudo apt-get install pyqt5-dev-tools &emsp;&emsp;创建src文件夹，下载源码 123cd ~/catkin_ws/srcgit clone https://github.com/robotics-in-concert/rocon_qt_gui.gitgit clone https://github.com/turtlebot/turtlebot_simulation.git &emsp;&emsp;在catkin_ws目录下编译：catkin_make。 测试连接turtlebot2和计算机，输入测试命令：1ls /dev/kobuki &emsp;&emsp;打开turtlebot开关，输入命令：1roslaunch turtlebot_bringup minimal.launch &emsp;&emsp;运行后听到响声即表示连接成功。 参考博客&emsp;&emsp;网址 软件安装——kinetcv2安装包文件12345sudo apt-get install build-essential cmake pkg-config sudo apt-get install libusb-1.0-0-dev sudo apt-get install libturbojpeg libjpeg-turbo8-dev sudo apt-get install libglfw3-dev sudo apt-get install libopenni2-dev &emsp;&emsp;注：依次运行，下同。 安装依赖库 libfreenect2123456git clone https://github.com/OpenKinect/libfreenect2.git cd libfreenect2 mkdir build &amp;&amp; cd build cmake .. -DCMAKE_INSTALL_PREFIX=$HOME/freenect2 make make install 安装源文件 iai-kinect2123456cd ~/catkin_ws/src/ git clone https://github.com/code-iai/iai_kinect2.git cd iai_kinect2 rosdep install -r --from-paths . cd ~/catkin_ws catkin_make -DCMAKE_BUILD_TYPE=\"Release\" 刷新环境变量12gedit ~/.bashrcsource ~/catkin_ws/devel/setup.bash 运行节点123roscore roslaunch kinect2_bridge kinect2_bridge.launch rosrun kinect2_viewer kinect2_viewer &emsp;&emsp;注：分3个终端打开。 参考博客&emsp;&emsp;网址","categories":[{"name":"ROS开发与应用","slug":"ROS开发与应用","permalink":"http://cxx0822.github.io/categories/ROS开发与应用/"}],"tags":[]},{"title":"ROS的安装及简单使用","slug":"ROS的安装及简单使用","date":"2019-10-23T02:11:49.000Z","updated":"2022-03-21T06:19:12.572Z","comments":true,"path":"2019/10/23/ros-de-an-zhuang-ji-jian-dan-shi-yong/","link":"","permalink":"http://cxx0822.github.io/2019/10/23/ros-de-an-zhuang-ji-jian-dan-shi-yong/","excerpt":"","text":"平台&emsp;&emsp;Ubuntu 16.04 ROS简介&emsp;&emsp;ROS即机器人操作系统(Robot Operating System)，ROS系统是起源于2007年斯坦福大学人工智能实验室的项目与机器人技术公司Willow Garage的个人机器人项目之间的合作，2008年之后就由Willow Garage来进行推动。2010年Willow Garage公司发布了开源机器人操作系统ROS。&emsp;&emsp;ROS是面向机器人的开源的元操作系统(meta-operatingsystem)。它能够提供类似传统操作系统的诸多功能，如硬件抽象、底层设备控制、常用功能实现、进程间消息传递和程序包管理等。此外，它还提供相关工具和库，用于获取、编译、编辑代码以及在多个计算机之间运行程序完成分布式计算。&emsp;&emsp;目前主流的ROS版本如下：&emsp;&emsp;本博客采用的是Kinetic Kame版本，也是目前为止(2019年)较为稳定的一个版本。 ROS安装安装 Ubuntu 16.04&emsp;&emsp;首先安装好Ubuntu 16.04。(中英文皆可) 设置 sources.list&emsp;&emsp;为Ubuntu的包管理器增加源，设置计算机接受来自于 packages.ros.org的软件。1sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list' &emsp;&emsp;这一步会根据Ubuntu Linux发行版本的不同，添加不同的源。Ubuntu的版本通过lsb_release -sc获得。一旦添加了正确的软件库，操作系统就知道去哪里下载程序，并根据命令自动安装软件。 设置密钥&emsp;&emsp;这一步是为了确认源代码是正确的，并且没有人在未经所有者授权的情况下，修改任何程序代码。通常情况下，当添加完软件库时，已经添加了软件库的密钥，并将其添加到操作系统的可信任列表中。1sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 检查软件更新&emsp;&emsp;确保包管理器的索引已经更新至最新。1sudo apt-get update 正式安装&emsp;&emsp;这里安装的是桌面完整版，也是推荐安装的版本。1sudo apt-get install ros-kinetic-desktop-full &emsp;&emsp;这一步比较耗时，耐心等待。 初始化 rosdep&emsp;&emsp;在使用ROS之前，需要先初始化rosdep。rosdep使得你可以为你想要编译的源码，以及需要运行的ROS核心组件，简单地安装系统依赖。12sudo rosdep initrosdep update &emsp;&emsp;注1：多行命令，需依次输入，下同。&emsp;&emsp;注2：实际安装时，通常这里会有个报错：12ERROR: cannot download default sources list from:https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.listWebsite may be down. &emsp;&emsp;导致这个错误的原因为，该链接必须要科学上网才能打开，因此，需要将其域名改为实际的IP地址。首先打开hosts文件：1sudo gedit /etc/hosts &emsp;&emsp;然后添加以下命令：1199.232.28.133 raw.githubusercontent.com &emsp;&emsp;然后重新sudo rosdep init(会报一个已经存在的错误，不用管他)。 环境设置&emsp;&emsp;如果在每次一个新的终端启动时，ROS环境变量都能自动地添加进你的bash会话是非常方便，这可以通过如下命令来实现：12echo \"source /opt/ros/kinetic/setup.bash\" &gt;&gt; ~/.bashrcsource ~/.bashrc 构建包所需的依赖&emsp;&emsp;到这一步，应该已经安装好了运行核心ROS包的所有东西。要创建和管理你自己的ROS workspace，还有单独发布的许多的工具。比如，rosinstall是一个常用的命令行工具，使你可以通过一个命令为ROS包简单地下载许多源码树。1sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential &emsp;&emsp;至此，已经安装完了ROS的所有部分，下面可以进行一个简单的测试。 测试启动ROS核心管理器&emsp;&emsp;打开一个终端，输入以下命令：1roscore 启动乌龟仿真器节点&emsp;&emsp;再打开一个终端，输入以下命令：1rosrun turtlesim turtlesim_node 启动控制乌龟操作节点&emsp;&emsp;再打开一个终端，输入以下命令：1rosrun turtlesim turtle_teleop_key &emsp;&emsp;点击该终端，使其处于激活状态，然后按下键盘的方向键就可以看到小乌龟的运动了。 ROS实例——两台计算机的通信硬件平台&emsp;&emsp;两台安装了Ubuntu16.04和ROS kinetic的计算机&emsp;&emsp;路由器 软件配置安装chrony包，用于实现同步123sudo apt-get install chronysudo apt-get install ntpdatesudo ntpdate ntp.ubuntu.com 安装SSH服务器库12sudo apt-get install openssh-serverps -e|grep ssh 修改配置文件查看hostname和IP地址&emsp;&emsp;首先利用hostname命令查看服务器和客户端电脑的名字，假设为server_name和client_name。&emsp;&emsp;其次利用ifconfig命令查看服务器和客户端的IP地址(连接至同一局域网)，假设IP地址分别为：server_IP和client_IP(wlp4s0的网络地址)。 修改/etc/hosts文件和环境变量1.打开/etc/hosts文件：sudo gedit /etc/hosts，添加如下内容：12server_IP server_nameclient_IP client_name &emsp;&emsp;注：中间为tab键，实际操作时，注意替换名字。&emsp;&emsp;输入命令重启网络：sudo /etc/init.d/networking restart 2.打开bash文件：sudo gedit ~/.bashrc，服务器的计算机增加的内容为：12export ROS_MASTER_URL=http://client_IP:11311export ROS_HOSTNAME=server_name &emsp;&emsp;客户端的计算机增加的内容为：12export ROS_MASTER_URL=http://server_IP:11311export ROS_HOSTNAME=client_name 3.在服务器的计算机中可以输入以下内容进行测试：12ssh server_nameping client_name &emsp;&emsp;同理，客户端也可以进行测试。 编写程序创建文件夹 创建工作空间 123mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace 创建功能包 1catkin_create_pkg test roscpp geometry_msgs tf &emsp;&emsp;注：这里的test是功能包的名字，roscpp,geometry_msgs,tf是需要的依赖库。 编写cpp文件&emsp;&emsp;在test/src里面新建一个move_turtle.cpp文件。其内容如下：123456789101112131415161718192021222324252627282930313233#include &lt;ros/ros.h&gt;#include &lt;signal.h&gt;#include &lt;geometry_msgs/Twist.h&gt;ros::Publisher cmdVelPub;void shutdown(int sig)&#123; cmdVelPub.publish(geometry_msgs::Twist());//使机器人停止运动 ROS_INFO(\"move_turtle_goforward ended!\"); ros::shutdown();&#125;int main(int argc, char** argv)&#123; ros::init(argc, argv, \"move_turtle\"); //初始化ROS,它允许ROS通过命令行进行名称重映射 ros::NodeHandle node;//为这个进程的节点创建一个句柄 cmdVelPub = node.advertise&lt;geometry_msgs::Twist&gt;(\"/mobile_base/commands/velocity\", 1); //在/mobile_base/commands/velocity topic上发布一个geometry_msgs/Twist的消息 ros::Rate loopRate(10);//ros::Rate对象可以允许你指定自循环的频率 signal(SIGINT, shutdown); ROS_INFO(\"move_turtle cpp start...\"); geometry_msgs::Twist speed; // 控制信号载体 Twist message while (ros::ok()) &#123; speed.linear.x = 0.1; // 设置线速度为0.1m/s，正为前进，负为后退 speed.angular.z = 0; // 设置角速度为0rad/s，正为左转，负为右转 cmdVelPub.publish(speed); // 将刚才设置的指令发送给机器人 loopRate.sleep();//休眠直到一个频率周期的时间 &#125; return 0;&#125; &emsp;&emsp;该程序的作用是：使turtlebot一直以0.1m/s的速度前进。 修改CMakeLists.txt&emsp;&emsp;在test功能包中的CMakeList.txt文件的末尾加上两句：12add_executable(move_turtle src/move_turtle.cpp) target_link_libraries(move_turtle $&#123;catkin_LIBRARIES&#125;) 编译工程&emsp;&emsp;回到工作空间1cd ~/catkin_ws/ &emsp;&emsp;编译1catkin_make &emsp;&emsp;设置环境变量1source devel/setup.bash &emsp;&emsp;附：将工作空间永久添加到环境变量中：12echo \"source ~/catkin_ws/devel/setup.bash\" &gt;&gt; ~/.bashrcsource ~/.bashrc 启动turtlebot 打开turtlebot电源，并使其和客户端计算机连接，将客户端计算机放在turtlebot上。 在客户端计算机中，打开节点管理器(打开终端输入)：roscore，再打开一个终端启动节点：roslaunch kobuki_node minimal.launch。 在服务器计算机中也打开节点管理器，再打开一个终端，启动刚才的工程：rosrun test move_turtle。 此时就会看到turtlebot一直在直线运行，直到按下ctrl + c。 附：ROS官网教程 附 基于虚拟机VMware的Ubuntu18.04和ROS的安装平台&emsp;&emsp;虚拟机VMware Workstation 15&emsp;&emsp;Ubuntu18.04&emsp;&emsp;ROS Melodic Morenia 虚拟机安装Ubuntu18.04&emsp;&emsp;参考博客：VMware Workstation 15。序列号。&emsp;&emsp;实际安装时，按照步骤一步步来即可。设备配置那里后面可以更改，不用太纠结。&emsp;&emsp;安装完Ubuntu之后，和正常双系统一样，需要更换国内源，更新软件等。 安装ROS Melodic Morenia&emsp;&emsp;Ubuntu18.04对应的ROS系统为Melodic Morenia，安装过程和kinetic类似。参考博客：ROS Melodic Morenia安装。","categories":[{"name":"ROS开发与应用","slug":"ROS开发与应用","permalink":"http://cxx0822.github.io/categories/ROS开发与应用/"}],"tags":[]},{"title":"NAO_GolfVision_ML_C++使用说明","slug":"NAO-GolfVision-ML-C-使用说明","date":"2019-08-29T10:05:35.000Z","updated":"2022-03-31T12:39:34.106Z","comments":true,"path":"2019/08/29/nao-golfvision-ml-c-shi-yong-shuo-ming/","link":"","permalink":"http://cxx0822.github.io/2019/08/29/nao-golfvision-ml-c-shi-yong-shuo-ming/","excerpt":"","text":"平台&emsp;&emsp;Windows 10&emsp;&emsp;Visual studio 2015 概述&emsp;&emsp;本博客为我的Github上项目的说明文档。 添加文件至项目工程&emsp;&emsp;打开VS2015，并新建工程文件夹，然后将GitHub上的所有文件放至Project1-&gt;Project1文件夹中。&emsp;&emsp;然后依次将.h和.cpp文件分别添加头文件和源文件中。&emsp;&emsp;最后我们重新生成编译方案，检查代码是否正确。&emsp;&emsp;注：编译前，一定要确保Opencv3已经配置正确，且切换到Debug ×64模式。 生成特征向量文件&emsp;&emsp;打开主函数，打开计算正样本函数train.cal_pos_vector();，并关闭其余函数，运行开始调试(不执行)。注意将属性-&gt;链接器-&gt;系统中的子系统设置为控制台。12345678910111213141516#include \"classifierTrain.h\"int main()&#123; clock_t start, end; start = clock(); ClassifierTrain train; train.cal_pos_vector(\"img_train_pos/*.jpg\", \"label_train_pos/*.xml\", \"data_1.txt\"); //train.cal_neg_vector(\"img_train_neg/*.jpg\", \"data_2.txt\"); //train.result_test(\"img_test/*.jpg\"); end = clock(); double endtime = (double)(end - start) / CLOCKS_PER_SEC; cout &lt;&lt; \"Total time:\" &lt;&lt; endtime &lt;&lt; endl; //s为单位 return 0;&#125; &emsp;&emsp;在Project1文件夹中会生成data_1.txt文件。 &emsp;&emsp;然后打开计算负样本函数train.cal_neg_vector();，并关闭其余函数，运行开始调试(不执行)。&emsp;&emsp;在Project1文件夹中会生成data_2.txt文件。 配置训练数据&emsp;&emsp;打开Project1文件夹中的data.xml文件，将data_1.txt和data_2.txt中的数据放入到&lt;datamat&gt;中，并更改其中的&lt;rows&gt;和&lt;cols&gt;(根据实际情况而定)。并配置好&lt;labelsmat&gt;中的信息，即行列数一致，其中1的个数为data_1.txt中的行数，0的个数为data_2.txt中的行数。 预测分析&emsp;&emsp;打开测试函数result_test();，并关闭其余函数，运行开始调试(不执行)。&emsp;&emsp;总体上和之前python的基本一致。","categories":[{"name":"NAO高尔夫比赛","slug":"NAO高尔夫比赛","permalink":"http://cxx0822.github.io/categories/NAO高尔夫比赛/"}],"tags":[]},{"title":"PyTorch的简单使用","slug":"PyTorch的简单使用","date":"2019-08-18T01:56:38.000Z","updated":"2022-03-31T12:38:18.805Z","comments":true,"path":"2019/08/18/pytorch-de-jian-dan-shi-yong/","link":"","permalink":"http://cxx0822.github.io/2019/08/18/pytorch-de-jian-dan-shi-yong/","excerpt":"","text":"概述&emsp;&emsp;2017年1月，Facebook人工智能研究院(FAIR)团队在GitHub上开源了PyTorch，并迅速占领GitHub热度榜榜首。&emsp;&emsp;本博客为我的Github上的项目的使用说明。该项目主要是利用PyTorch深度学习框架进行简单的目标分类。 安装方法一——官网&emsp;&emsp;登陆PyTorch的官网，在下面找到相应的版本，执行命令即可(windows的安装命令可能是pip)：&emsp;&emsp;但实际测试发现，这种方式下载的很慢，我们可以用浏览器打开后面的网站，然后在网站中找到需要的版本，在点击下载即可。(可以用IDM下载器)然后使用命令pip install .\\torch-1.2.0-cp35-cp35m-win_amd64.whl和pip install .\\torchvision-0.4.0-cp35-cp35m-win_amd64.whl即可。 方法二——Anacoda+清华源&emsp;&emsp;这个也是大部分人的安装方法，网上有很多博客介绍，读者可以自行百度学习。 数据集&emsp;&emsp;对于目标分类的数据集，其文件夹目录如下所示：12345678910111213dataSet train 1 2 3 valid 1 2 3 test 1 2 3 &emsp;&emsp;首先新建3个文件夹，即train，valid和test。然后再分别新建类别文件夹，这里的1,2,3指的是3个类别，最后将图片按类别放入各自的文件夹中。 读取数据集&emsp;&emsp;load_data.py12345678910111213141516# -*-coding:utf-8-*-import torchimport torchvisionfrom torchvision import datasets, transformsimport osimport os.pathdef load_data(data_dir, image_size, batch_size): data_transform = transforms.Compose([transforms.Resize([image_size, image_size]), transforms.ToTensor()]) image_datasets = datasets.ImageFolder(root=os.path.join(data_dir), transform=data_transform) dataloader = torch.utils.data.DataLoader(dataset=image_datasets, batch_size=batch_size, shuffle=True) return dataloader &emsp;&emsp;PyTorch常用的读取图片数据集的函数为ImageFolder()，但使用该函数前必须保证图片已经按照刚才的文件夹形式存放好。&emsp;&emsp;该函数的函数声明如下：1ImageFolder(root,transform=None,target_transform=None,loader=default_loader) &emsp;&emsp;其中，root是在指定的root路径下面寻找图片，transform是对PIL Image图片进行转换操作，target_transform是对label进行变换，loader是指定加载图片的函数，默认操作是读取PIL image对象。&emsp;&emsp;这里我们需要对原始数据集进行简单的处理，即统一大小并转换为Tensor变量。也就是transforms.Resize()和transforms.ToTensor()两个函数。transforms.Compose()指的是将多个操作合并在一起。(当然这里也可以增加其他的图片处理函数)&emsp;&emsp;最后我们用DataLoader()读取数据集。其函数声明为：1DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, batch_sampler=None, num_workers=0) &emsp;&emsp;其中dataset是传入的数据集，batch_size是每个batch有多少个样本，shuffle是在每个epoch开始的时候，对数据进行重新排序，sampler是自定义从数据集中取样本的策略，如果指定这个参数，那么shuffle必须为False，batch_sampler与sampler类似，但是一次只返回一个batch的indices(索引)，num_workers这个参数决定了有几个进程来处理data loading。0意味着所有的数据都会被load进主进程。(默认为0)&emsp;&emsp;这里的dataset就是之前ImageFolder()的返回值，这里我们选择shuffle为True，其他除了batch_size均为默认值。&emsp;&emsp;dataloader本质是一个可迭代对象，使用iter()访问，不能使用next()访问；使用iter(dataloader)返回的是一个迭代器，然后可以使用next访问。&emsp;&emsp;我们可以使用下面的测试函数简单看一下数据集。123456789if __name__ == \"__main__\": data_dir_train = \"dataSet/train\" train_data = load_data(data_dir_train, 224, 4) images, labels = next(iter(train_data)) img = torchvision.utils.make_grid(images) img = img.numpy().transpose(1, 2, 0) import matplotlib.pyplot as plt plt.imshow(img) plt.show() &emsp;&emsp;显示结果为： 搭建网络模型&emsp;&emsp;model.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*-coding:utf-8-*-import torchimport torch.nn.functional as Fclass Models(torch.nn.Module): def __init__(self, image_dim, n_classes): super(Models, self).__init__() self.image_dim = image_dim self.n_classes = n_classes self.Conv = torch.nn.Sequential( torch.nn.Conv2d(in_channels=self.image_dim, out_channels=64, kernel_size=3, stride=1, padding=1), torch.nn.ReLU(), torch.nn.Conv2d(in_channels=64, out_channels=64, kernel_size=3, stride=1, padding=1), torch.nn.ReLU(), torch.nn.MaxPool2d(kernel_size=2, stride=2), torch.nn.Conv2d(in_channels=64, out_channels=128, kernel_size=3, stride=1, padding=1), torch.nn.ReLU(), torch.nn.Conv2d(in_channels=128, out_channels=128, kernel_size=3, stride=1, padding=1), torch.nn.ReLU(), torch.nn.MaxPool2d(kernel_size=2, stride=2), torch.nn.Conv2d(in_channels=128, out_channels=256, kernel_size=3, stride=1, padding=1), torch.nn.ReLU(), torch.nn.Conv2d(in_channels=256, out_channels=256, kernel_size=3, stride=1, padding=1), torch.nn.ReLU(), torch.nn.Conv2d(in_channels=256, out_channels=256, kernel_size=3, stride=1, padding=1), torch.nn.ReLU(), torch.nn.MaxPool2d(kernel_size=2, stride=2), torch.nn.Conv2d(in_channels=256, out_channels=512, kernel_size=3, stride=1, padding=1), torch.nn.ReLU(), torch.nn.Conv2d(in_channels=512, out_channels=512, kernel_size=3, stride=1, padding=1), torch.nn.ReLU(), torch.nn.Conv2d(in_channels=512, out_channels=512, kernel_size=3, stride=1, padding=1), torch.nn.ReLU(), torch.nn.MaxPool2d(kernel_size=2, stride=2), ) self.Classes = torch.nn.Sequential( torch.nn.Linear(in_features=14 * 14 * 512, out_features=256), # 14 * 14 * 512是根据图像的输入和网络结构算出来的 torch.nn.ReLU(), torch.nn.Dropout(p=0.5), torch.nn.Linear(in_features=256, out_features=self.n_classes) ) def forward(self, input): x = self.Conv(input) x = x.view(-1, 14 * 14 * 512) x = self.Classes(x) return x &emsp;&emsp;在Pytorch中，搭建模型的常用做法是新建一个类，并继承torch.nn.Module这个类，然后在__init__()方法中定义自己的卷积、池化和全连接层等。这里比较简单，熟悉深度学习CNN网络结构的都能看懂。唯一和其他框架不同的是，这里的全连接层的第一个参数，需要自己计算，即代码中的self.Classes中的第一个in_features=14 * 14 * 512，这个是根据输入图片的大小，这里为224*224，然后经过一系列网络结构后得到的输出Tensor后的大小。读者有兴趣可以自己计算一遍，如果更改了图片的大小也需要重新计算。&emsp;&emsp;附：计算公式 \\frac{n+2p-f}{s}+1训练模型&emsp;&emsp;train.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# -*-coding:utf-8-*-import torchfrom torch.autograd import Variablefrom tensorboardX import SummaryWriterfrom model import Modelsfrom load_data import * import yamlwith open(\"info.yml\") as stream: my_data = yaml.load(stream, Loader=yaml.FullLoader) # python3.6 可能需要去掉 Loader=yaml.FullLoaderdata_dir_train = my_data['data_dir_train']data_dir_valid = my_data['data_dir_valid']image_dim = my_data['image_dim'] n_classes = my_data['n_classes'] image_size = my_data['image_size']batch_size = my_data['batch_size']learning_rate = my_data['learning_rate']epochs = my_data['epochs']writer = SummaryWriter()def my_train(): use_gpu = torch.cuda.is_available() dataloader = &#123;\"train\": load_data(data_dir_train, image_size, batch_size), \"valid\": load_data(data_dir_valid, image_size, batch_size)&#125; model = Models(image_dim, n_classes) loss_f = torch.nn.CrossEntropyLoss() optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate) if use_gpu: model = model.cuda() for epoch in range(epochs): print(\"Epoch &#123;&#125;/&#123;&#125;\".format(epoch + 1, epochs)) print(\"-\" * 10) running_loss = 0.0 train_correct = 0 train_total = 0 for i, data in enumerate(dataloader[\"train\"], 0): inputs, train_labels = data if use_gpu: inputs, labels = Variable(inputs.cuda()), Variable(train_labels.cuda()) else: inputs, labels = Variable(inputs), Variable(train_labels) optimizer.zero_grad() outputs = model(inputs) _, train_predicted = torch.max(outputs.data, 1) train_correct += (train_predicted == labels.data).sum() loss = loss_f(outputs, labels) loss.backward() optimizer.step() running_loss += loss.item() train_total += train_labels.size(0) print('train %d epoch loss: %.3f acc: %.3f ' % (epoch + 1, running_loss / train_total, 100 * train_correct / train_total)) writer.add_scalar('Train/Loss', running_loss / train_total, epoch + 1) writer.add_scalar('Train/Acc', 100 * train_correct / train_total, epoch + 1) # 模型测试 correct = 0 test_loss = 0.0 test_total = 0 test_total = 0 model.eval() for data in dataloader[\"valid\"]: images, labels = data if use_gpu: images, labels = Variable(images.cuda()), Variable(labels.cuda()) else: images, labels = Variable(images), Variable(labels) outputs = model(images) _, predicted = torch.max(outputs.data, 1) loss = loss_f(outputs, labels) test_loss += loss.item() test_total += labels.size(0) correct += (predicted == labels.data).sum() print('test %d epoch loss: %.3f acc: %.3f ' % (epoch + 1, test_loss / test_total, 100 * correct / test_total)) writer.add_scalar('Test/Loss', test_loss / test_total, epoch + 1) writer.add_scalar('Test/Acc', 100 * correct / test_total, epoch + 1) writer.close() torch.save(model, 'model.pt')if __name__ == \"__main__\": my_train() &emsp;&emsp;首先从配置文件中导入一些必要的参数信息。在正式训练前，可以先检查一下是否装了GPU加速，即torch.cuda.is_available()。为了更好的显示效果，可以安装tensorboardX图形化显示工具。先定义一个writer，即writer = SummaryWriter()。下面正式进入训练。&emsp;&emsp;训练分为训练集和测试集，并分别计算其正确率和Loss值。然后打印每次迭代的相应信息，并将正确率和Loss写入tensorboardX的scalar中，最后关闭writer并保存模型。&emsp;&emsp;训练过程：&emsp;&emsp;训练结束后，会在文件夹内生成model.pt文件和runs文件夹。其中model.pt就是模型文件，runs文件夹下会有一个以时间命名的文件夹，里面存放的就是tensorboardX生成的日志文件。cd到日志文件的上一层文件夹下，并输入tensorboard查看指令：tensorboard --logdir=***(***就是日志文件的上一层文件夹，不需要引号)。然后将生成的网址放入浏览器中就可以看到可视化的结果了(可能需要IE浏览器)。 预测&emsp;&emsp;predict.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import torchfrom torch.autograd import Variablefrom model import Modelsfrom load_data import * import matplotlib.pyplot as pltimport yamlwith open(\"info.yml\") as stream: my_data = yaml.load(stream, Loader=yaml.FullLoader)data_dir_test = my_data['data_dir_test']data_dir_valid = my_data['data_dir_valid']image_dim = my_data['image_dim'] n_classes = my_data['n_classes'] image_size = my_data['image_size']batch_size = 4def my_predict(): use_gpu = torch.cuda.is_available() test_data = load_data(data_dir_test, image_size=image_size, batch_size=batch_size) X_test, y_test = next(iter(test_data)) model = torch.load('model.pt') if use_gpu: model = model.cuda() if use_gpu: images = Variable(X_test.cuda()) else: images = Variable(X_test) outputs = model(images) _, predicted = torch.max(outputs.data, 1) print(\"Predict Label is: \", predicted.data) print(\"Real Label is :\", y_test.data) img = torchvision.utils.make_grid(X_test) img = img.numpy().transpose([1, 2, 0]) # 转成numpy在转置 plt.imshow(img) plt.show()if __name__ == \"__main__\": my_predict() &emsp;&emsp;首先利用load()函数导入模型，然后再将测试图片放入模型中得到预测结果。并将预测标签和实际标签分别打印出来。如图所示：&emsp;&emsp;实际测试下来发现，检测效果还是不错的，只有个别几个会判断错误。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://cxx0822.github.io/categories/深度学习/"}],"tags":[]},{"title":"支持向量机的原理及python实现","slug":"支持向量机的原理及python实现","date":"2019-08-11T11:21:14.000Z","updated":"2022-03-31T12:36:19.052Z","comments":true,"path":"2019/08/11/zhi-chi-xiang-liang-ji-de-yuan-li-ji-python-shi-xian/","link":"","permalink":"http://cxx0822.github.io/2019/08/11/zhi-chi-xiang-liang-ji-de-yuan-li-ji-python-shi-xian/","excerpt":"","text":"概述&emsp;&emsp;支持向量机(support vector machine，一般称为SVM。是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。&emsp;&emsp;因为其较低的错误率，使其被认为是机器学习中目前为止最好的分类器。 基本概念&emsp;&emsp;上图一共有四个部分，A为原始数据集，一共有两类，分别在左边和右边，B，C，D分别给出了一条可以将两类分开的直线。这条直线被称为分隔超平面。如果是在二维平面上，这个超平面就是一条直线，如果是三维的，就是一个平面。如果数据集是N维的话，就需要一个N-1维的对其分隔，也就是分类的决策边界。&emsp;&emsp;对于上图的三种决策边界，我们明显认为D的决策边界是最好的，因为其距离两类的间距都是最大的。也就是说，我们希望找到离分隔超平面最近的点，确保它们离分隔面的距离尽可能地远。这里点到分割面地距离被称为间隔。我们希望间隔尽可能地大。&emsp;&emsp;而所谓的支持向量就是离分隔超平面最近的那些点，机的意思就是决策边界。所以接下来的任务就是最大化支持向量到分隔面的距离。 任务——寻找最大间隔&emsp;&emsp;首先我们要确定点到决策边界的距离，也就是所谓的函数间隔(可能有的书这里指的是几何间隔)。&emsp;&emsp;分隔超平面的直线可以记为$y=\\omega ^Tx + b$(这里的$\\omega$和$x$都是一个向量，$b$类似于截距)，然后计算点A到分隔面的法线或垂线的长度，利用点到平面的公式可以得到其函数间隔为： d=\\frac{\\left | \\omega ^{T}x+b \\right |}{\\left \\| \\omega \\right \\|}&emsp;&emsp;所以我们对一个数据点进行分类时，当超平面离数据点的“间隔”越大，分类的置信度也越大。为了使得分类的确信度尽量高，需要让所选择的超平面能够最大化这个“间隔”值。&emsp;&emsp;但是只有这个间隔也不够，因为我们有两类数据，所以还需要再定义类别标签的概念。&emsp;&emsp;这里的类别的定义和之前的机器学习算法不同，使用的是-1和+1两种标签，即： g\\left ( z \\right )=g\\left ( \\omega ^{T}x+b \\right )=\\left\\{\\begin{matrix} -1 & z\\geqslant 0\\\\ 1 & z < 0 \\end{matrix}\\right.&emsp;&emsp;为什么这样定义呢？因为之前我们定义的间隔公式中含有绝对值项$\\left | \\omega ^{T}x+b \\right |$，这对后面的计算来说不太方便，而现在我们可以将其替换为$lable\\left ( \\omega ^{T}x+b \\right )$，因为这是一个恒正的表达式。如果数据点处于正方向(+1类)，并且离分隔面很远的位置时，$\\left ( \\omega ^{T}x+b \\right )$会是一个很大的正数，同时$lable\\left ( \\omega ^{T}x+b \\right )$也是一个很大的正数。反之，如果在负方向，其最终的值也是一个正数(负负得正)。而且标签值为+1和-1，也不影响最终的间距值。&emsp;&emsp;综上所述，我们最终的目标任务可以用以下的数学表达式表示： arg \\underset{\\omega,b}{max}\\left \\{ \\underset{n}{min}\\left ( label\\cdot \\left ( \\omega ^{T}x+b \\right ) \\right ) \\cdot \\frac{1}{\\left \\| \\omega \\right \\|}\\right \\}&emsp;&emsp;公式前面的$argmax$表示的是间隔最大值时，参数$\\omega,b$的取值。$min$表示的是具有最小间隔的数据点。&emsp;&emsp;但是这里面都是乘积项，对其求最值比较困难，如果能固定某个乘积项，只求其中一个的最值就会简单很多，而经过之前的分析，$lable*\\left ( \\omega ^{T}x+b \\right )$项都是大于0的，在准确地说其值是$\\geqslant 1$的(如下图所示)。那么其最小值为1，就可以去掉该项。&emsp;&emsp;所以我们就将此问题转换为了约束条件下的极值问题，即&emsp;&emsp;目标函数为： max\\frac{1}{\\left \\| \\omega \\right \\|}&emsp;&emsp;约束条件为： s.t. \\quad \\quad y_i*\\left ( \\omega ^{T}x_i+b \\right) \\geqslant 1,i=1,2,...,n注：这里的$label$替换为了$y_i$。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://cxx0822.github.io/categories/机器学习/"}],"tags":[]},{"title":"NAO_GolfVision_ML使用说明","slug":"NAO-GolfVision-ML使用说明","date":"2019-08-05T01:50:24.000Z","updated":"2022-03-31T12:31:26.267Z","comments":true,"path":"2019/08/05/nao-golfvision-ml-shi-yong-shuo-ming/","link":"","permalink":"http://cxx0822.github.io/2019/08/05/nao-golfvision-ml-shi-yong-shuo-ming/","excerpt":"","text":"概述&emsp;&emsp;本博客是我的Github上的NAO_GolfVision_ML项目的使用说明。该项目是NAO高尔夫比赛中的视觉系统设计，主要是利用opencv和机器学习算法对视觉系统中的目标进行分类检测。详细的代码解释见另一篇博客：NAO比赛视觉系统设计 平台&emsp;&emsp;Windows 10&emsp;&emsp;python2.7 32(NAO支持的版本) 文件夹结构&emsp;&emsp;该文件夹主要分为三个部分，第一部分是数据集，包含图片和标签的数据集，其中图片为NAO摄像头实际拍摄的图像，像素大小为640*480，标签为labelImg软件标注生成的xml文件，其中正负样本分开存放。&emsp;&emsp;第二部分是代码，其中TargetDetection.py和TargetFeature.py是opnecv对目标的检测和机器学习对目标的特征提取文件，Classifier,py和ClassifierTrain,py是机器学习的分类器和训练文件。其中ClassifierTrain,py是主函数文件。&emsp;&emsp;第三部分是其他文件，主要包含3张测试图片，即足球、红球和黄杆，3张数据文件，即总数据，正样本数据和负样本数据，另外包含一个renamefile.py，主要是为了统一图片和标签的名字。 TargetDetection.py&emsp;&emsp;该文件包含3个类，其中TargetDetection是基类，HoughDetection是霍夫圆检测类，ContoursDetection是轮廓检测类。读者也可以使用其他检测算法新建自己的检测类。 TargetDetection&emsp;&emsp;该类包含图像预处理函数preProcess()，滤波函数filter()和滑动条函数sliderObjectHSV()。 使用方法123456if __name__ == '__main__': Img = cv2.imread(\"stick.jpg\") # 注意替换照片 # 测试HSV滑动条函数 tarDet = TargetDetection(Img) tarDet.sliderObjectHSV(\"stick\") &emsp;&emsp;首先打开一张测试图片，实际比赛中可以将此替换为NAO拍摄的图片，然后实例化类，并调用滑动条函数。注意图片名字和类别名字要一致。 &emsp;&emsp;不断调整滑动条的参数，以得到理想效果。 HoughDetection&emsp;&emsp;该类包含霍夫圆检测函数houghDetection()，信息转换函数circle2Rect()，显示结果函数showHoughResult()和霍夫圆检测滑动条函数houghSlider()。 使用方法123456if __name__ == '__main__': Img = cv2.imread(\"redBall.jpg\") # 注意替换照片 # 测试霍夫圆检测滑动条(球类目标专用) houghDet = HoughDetection(Img) houghDet.houghSlider(\"redBall\") &emsp;&emsp;不断调整滑动条的参数，以得到理想效果。 ContoursDetection&emsp;&emsp;该类包含轮廓检测函数contoursDetection()，信息转换函数contour2Rect()，显示结果函数showContourResult()和轮廓检测滑动条函数contoursSlider()。 使用方法123456if __name__ == '__main__': Img = cv2.imread(\"stick.jpg\") # 注意替换照片 # 测试轮廓检测滑动条(黄杆专用) ContoursDet = ContoursDetection(Img) ContoursDet.contoursSlider(\"stick\") &emsp;&emsp;不断调整滑动条的参数，以得到理想效果。 TargetFeature.py&emsp;&emsp;该文件包含2个类，其中HogFeature是提取HOG特征，ColorFeature是提取颜色特征。读者也可以使用其他特征提取算法。最后统一成向量的形式即可。 使用方法&emsp;&emsp;这部分主要是结合之后的分类器训练使用。 Classifier.py&emsp;&emsp;该文件包含2个类，其中Logistic是逻辑回归分类器，KNN是K近邻分类器。读者也可以使用自己的分类器。 使用方法&emsp;&emsp;这部分主要是结合之后的分类器训练使用。 ClassifierTrain.py&emsp;&emsp;该文件包含以下函数： parseXml()：解析标注文件函数， reshapeBallRect()：重造球类目标矩形框函数， reshapeStickRect()：重造黄杆类目标矩形框函数， circle2Rect()：转换信息函数， calColorFeature()：计算颜色特征函数， calHOGFeature()：计算HOG特征函数， calPosVector()：计算正样本向量函数 calNegVector()：计算负样本向量函数 resultTest()：分类结果测试函数 使用方法&emsp;&emsp;首先将数据集正确的放入到文件夹中，越多越好，至少上百张，其次更改calPosVector()函数里面的路径位置及信息。&emsp;&emsp;其中画图部分的函数，即：12345 # cv2.rectangle(srcImg, (newInitX, newInitY), (newEndX, newEndY), (0, 0, 255), 2) # 画矩形 # cv2.imshow(\"test \" + str(i), srcImg) # cv2.waitKey(300) # cv2.destroyAllWindows() &emsp;&emsp;在实际训练时需要注释掉，否则会把标注框也认为是正样本。该部分主要是为了测试标注框是否准确，读者可以先保留该部分运行一遍，再注释后运行一遍，实际的特征向量以加了注释后的为准。 12if __name__ == '__main__': calPosVector(\"data_pos.txt\") # 计算正样本的特征向量 &emsp;&emsp;运行过程中，会显示出特征向量的总数，如果是320则是正确的，当然了如果读者自己加入了其他的特征提取，可以自己算一遍。&emsp;&emsp;最后所有的特征向量会存放在data_pos.txt的文件夹下。 &emsp;&emsp;负样本的使用方法同上。其最终的特征向量会存放在data_neg.txt文件夹下，最后将这2个txt文件的数据合并到data.txt文件中。 &emsp;&emsp;最后再调用测试分类结果函数resultTest()即可，在里面输入相应的分类器，当然也可以是自己的。&emsp;&emsp;最终结果如图所示，红色为正确的，黄色为错误的。实际测试发现，只要目标不在边界上，其正确率几乎可以达到100%，对于边界上的情况，个别几个情况分类错误，但这对比赛也并没有太大的影响。整体效果还是非常不错的，可以达到比赛的实时检测要求。 注：我这里只对足球类目标进行了检测，没用对红球和黄杆测试，读者有兴趣的话可以自己采集数据并测试一下，欢迎大家留言讨论。 附：sklearn机器学习库实现分类器&emsp;&emsp;这里提供一个强大的机器学习库sklearn来实现之前的分类器，首先需要通过pip安装(pip install -U scikit-learn)，由于NAO本身并不支持这个第三方库，所以我们如果要使用的话，需要将下载好的sklearn库上传至NAO中。&emsp;&emsp;和之前一样，还是新建一个py文件，里面可以新建若干各类，每个类实现一个分类器。 实现原理&emsp;&emsp;sklearn实现机器学习算法特别简单，大致可以分为三步，1.读取数据，2.构建分类器并训练参数，3.使用分类器预测。&emsp;&emsp;下面以Logistic回归为例，详细讲解：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import sklearnfrom sklearn.linear_model import LogisticRegressionCV, LinearRegressionfrom sklearn.model_selection import train_test_splitimport numpy as npfrom sklearn.externals import joblibclass LogisticSk(object): def __init__(self, filename): self.filename = filename def file2matrix(self): fr = open(self.filename) arrayOfLines = fr.readlines() numberOfLines = len(arrayOfLines) returnMat = np.zeros((numberOfLines, 320)) classLabelVector = [] index = 0 for line in arrayOfLines: line = line.strip() listFromLine = line.split(' ') returnMat[index, :] = listFromLine[0:320] if listFromLine[-1] == '0': classLabelVector.append(0) elif listFromLine[-1] == '1': classLabelVector.append(1) index += 1 return returnMat, classLabelVector def trainClassify(self): X, Y = self.file2matrix() X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.1, random_state=0) lr = LogisticRegressionCV(multi_class=\"ovr\", fit_intercept=True, Cs=np.logspace(-2, 2, 20), cv=2, penalty=\"l2\", solver=\"lbfgs\", tol=0.01) lr.fit(X_train, Y_train) return lr def saveClassify(self, model, path): joblib.dump(model, path) def readClassify(self, path): return joblib.load(path) def predictClassify(self, lr, X_test): Y_predict = lr.predict(X_test) return Y_predict &emsp;&emsp;这里为了和之前的变量名不一样，在分类器后面加了SK，表示是用sklearn库实现的。 读取数据&emsp;&emsp;这部分可以参考之前的file2matrix()函数。 构建分类器并训练&emsp;&emsp;在构建分类器之前，我们可以先用train_test_split()函数将数据集分为训练集和测试集，以便后续的分析(当然也可以直接用原来的数据)。&emsp;&emsp;接下来就是使用sklearn库中自带的分类器训练，这里注意首先要将分类器所在的类导入进来，比如这里是LogisticRegressionCV()分类器函数，它是在sklearn.linear_model类中的。然后可以设置分类器的参数，当然也可以使用默认值。最后使用fit()函数训练以得到相应的参数。 保存和读取模型&emsp;&emsp;训练一次数据集通常需要花费一定的时间，这对实时性的要求显然是不利的，所以通常的做法是先将训练好的模型保存下来，然后再读取。&emsp;&emsp;sklearn中保存和读取的模块是joblib(也有其他的)，其dump()和load()函数分别是读取和保存。注：保存的模型一般后缀名为.m。 使用模型预测&emsp;&emsp;使用predict()函数预测即可，输入参数为待预测的数据。 结果分析&emsp;&emsp;实际测试下来发现，sklearn库的分类器函数和自己写的分类器的效果几乎差不多，总体效果还是比较好的。","categories":[{"name":"NAO高尔夫比赛","slug":"NAO高尔夫比赛","permalink":"http://cxx0822.github.io/categories/NAO高尔夫比赛/"}],"tags":[]},{"title":"深度学习的数据集处理","slug":"深度学习的数据集处理","date":"2019-07-26T05:46:21.000Z","updated":"2022-03-31T12:29:11.998Z","comments":true,"path":"2019/07/26/shen-du-xue-xi-de-shu-ju-ji-chu-li/","link":"","permalink":"http://cxx0822.github.io/2019/07/26/shen-du-xue-xi-de-shu-ju-ji-chu-li/","excerpt":"","text":"概述&emsp;&emsp;只是整理，不展开叙述 平台&emsp;&emsp;Ubuntu / Windows&emsp;&emsp;python3.5 / 3.6 目标分类数据集&emsp;&emsp;目标分类的数据集通常为若干个类别文件夹，然后每个文件夹存放着若干个该类别的图片。数据集通常由图片+类别标签组成的。图片是不需要标注的。 文件夹设置&emsp;&emsp;首先新建一个文件夹dataSet(当然可以取其他名字，下同)，然后新建2个文件夹test和val分别存放训练集数据和验证集数据，另外在新建1个文件夹record保存tfrecords数据格式的文件：1234dataSet record test val 获取数据集&emsp;&emsp;目标分类的数据集的大小尽可能地小一点，仅包含分类物体即可，如下面的几个图片：&emsp;&emsp;可以从网上获取或自己拍摄采集。 放入数据集&emsp;&emsp;在test和val文件夹下依次新建分类的类别文件夹，并将数据集放入各自的文件夹中。 生成数据集文本文件&emsp;&emsp;这一步主要是生成记录数据集路径的txt文件，以便后续读取方便。&emsp;&emsp;create_labels_files.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*-coding:utf-8-*-import osimport os.pathdef get_files_list(dir): files_list = [] for parent, dirnames, filenames in os.walk(dir): for filename in filenames: curr_file = parent.split(os.sep)[-1] if curr_file == 'flower': labels = 0 elif curr_file == 'guitar': labels = 1 elif curr_file == 'animal': labels = 2 elif curr_file == 'houses': labels = 3 elif curr_file == 'plane': labels = 4 files_list.append([os.path.join(curr_file, filename), labels]) return files_listdef write_txt(content, filename, mode='w'): with open(filename, mode) as f: for line in content: str_line = \"\" for col, data in enumerate(line): if not col == len(line) - 1: str_line = str_line + str(data) + \" \" else: str_line = str_line + str(data) + \"\\n\" f.write(str_line)if __name__ == '__main__': train_dir = 'dataSet/train' train_txt = 'dataSet/train.txt' train_data = get_files_list(train_dir) write_txt(train_data, train_txt, mode='w') val_dir = 'dataSet/val' val_txt = 'dataSet/val.txt' val_data = get_files_list(val_dir) write_txt(val_data, val_txt, mode='w') &emsp;&emsp;生成的train.txt： 制作tfrecords数据格式&emsp;&emsp;create_tf_record.py，主要的函数为： create_records()：用于制作records数据的函数； read_records()：用于读取records数据的函数； get_batch_images():用于生成批训练数据的函数； get_example_nums：统计tf_records图像的个数(example个数)； disp_records(): 解析record文件，并显示图片，主要用于验证生成record文件是否成功。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205# -*-coding: utf-8 -*-import tensorflow as tfimport numpy as npimport osimport cv2import matplotlib.pyplot as pltimport randomfrom PIL import Imagedef _int64_feature(value): return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))def _bytes_feature(value): return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))def float_list_feature(value): return tf.train.Feature(float_list=tf.train.FloatList(value=value))def get_example_nums(tf_records_filenames): nums = 0 for record in tf.python_io.tf_record_iterator(tf_records_filenames): nums += 1 return numsdef show_image(title, image): plt.imshow(image) plt.axis('on') plt.title(title) plt.show()def load_labels_file(filename, labels_num=1, shuffle=False): images = [] labels = [] with open(filename) as f: lines_list = f.readlines() if shuffle: random.shuffle(lines_list) for lines in lines_list: line = lines.rstrip().split(' ') label = [] for i in range(labels_num): label.append(int(line[i + 1])) images.append(line[0]) labels.append(label) return images, labelsdef read_image(filename, resize_height, resize_width, normalization=False): bgr_image = cv2.imread(filename) if len(bgr_image.shape) == 2: print(\"Warning:gray image\", filename) bgr_image = cv2.cvtColor(bgr_image, cv2.COLOR_GRAY2BGR) rgb_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2RGB) if resize_height &gt; 0 and resize_width &gt; 0: rgb_image = cv2.resize(rgb_image, (resize_width, resize_height)) rgb_image = np.asanyarray(rgb_image) if normalization: rgb_image = rgb_image / 255.0 return rgb_imagedef get_batch_images(images, labels, batch_size, labels_nums, one_hot=False, shuffle=False, num_threads=1): min_after_dequeue = 200 capacity = min_after_dequeue + 3 * batch_size if shuffle: images_batch, labels_batch = tf.train.shuffle_batch([images, labels], batch_size=batch_size, capacity=capacity, min_after_dequeue=min_after_dequeue, num_threads=num_threads) else: images_batch, labels_batch = tf.train.batch([images, labels], batch_size=batch_size, capacity=capacity, num_threads=num_threads) if one_hot: labels_batch = tf.one_hot(labels_batch, labels_nums, 1, 0) return images_batch, labels_batchdef read_records(filename, resize_height, resize_width, type=None): filename_queue = tf.train.string_input_producer([filename]) reader = tf.TFRecordReader() _, serialized_example = reader.read(filename_queue) features = tf.parse_single_example( serialized_example, features=&#123; 'image_raw': tf.FixedLenFeature([], tf.string), 'height': tf.FixedLenFeature([], tf.int64), 'width': tf.FixedLenFeature([], tf.int64), 'depth': tf.FixedLenFeature([], tf.int64), 'label': tf.FixedLenFeature([], tf.int64) &#125; ) tf_image = tf.decode_raw(features['image_raw'], tf.uint8) tf_height = features['height'] tf_width = features['width'] tf_depth = features['depth'] tf_label = tf.cast(features['label'], tf.int32) tf_image = tf.reshape(tf_image, [resize_height, resize_width, 3]) if type is None: tf_image = tf.cast(tf_image, tf.float32) elif type == 'normalization': tf_image = tf.cast(tf_image, tf.float32) * (1. / 255.0) elif type == 'centralization': tf_image = tf.cast(tf_image, tf.float32) * (1. / 255) - 0.5 return tf_image, tf_labeldef create_records(image_dir, file, output_record_dir, resize_height, resize_width, shuffle, log=5): images_list, labels_list = load_labels_file(file, 1, shuffle) writer = tf.python_io.TFRecordWriter(output_record_dir) for i, [image_name, labels] in enumerate(zip(images_list, labels_list)): image_path = os.path.join(image_dir, images_list[i]) if not os.path.exists(image_path): print('Err:no image', image_path) continue image = read_image(image_path, resize_height, resize_width) image_raw = image.tostring() if i % log == 0 or i == len(images_list) - 1: print('------------processing:%d-th------------' % (i)) print('current image_path=%s' % (image_path), 'shape:&#123;&#125;'.format(image.shape), 'labels:&#123;&#125;'.format(labels)) label = labels[0] example = tf.train.Example(features=tf.train.Features(feature=&#123; 'image_raw': _bytes_feature(image_raw), 'height': _int64_feature(image.shape[0]), 'width': _int64_feature(image.shape[1]), 'depth': _int64_feature(image.shape[2]), 'label': _int64_feature(label) &#125;)) writer.write(example.SerializeToString()) writer.close()def disp_records(record_file, resize_height, resize_width, show_nums=4): tf_image, tf_label = read_records(record_file, resize_height, resize_width, type='normalization') init_op = tf.initialize_all_variables() with tf.Session() as sess: sess.run(init_op) coord = tf.train.Coordinator() threads = tf.train.start_queue_runners(sess=sess, coord=coord) for i in range(show_nums): image, label = sess.run([tf_image, tf_label]) print('shape:&#123;&#125;,tpye:&#123;&#125;,labels:&#123;&#125;'.format(image.shape, image.dtype, label)) show_image(\"image:%d\" % (label), image) coord.request_stop() coord.join(threads)def batch_test(record_file, resize_height, resize_width): tf_image, tf_label = read_records(record_file, resize_height, resize_width, type='normalization') image_batch, label_batch = get_batch_images(tf_image, tf_label, batch_size=4, labels_nums=5, one_hot=False, shuffle=False) init = tf.global_variables_initializer() with tf.Session() as sess: sess.run(init) coord = tf.train.Coordinator() threads = tf.train.start_queue_runners(coord=coord) for i in range(4): images, labels = sess.run([image_batch, label_batch]) show_image(\"image\", images[0, :, :, :]) print('shape:&#123;&#125;,tpye:&#123;&#125;,labels:&#123;&#125;'.format(images.shape, images.dtype, labels)) coord.request_stop() coord.join(threads)if __name__ == '__main__': resize_height = 299 resize_width = 299 shuffle = True log = 5 image_dir = 'dataSet/train' train_labels = 'dataSet/train.txt' train_record_output = 'dataSet/record/train&#123;&#125;.tfrecords'.format(resize_height) create_records(image_dir, train_labels, train_record_output, resize_height, resize_width, shuffle, log) train_nums = get_example_nums(train_record_output) print(\"save train example nums=&#123;&#125;\".format(train_nums)) image_dir = 'dataSet/val' val_labels = 'dataSet/val.txt' val_record_output = 'dataSet/record/val&#123;&#125;.tfrecords'.format(resize_height) create_records(image_dir, val_labels, val_record_output, resize_height, resize_width, shuffle,log) val_nums = get_example_nums(val_record_output) print(\"save val example nums=&#123;&#125;\".format(val_nums)) batch_test(train_record_output, resize_height, resize_width) 目标检测数据集&emsp;&emsp;目标检测数据集的格式一般为VOC格式，即由图片文件夹，标注文件夹和txt图片信息文件夹组成。 文件夹设置&emsp;&emsp;首先新建一个文件夹VOCdevkit，然后在里面在新建1个文件夹VOC2019(当然也可以取其他年份)，然后新建3个文件夹Annotations，ImageSets和JPEGImages，其中ImageSets文件夹下再新建一个Main文件夹，在里面新建4个txt文件：test.txt，train.txt，trainval.txt，val.txt。12345678910VOCdevkit VOC2019 Annotations ImageSets Main test.txt train.txt trainval.txt val.txt JPEGImages 获取数据集&emsp;&emsp;目标检测的数据集的大小一般要比目标分类的大一些，可以包含多个检测目标，最后还需要对每个数据集利用标注软件进行标注。 标注数据集&emsp;&emsp;软件：labelImg 放入数据集&emsp;&emsp;将数据集图片放入到JPEGImages文件夹中，其对应的标注文件放入到Annotations中，然后在VOC2019下新建一个可以产生txt文件的py文件：create_label.py：123456789101112131415161718192021222324252627282930313233343536import osimport random trainval_percent = 0.2train_percent = 0.8xmlfilepath = 'Annotations'txtsavepath = 'ImageSets\\Main'total_xml = os.listdir(xmlfilepath) num = len(total_xml)list = range(num)tv = int(num * trainval_percent)tr = int(tv * train_percent)trainval = random.sample(list, tv)train = random.sample(trainval, tr) ftrainval = open('ImageSets/Main/trainval.txt', 'w')ftest = open('ImageSets/Main/test.txt', 'w')ftrain = open('ImageSets/Main/train.txt', 'w')fval = open('ImageSets/Main/val.txt', 'w') for i in list: name = total_xml[i][:-4] + '\\n' if i in trainval: ftrainval.write(name) if i in train: ftest.write(name) else: fval.write(name) else: ftrain.write(name) ftrainval.close()ftrain.close()fval.close()ftest.close() &emsp;&emsp;首先将数据集8:2分成train.txt和trainval.txt，然后再将trainval.txt再8:2分成test.txt和val.txt。 生成数据集文本文件&emsp;&emsp;对于目标检测来说，还需要生成一个包含数据集路径、标注框信息和类别信息的txt文件。在最外面的文件夹在新建一个转换文件：voc_annotation.py：123456789101112131415161718192021222324252627282930313233import xml.etree.ElementTree as ETfrom os import getcwdsets=[('2019', 'train'), ('2019', 'val'), ('2019', 'test')]classes = [\"aeroplane\", \"bicycle\", \"bird\", \"boat\", \"bottle\", \"bus\", \"car\", \"cat\", \"chair\", \"cow\", \"diningtable\", \"dog\", \"horse\", \"motorbike\", \"person\", \"pottedplant\", \"sheep\", \"sofa\", \"train\", \"tvmonitor\"]def convert_annotation(year, image_id, list_file): in_file = open('VOCdevkit/VOC%s/Annotations/%s.xml'%(year, image_id)) tree=ET.parse(in_file) root = tree.getroot() for obj in root.iter('object'): difficult = obj.find('difficult').text cls = obj.find('name').text if cls not in classes or int(difficult)==1: continue cls_id = classes.index(cls) xmlbox = obj.find('bndbox') b = (int(xmlbox.find('xmin').text), int(xmlbox.find('ymin').text), int(xmlbox.find('xmax').text), int(xmlbox.find('ymax').text)) list_file.write(\" \" + \",\".join([str(a) for a in b]) + ',' + str(cls_id))wd = getcwd()for year, image_set in sets: image_ids = open('VOCdevkit/VOC%s/ImageSets/Main/%s.txt'%(year, image_set)).read().strip().split() list_file = open('%s_%s.txt'%(year, image_set), 'w') for image_id in image_ids: list_file.write('%s/VOCdevkit/VOC%s/JPEGImages/%s.jpg'%(wd, year, image_id)) convert_annotation(year, image_id, list_file) list_file.write('\\n') list_file.close() &emsp;&emsp;更改相应的信息，最后运行会生成3个txt文件，即2019_train.txt，2019_test.txt和2019_val.txt。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://cxx0822.github.io/categories/深度学习/"}],"tags":[]},{"title":"基于MATLAB的深度学习——入门篇","slug":"基于MATLAB的深度学习——入门篇","date":"2019-07-21T07:37:14.000Z","updated":"2022-03-31T12:26:33.477Z","comments":true,"path":"2019/07/21/ji-yu-matlab-de-shen-du-xue-xi-ru-men-pian/","link":"","permalink":"http://cxx0822.github.io/2019/07/21/ji-yu-matlab-de-shen-du-xue-xi-ru-men-pian/","excerpt":"","text":"概述&emsp;&emsp;MATLAB从2016年开始就提供深度神经网络的相关工具了，现如今，深度学习的基本使用模块已经相对完善，并且支持逐层拖拽的simulink型的架构设计方式。&emsp;&emsp;Deep Learning Toolbox™提供了一个用于通过算法、预训练模型和应用程序来设计和实现深度神经网络的框架。您可以使用卷积神经网络(ConvNet、CNN)和长短期记忆 (LSTM) 网络对图像、时序和文本数据执行分类和回归。应用程序和绘图可帮助您可视化激活值、编辑网络架构和监控训练进度。&emsp;&emsp;对于小型训练集，您可以使用预训练深度网络模型(包括 SqueezeNet、Inception-v3、ResNet-101、GoogLeNet和VGG-19)以及从TensorFlow®-Keras和Caffe导入的模型执行迁移学习。&emsp;&emsp;要加速对大型数据集的训练，您可以将计算和数据分布到桌面计算机上的多核处理器和GPU中(使用Parallel Computing Toolbox™)，或者扩展到群集和云，包括Amazon EC2® P2、P3 和 G3 GPU 实例(使用 MATLAB® Distributed Computing Server™)。 平台&emsp;&emsp;Windows 10&emsp;&emsp;MATLAB 2018a&emsp;&emsp;Deep Learning Toolbox&emsp;&emsp;Computer Vision Toolbox 注：如果没有Deep Learning Toolbox和Computer Vision Toolbox，需要自己安装，在MATLAB主页的APP中，点击获取更多App，在打开的附加功能资源管理器中，搜索这2个工具箱并下载安装即可。 一个简单的例子&emsp;&emsp;在MATLAB官方文档中，提供了一些简单的入门实例。下面我们挑选第一个案例进行简单的分析。 使用 GoogLeNet 对图像进行分类&emsp;&emsp;首先是使用一个典型的的深度卷积神经网络GoogLeNet对图像进行分类。&emsp;&emsp;GoogLeNet已经对超过一百万个图像进行了训练，可以将图像分为1000个对象类别（例如键盘、咖啡杯、铅笔和多种动物）。该网络已基于大量图像学习了丰富的特征表示。网络以图像作为输入，然后输出图像中对象的标签以及每个对象类别的概率。 加载预训练网络1net = googlenet &emsp;&emsp;加载一个已知网络十分简单，直接令变量名等于网络名即可(第一次加载可能需要联网下载)。下面我们使用disp(net)简单看一个googlenet的内容：&emsp;&emsp;每个net都有2个属性，即Layers(网络层)和Connections(层连接)，Layers为数组，指的是网络图层，指定为Layer阵列。Connections是表，图层连接，指定为具有两列的表。每个表行表示图层图中的连接。第一列Source指定每个连接的源。第二列Destination指定每个连接的目标。连接源和目标要么是图层名称,要么layerName/IOName的窗体,其中IOName是图层输入或输出的名称。&emsp;&emsp;我们可以继续disp(net.Layers)查看其网络结构：&emsp;&emsp;可以看出，googlenet一共有144层，第一列为网络名称，第二列为网络的类型，第三列为网络的具体参数。&emsp;&emsp;这里我们需要网络结构里面的第一个和最后一个参数，即图像输入和分类类别，先定义2个变量保存该信息。12inputSize = net.Layers(1).InputSize;classNames = net.Layers(end).ClassNames; &emsp;&emsp;我们可以简单看下这2个参数里面的信息： 读取图像并调整图像大小&emsp;&emsp;有了训练好的网络结构后，我们就可以用图片进行分类预测了。&emsp;&emsp;首先读取一张图片，这里使用了官方文档里面的图片，然后要将其调整到网络需要的输入图片大小(否则会编译报错)。12I = imread('peppers.png');I = imresize(I,inputSize(1:2)); &emsp;&emsp;使用imresize将图像大小调整为网络的输入大小。调整大小会略微更改图像的纵横比。当然也可以使用更好的调整大小的函数。&emsp;&emsp;B = imresize(A, [numrows numcols])：numrows和numcols分别指定目标图像的高度和宽度。这里的numrows和numcols就是刚才inputSize的第1列和第2列数组，即224,224。 对图像进行分类&emsp;&emsp;使用classify对图像进行分类并计算类概率。用于分类的网络训练为针对每个输入图像输出单个标签，即使图像包含多个对象时也是如此。最后我们也可以显示图像及预测的标签，以及具有该标签的图像的预测概率。1234[label,scores] = classify(net,I);figureimshow(I)title(string(label) + \", \" + num2str(100*scores(classNames == label),3) + \"%\"); &emsp;&emsp;classify()：使用经过训练的深度学习神经网络对数据进行分类，一共有3种形式：&emsp;&emsp;其返回值label就是scores中数组最高的那个对应的label，scores是一个1000*1的向量(因为googlenet一共有1000个分类类别)，里面依次存放着每个列别的置信度。scores(classNames == label)即表示找到label对应的那个scores。 其结果如图所示： 显示排名靠前的预测值&emsp;&emsp;根据scores的特点，我们还可以显示出排名前五的预测标签，并以直方图形式显示它们的相关概率。由于网络将图像分类为如此多的对象类别，并且许多类别是相似的，因此在评估网络时通常会考虑准确度排名前五的几个类别。网络以高概率将图像分类为甜椒。1234567891011[~,idx] = sort(scores,'descend'); % 降序排列idx = idx(5:-1:1);classNamesTop = net.Layers(end).ClassNames(idx); % 获取前5个类别scoresTop = scores(idx);figurebarh(scoresTop) %绘制水平条形图xlim([0 1])title('Top 5 Predictions')xlabel('Probability')yticklabels(classNamesTop) &emsp;&emsp;其结果如下： 标注自己的数据集","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://cxx0822.github.io/categories/深度学习/"}],"tags":[]},{"title":"典型的深度神经网络","slug":"典型的深度神经网络","date":"2019-07-06T01:50:31.000Z","updated":"2022-03-31T12:23:46.376Z","comments":true,"path":"2019/07/06/dian-xing-de-shen-du-shen-jing-wang-luo/","link":"","permalink":"http://cxx0822.github.io/2019/07/06/dian-xing-de-shen-du-shen-jing-wang-luo/","excerpt":"","text":"AlexNet简介&emsp;&emsp; 网络结构&emsp;&emsp;该网络包含8个带权重的层；前5层是卷积层，剩下的3层是全连接层。最后一层全连接层的输出是1000维softmax的输入，softmax会产生1000类标签。 卷积层C1&emsp;&emsp;该层的处理流程是：卷积—&gt;ReLU—&gt;池化—&gt;归一化。&emsp;&emsp;卷积：输入图像是227×227×3，使用96个11×11×3的卷积核，步长为4，不边缘填充，所以得到的FeatureMap为55×55×96。(55=(227-11)/4+1)&emsp;&emsp;ReLU：将卷积层输出的FeatureMap输入到ReLU函数中。&emsp;&emsp;池化：使用3×3步长为2的池化单元，输出为27×27×96。(27=(55−3)/2+1)&emsp;&emsp;局部响应归一化：使用k=2,n=5,α=10−4,β=0.75进行局部归一化，输出的仍然为27×27×96，输出分为两组，每组的大小为27×27×48。 卷积层C2&emsp;&emsp;该层的处理流程是：卷积—&gt;ReLU—&gt;池化—&gt;归一化&emsp;&emsp;卷积：输入是2组27×27×48。使用2组，每组128个尺寸为5×5×48的卷积核，边缘填充padding=2，卷积的步长为1。则输出的FeatureMap为2组，每组的大小为27×27×128。一共是27×27×256。(27=(27+2∗2−5)/1+1)&emsp;&emsp;ReLU：将卷积层输出的FeatureMap输入到ReLU函数中。&emsp;&emsp;池化运算的尺寸为3×3，步长为2，池化后图像的尺寸为13=(27−3)/2+1，所以输出为13×13×256。&emsp;&emsp;局部响应归一化：使用k=2,n=5,α=10−4,β=0.75进行局部归一化，输出的仍然为13×13×256，输出分为2组，每组的大小为13×13×128。 卷积层C3&emsp;&emsp;该层的处理流程是：卷积—&gt;ReLU&emsp;&emsp;卷积：输入是13×13×256，使用2组共384个尺寸为3×3×256的卷积核，边缘填充padding=1，卷积的步长为1。则输出的FeatureMap为13×13×384。(13=(13+2∗1−3)/1+1)&emsp;&emsp;ReLU：将卷积层输出的FeatureMap输入到ReLU函数中。 卷积层C4&emsp;&emsp;该层的处理流程是：卷积—&gt;ReLU&emsp;&emsp;卷积：输入是13×13×384，分为两组，每组为13×13×192。使用2组，每组192个尺寸为3×3×192的卷积核，边缘填充padding=1，卷积的步长为1。则输出的FeatureMap为13×13×384，分为两组，每组为13×13×192。(13=(13+2∗1−3)/1+1)&emsp;&emsp;ReLU：将卷积层输出的FeatureMap输入到ReLU函数中。 卷积层C5&emsp;&emsp;该层处理流程为：卷积—&gt;ReLU—&gt;池化&emsp;&emsp;卷积：输入为13×13×384，分为两组，每组为13×13×192。使用2组，每组为128个尺寸为3×3×192的卷积核，边缘填充padding=1，卷积的步长为1。则输出的FeatureMap为13×13×256。(13=(13+2∗1−3)/1+1)&emsp;&emsp;ReLU：将卷积层输出的FeatureMap输入到ReLU函数中。&emsp;&emsp;池化：池化运算的尺寸为3×3，步长为2，池化后图像的尺寸为(13−3)/2+1=6，即池化后的输出为6×6×256 全连接层FC6&emsp;&emsp;该层的流程为：（卷积）全连接 —&gt;ReLU —&gt;Dropout&emsp;&emsp;卷积-&gt;全连接：输入为6×6×256，该层有4096个卷积核，每个卷积核的大小为6×6×256。由于卷积核的尺寸刚好与待处理特征图（输入）的尺寸相同，即卷积核中的每个系数只与特征图（输入）尺寸的一个像素值相乘，一一对应，因此，该层被称为全连接层。由于卷积核与特征图的尺寸相同，卷积运算后只有一个值，因此，卷积后的像素层尺寸为4096×1×1，即有4096个神经元。&emsp;&emsp;ReLU：这4096个运算结果通过ReLU激活函数生成4096个值。&emsp;&emsp;Dropout：抑制过拟合，随机的断开某些神经元的连接或者是不激活某些神经元。 全连接层FC7&emsp;&emsp;流程为：全连接—&gt;ReLU—&gt;Dropout&emsp;&emsp;全连接：输入为4096的向量。&emsp;&emsp;ReLU：这4096个运算结果通过ReLU激活函数生成4096个值。&emsp;&emsp;Dropout：抑制过拟合，随机的断开某些神经元的连接或者是不激活某些神经元。 输出层&emsp;&emsp;第七层输出的4096个数据与第八层的1000个神经元进行全连接，经过训练后输出1000个float型的值，这就是预测结果。 参数数量&emsp;&emsp;卷积层的参数 = 卷积核的数量 * 卷积核 + 偏置 TensorFlow实现VGG简介&emsp;&emsp;VGGNet是牛津大学计算机视觉组(Visual Geometry Group)和Google DeepMind公司的研究员一起研发的深度卷积神经网络。&emsp;&emsp;VGG在AlexNet基础上做了改进，整个网络都使用了同样大小的3*3卷积核尺寸和2*2最大池化尺寸，网络结构简洁。 网络结构&emsp;&emsp;VGG一共有五组卷积，每组卷积之后紧接着最大池化层，后面接上三个全连接层，最后softmax输出。一共有两种形式，即VGG16和VGG19，后面的数字含义为卷积层和全连接层的个数，不包括池化层。 第一组卷积&emsp;&emsp;2个卷积层+1个池化层&emsp;&emsp;卷积层：conv3 - 64，卷积核为3×3×3，步长为1，填充为1，共64个，输出为：224*224*64，(224=(224+2∗1−3)/1+1)。(输入图像是224×224×3) 第2个卷积层结构不变，输出不变，下同。&emsp;&emsp;池化层：池化核为2×2，步长为2，填充为0，共64个，输出为：112*112*64，(112=(224+2∗0−2)/2+1)。 第二组卷积&emsp;&emsp;2个卷积层+1个池化层&emsp;&emsp;卷积层：conv3 - 128，卷积核为3×3×3，步长为1，填充为1，共128个，输出为：112*112*128，(112=(112+2∗1−3)/1+1)。&emsp;&emsp;池化层：池化核为2×2，步长为2，填充为0，共128个，输出为：56*56*128，(56=(112+2∗0−2)/2+1)。 第三组卷积&emsp;&emsp;2个卷积层+1个池化层&emsp;&emsp;卷积层：conv3 - 256，卷积核为3×3×3，步长为1，填充为1，共256个，输出为：56*56*256，(56=(56+2∗1−3)/1+1)。&emsp;&emsp;池化层：池化核为2×2，步长为2，填充为0，共256个，输出为：28*28*256，(28=(56+2∗0−2)/2+1)。 第四组卷积&emsp;&emsp;2个卷积层+1个池化层&emsp;&emsp;卷积层：conv3 - 512，卷积核为3×3×3，步长为1，填充为1，共512个，输出为：28*28*512，(28=(28+2∗1−3)/1+1)。&emsp;&emsp;池化层：池化核为2×2，步长为2，填充为0，共512个，输出为：14*14*512，(14=(28+2∗0−2)/2+1)。 第五组卷积&emsp;&emsp;2个卷积层+1个池化层&emsp;&emsp;卷积层：conv3 - 512，卷积核为3×3×3，步长为1，填充为1，共512个，输出为：14*14*512，(14=(14+2∗1−3)/1+1)。&emsp;&emsp;池化层：池化核为2×2，步长为2，填充为0，共512个，输出为：7*7*512，(7=(14+2∗0−2)/2+1)。 全连接层和输出层&emsp;&emsp;和AlexNet类似。 参数数量改进 去掉了LRN层，作者发现深度网络中LRN的作用并不明显，干脆取消了。 采用更小的卷积核-3x3，Alexnet中使用了更大的卷积核，比如有7x7的，因此VGG相对于Alexnet而言，参数量更少。 池化核变小，VGG中的池化核是2x2，stride为2，Alexnet池化核是3x3，步长为2。 &emsp;&emsp;这样做改进都是有一些原因的，首先为了更好的探究深度对网络的影响，必须要解决参数量的问题，更深的网络意味着更多的参数，训练更困难，使用大卷积核时尤其明显。作者通过分析，认为由于卷积神经网络的特性，3x3大小的卷积核足以捕捉到横、竖以及斜对角像素的变化。使用大卷积核会带来参数量的爆炸不说，而且图像中会存在一些部分被多次卷积，可能会给特征提取带来困难，所以在VGG中，普遍使用3x3的卷积。 TensorFlow实现GoogLeNetTensorFlow实现项目文件结构说明数据集预处理数据集下载生成train.txt和val.txt制作tfrecords数据格式tfrecords数据格式简介&emsp;&emsp;TFRecords文件包含了tf.train.Example协议内存块(protocol buffer)(协议内存块包含了字段Features)。我们可以写一段代码获取你的数据，将数据填入到Example协议内存块(protocol buffer)，将协议内存块序列化为一个字符串， 并且通过tf.python_io.TFRecordWriter写入到TFRecords文件。&emsp;&emsp;从TFRecords文件中读取数据， 可以使用tf.TFRecordReader的tf.parse_single_example解析器。这个操作可以将Example协议内存块(protocol buffer)解析为张量。 写入tfrecords数据&emsp;&emsp;一个Example中包含Features，Features里包含Feature的字典。最后，Feature里包含有一个FloatList，或者ByteList，或者Int64List。1234567891011121314151617181920212223def create_records(image_dir, file, output_record_dir, resize_height, resize_width, shuffle): images_list, labels_list = load_labels_file(file, 1, shuffle) writer = tf.python_io.TFRecordWriter(output_record_dir) for i, [image_name, labels] in enumerate(zip(images_list, labels_list)): image_path = os.path.join(image_dir, images_list[i]) if not os.path.exists(image_path): print('Err:no image', image_path) continue image = read_image(image_path, resize_height, resize_width) image_raw = image.tostring() label = labels[0] example = tf.train.Example(features=tf.train.Features(feature=&#123; 'image_raw': _bytes_feature(image_raw), 'height': _int64_feature(image.shape[0]), 'width': _int64_feature(image.shape[1]), 'depth': _int64_feature(image.shape[2]), 'label': _int64_feature(label) &#125;)) writer.write(example.SerializeToString()) writer.close() &emsp;&emsp;首先利用load_labels_file()函数(后面会给出其定义，下同)将images和labels加载进来，然后创建一个TFRecordWriter对象，这个对象就负责把记录写到指定的文件中，其函数参数为TFRecords，即文件路径。然后利用read_image()读取图片，最后将数据填入到Example协议内存块，其中图片的格式为字符串格式，其他均为整型格式。附：辅助函数定义：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# -*-coding: utf-8 -*-import tensorflow as tfimport numpy as npimport osimport cv2import matplotlib.pyplot as pltimport randomfrom PIL import Image# 生成整型的属性def _int64_feature(value): return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))# 生成字符串型的属性def _bytes_feature(value): return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))# 生成实数型的属性def float_list_feature(value): return tf.train.Feature(float_list=tf.train.FloatList(value=value))def get_example_nums(tf_records_filenames): nums = 0 for record in tf.python_io.tf_record_iterator(tf_records_filenames): nums += 1 return numsdef show_image(title, image): plt.imshow(image) plt.axis('on') plt.title(title) plt.show()def load_labels_file(filename, labels_num=1, shuffle=False): images = [] labels = [] with open(filename) as f: lines_list = f.readlines() if shuffle: random.shuffle(lines_list) for lines in lines_list: line = lines.rstrip().split(' ') label = [] for i in range(labels_num): label.append(int(line[i + 1])) # 单label，即line[1]就是label images.append(line[0]) labels.append(label) return images, labelsdef read_image(filename, resize_height, resize_width, normalization=False): bgr_image = cv2.imread(filename) if len(bgr_image.shape) == 2: print(\"Warning:gray image\", filename) bgr_image = cv2.cvtColor(bgr_image, cv2.COLOR_GRAY2BGR) rgb_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2RGB) if resize_height &gt; 0 and resize_width &gt; 0: rgb_image = cv2.resize(rgb_image, (resize_width, resize_height)) rgb_image = np.asanyarray(rgb_image) if normalization: rgb_image = rgb_image / 255.0 return rgb_imagedef get_batch_images(images, labels, batch_size, labels_nums, one_hot=False, shuffle=False, num_threads=1): min_after_dequeue = 200 capacity = min_after_dequeue + 3 * batch_size # 保证capacity必须大于min_after_dequeue参数值 if shuffle: images_batch, labels_batch = tf.train.shuffle_batch([images, labels], batch_size=batch_size, capacity=capacity, min_after_dequeue=min_after_dequeue, num_threads=num_threads) else: images_batch, labels_batch = tf.train.batch([images, labels], batch_size=batch_size, capacity=capacity, num_threads=num_threads) if one_hot: labels_batch = tf.one_hot(labels_batch, labels_nums, 1, 0) return images_batch, labels_batch &emsp;&emsp;整体比较简单，就不多做解释了。 读取tfrecords数据&emsp;&emsp;一旦生成了TFRecords文件，为了高效地读取数据，TF中使用队列(queue)读取数据。1234567891011121314151617181920212223242526272829303132def read_records(filename, resize_height, resize_width, type=None): filename_queue = tf.train.string_input_producer([filename]) reader = tf.TFRecordReader() _, serialized_example = reader.read(filename_queue) features = tf.parse_single_example( serialized_example, features=&#123; 'image_raw': tf.FixedLenFeature([], tf.string), 'height': tf.FixedLenFeature([], tf.int64), 'width': tf.FixedLenFeature([], tf.int64), 'depth': tf.FixedLenFeature([], tf.int64), 'label': tf.FixedLenFeature([], tf.int64) &#125; ) tf_image = tf.decode_raw(features['image_raw'], tf.uint8) tf_height = features['height'] tf_width = features['width'] tf_depth = features['depth'] tf_label = tf.cast(features['label'], tf.int32) tf_image = tf.reshape(tf_image, [resize_height, resize_width, 3]) if type is None: tf_image = tf.cast(tf_image, tf.float32) elif type == 'normalization': tf_image = tf.cast(tf_image, tf.float32) * (1. / 255.0) elif type == 'standardization': tf_imag = tf.cast(tf_image, tf.float32) * (1. / 255) - 0.5 return tf_image, tf_label &emsp;&emsp;首先利用string_input_producer()将字符串输出到一个输入管道队列，然后利用parse_single_example()解析器解析。 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546def batch_test(record_file, resize_height, resize_width): # 读取record函数 tf_image, tf_label = read_records(record_file, resize_height, resize_width, type='normalization') image_batch, label_batch = get_batch_images(tf_image, tf_label, batch_size=4, labels_nums=2, one_hot=False, shuffle=True) init = tf.global_variables_initializer() with tf.Session() as sess: # 开始一个会话 sess.run(init) coord = tf.train.Coordinator() threads = tf.train.start_queue_runners(coord=coord) for i in range(4): # 在会话中取出images和labels images, labels = sess.run([image_batch, label_batch]) # 这里仅显示每个batch里第一张图片 show_image(\"image\", images[0, :, :, :]) print('shape:&#123;&#125;,tpye:&#123;&#125;,labels:&#123;&#125;'.format(images.shape, images.dtype, labels)) # 停止所有线程 coord.request_stop() coord.join(threads)if __name__ == '__main__': # 参数设置 resize_height = 224 # 指定存储图片高度 resize_width = 224 # 指定存储图片宽度 shuffle = True # 产生train.record文件 image_dir = 'dataset/train' train_labels = 'dataset/train.txt' # 图片路径 train_record_output = 'dataset/record/train.tfrecords' create_records(image_dir, train_labels, train_record_output, resize_height, resize_width, shuffle) train_nums = get_example_nums(train_record_output) print(\"save train example nums=&#123;&#125;\".format(train_nums)) # 产生val.record文件 image_dir = 'dataset/val' val_labels = 'dataset/val.txt' # 图片路径 val_record_output = 'dataset/record/val.tfrecords' create_records(image_dir, val_labels, val_record_output, resize_height, resize_width, shuffle) val_nums = get_example_nums(val_record_output) print(\"save val example nums=&#123;&#125;\".format(val_nums)) # 测试显示函数 # disp_records(train_record_output,resize_height, resize_width) batch_test(train_record_output, resize_height, resize_width)","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://cxx0822.github.io/categories/深度学习/"}],"tags":[]},{"title":"基于YOLO的目标检测","slug":"基于YOLO的目标检测","date":"2019-06-23T10:39:28.000Z","updated":"2022-03-21T06:19:12.803Z","comments":true,"path":"2019/06/23/ji-yu-yolo-de-mu-biao-jian-ce/","link":"","permalink":"http://cxx0822.github.io/2019/06/23/ji-yu-yolo-de-mu-biao-jian-ce/","excerpt":"","text":"摘要&emsp;&emsp; 平台&emsp;&emsp;系统：Ubuntu&emsp;&emsp;框架：Darknet 配置环境opencv配置下载opencv3.4.0&emsp;&emsp;从官网下载即可，网址，选择Sources源代码，尽量选择3.4.0及以下的版本，高版本的不一定能配置成功。 安装依赖&emsp;&emsp;依次执行下面4条命令即可。 sudo apt-get install gcc g++ cmake pkg-config build-essential sudo apt-get install build-essential cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install libgtk2.0-dev libavcodec-dev libavformat-dev libtiff4-dev libswscale-dev libjasper-dev注：安装过程中，有yes/no选项时，选择yes即可。 编译&emsp;&emsp;刚才从官网下载的只是opencv的源码，我们还要对其编译后才能正常使用。 cd进入到opencv文件夹，比如我的opencv位置是在home目录下：cd opencv-3.4.0 新建一个文件夹build：mkdir build cd进入到build文件夹：cd build cmake编译：cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..这里需要下载一个压缩包，如果网络环境不好的话，可能会卡很长时间，这里我们可以先离线下载好压缩包。首先在github网站上找到压缩包并下载，网址，然后再打开opencv文件夹内的3rdparty/ippicv里面的ippicv.cmake文件，并将里面的压缩包下载网址改为本地的文件路径，如file://Downloads。最后再重新执行上面命名即可。 make -j8 sudo make install 环境配置&emsp;&emsp;最后添加Ubuntu的环境变量就全部完成了。 首先将OpenCV的库添加到路径：sudo gedit /etc/ld.so.conf.d/opencv.conf执行此命令后打开的可能是一个空白的文件，在文件末尾添加：/usr/local/lib注：这里很多博客都这么写，我当时也这么做的，但实际运行时，仍然报错，说找不到libopencv_highgui.so.3.4文件，后来才发现我的这个文件并不在该路径下，而是在该路径下的x86_64-linux-gnu文件夹内，所以正确的应该是/usr/local/lib/x86_64-linux-gnu。所以读者在实际配置时，这里填的应该是libopencv_highgui.so.3.4文件的上一级文件夹路径。 生效配置文件：sudo ldconfig 配置bash:sudo gedit /etc/bash.bashrc在末尾添加：PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig export PKG_CONFIG_PATH保存，执行如下命令使得配置生效：source /etc/bash.bashrc更新：sudo updatedb至此，所有opencv的配置都已经完成。 darknet配置下载源代码&emsp;&emsp;登陆darknet官网，在里面找到其GitHub地址，然后下载即可。注：如果读者想在Windows上使用YOLO，可以自己新建build文件夹编译，也可以使用别人的：网址。&emsp;&emsp;然后解压缩，并cd进入该文件夹下，输入make指令编译：12cd darknet-mastermake &emsp;&emsp;在继续输入./darknet，如果没有报错，则配置成功。 更改配置文件&emsp;&emsp;打开里面的Makefile文件，修改里面的配置信息，如果装了GPU，将GPU和CUDNN设置为1，如果装了opnecv，将OPENCV设置为1。(我这里只装了opencv) 下载权重&emsp;&emsp;进入darknet官网中，选择里面的YOLO选项，进入YOLO主页，在里面找到权重的下载地址，点击下载即可。注：可能会很慢，可以找别人下好的百度云下载。 测试&emsp;&emsp;输入下面指令：1./darknet detect cfg/yolov3.cfg yolov3.weights data/dog.jpg &emsp;&emsp;最终的结果如图所示，生成每个类别的概率信息和标注框信息。 初识darknet源代码框架&emsp;&emsp;cfg：存放的是各种常见网络结构的配置文件，如yolo、rcnn等，如果想要定义自己的网络结构需要编写自己的cfg文件；&emsp;&emsp;data：各种数据集；&emsp;&emsp;examples：存放的各种检测算法的例子，如detector.c就是检测的代码，根据你输入run_detector函数的参数是train还是test转到其内部的train_detector或者test_detector，此文件夹中最重要的文件是darknet.c；&emsp;&emsp;include：只有一个文件darknet.h是darknet的头文件，主要是一些定义和函数声明；&emsp;&emsp;scripts：几个shell脚本，用来获取数据集的；&emsp;&emsp;src：绝大部分的源码，里面有BN层的实现、卷积层的实现、正则化等等。 编译&emsp;&emsp;编译好了，这时我们会发现文件夹里多出了obj、backup、results三个文件夹和libdarknet.a静态库、libdarknet.so动态库。动态链接的基本思想简单来说，就是不对那些组成程序的目标文件进行链接，而是当程序运行时才进行链接，从而解决了静态链接空间浪费的问题。obj文件夹下就是所有目标文件，backup文件夹主要存放训练的模型，result文件夹主要存放训练的结果。 简单使用&emsp;&emsp;darknet的使用也是很简单，我们先在darknet官网上下载好已经训练出的yolov3的权重，之后在终端运行：1./darknet detect cfg/yolov3.cfg yolov3.weights data/dog.jpg &emsp;&emsp;这个命令结合代码非常好理解，我们首先在examples文件夹下的darknet.c文件里面找到darknet的主函数:&emsp;&emsp;这是主函数的部分截图，可以看出该程序是根据给定的argv(命令行参数)来决定程序的走向，如本例argv[1](命令行的第一个参数，下同)为detect，根据主函数中的第6个if判断语句可以看出，该程序会转到test_dector函数中，也就是测试检测，后面的args[2]、args[3]、args[4]都是该函数的形参。那test_dector()函数又是什么意思呢？&emsp;&emsp;这个函数的定义并不在当前的darknet.c文件中，在第8行可以看到其使用了extern来声明这是一个外部函数，该函数是在examples文件夹下的detector.c文件里面，其函数头为：1void test_detector(char *datacfg, char *cfgfile, char *weightfile, char *filename, float thresh, float hier_thresh, char *outfile, int fullscreen) &emsp;&emsp;该函数由darknet.c中的主函数调用，该函数为一个前向推理测试函数，不包括训练过程，因此如果要使用该函数，必须提前训练好网络，并加载训练好的网络参数文件。&emsp;&emsp;其主要参数含义为：&emsp;&emsp;datacfg：数据集信息文件路径(也即cfg/*.data文件)，文件中包含有关数据集的信息，比如cfg/coco.data；&emsp;&emsp;cfgfile：网络配置文件路径(也即cfg/*.cfg文件)，包含一个网络所有的结构参数，比如cfg/yolo.cfg；&emsp;&emsp;weightfile：已经训练好的网络权重文件路径，比如darknet网站上下载的yolo.weights文件；&emsp;&emsp;filename：待进行检测的图片路径(单张图片)。&emsp;&emsp;综上所述，这个命令代码的含义就是：运用yolov3.cfg的网络框架和yolov3.weights权重去测试dog.jpg这张图片并显示结果。其中数据集为默认的coco.data。当然了，我们也可以使用其他的网络结构去测试其他图片。 初识Yolo目标检测&emsp;&emsp;在正式讲解yolo之前，我们先简单了解一下计算机视觉中的目标检测。&emsp;&emsp;图像分类是计算机视觉最基本的任务之一，在图像分类的基础上，还有更复杂和有意思的任务，如目标检测，物体定位，图像分割等。其中目标检测是一件比较实际的且具有挑战性的计算机视觉任务，其可以看成图像分类与定位的结合，给定一张图片，目标检测系统要能够识别出图片的目标并给出其位置。&emsp;&emsp;最近几年比较流行的目标检测算法可以分为两类，一类是基于Region Proposal(候选区域)的R-CNN系算法(R-CNN，Fast R-CNN, Faster R-CNN)，它们是two-stage(两步走)的，需要先使用启发式方法(selective search)或者CNN网络(RPN)产生Region Proposal，然后再在Region Proposal上做分类与回归。而另一类是Yolo，SSD这类one-stage(一步走)算法，其仅仅使用一个CNN网络直接预测不同目标的类别与位置。&emsp;&emsp;第一类方法是准确度高一些，但是速度慢，但是第二类算法是速度快，但是准确性要低一些。这可以在下图中看到。&emsp;&emsp;其中FPS表示每秒帧率，用来评估速度，mAP表示多类别的平均精度，用来评估准确率。 Yolo名称含义&emsp;&emsp;Yolo其全称是You Only Look Once: Unified, Real-Time Object Detection，这个题目取得非常好，基本上把Yolo算法的特点概括全了：You Only Look Once说的是只需要一次CNN运算，Unified指的是这是一个统一的框架，提供end-to-end的预测，而Real-Time体现是Yolo算法速度快。 Yolo之前的目标检测思想&emsp;&emsp;在Yolo出现之前，目标检测中比较常用的思想是滑动窗口技术。其基本原理就是采用不同大小和比例(宽高比)的窗口在整张图片上以一定的步长进行滑动，然后对这些窗口对应的区域做图像分类，这样就可以实现对整张图片的检测了，如下图所示，如DPM就是采用这种思路。&emsp;&emsp;但是这个方法有致命的缺点，就是你并不知道要检测的目标大小是什么规模，所以你要设置不同大小和比例的窗口去滑动，而且还要选取合适的步长。但是这样会产生很多的子区域，并且都要经过分类器去做预测，这需要很大的计算量，所以你的分类器不能太复杂，因为要保证速度。解决思路之一就是减少要分类的子区域，这就是R-CNN的一个改进策略，其采用了selective search(选择性搜索)方法来找到最有可能包含目标的子区域(Region Proposal)，其实可以看成采用启发式方法过滤掉很多子区域，这会提升效率。 Yolo的检测思想&emsp;&emsp;Yolo算法不再是窗口滑动了，而是直接将原始图片分割成互不重合的小方块，然后通过卷积直接生成特征图，我们可以认为特征图的每个元素也是对应原始图片的一个小方块，然后用每个元素来可以预测那些中心点在该小方格内的目标，这就是Yolo算法的朴素思想。&emsp;&emsp;整体来看，Yolo算法采用一个单独的CNN模型实现end-to-end的目标检测，整个系统如下图所示：首先将输入图片resize到448x448，然后送入CNN网络，最后处理网络预测结果得到检测的目标。相比R-CNN算法，其是一个统一的框架，其速度更快，而且Yolo的训练过程也是end-to-end的。也就是这里的窗口就是整幅图片。 再看Darknet——测试自己的数据集&emsp;&emsp;之前我们使用了Yolo作者提供的数据集和权重系数来预测图片，那我们该如何建立自己的数据集和权重系数呢？ 数据集配置&emsp;&emsp;Yolo属于有监督学习，即事先知道分类的标签值，所以我们需要采集大量的数据集供Yolo学习。下面以检测黄杆为例，讲解如何配置数据集。 重命名数据集&emsp;&emsp;我们采集到的数据集可以是从网上找的，也可以是手机拍摄的，也可以是从视频里面截取的等等，但往往其命名格式都是互不相同，如果没有一个统一的命名规则，直接训练的话，显然不是太好，所以我们首先要将采集到的数据集统一命名：123456789101112131415161718import osdef rename_files(dir_path): \"\"\" 批量重命名文件 参数： dirPath：文件路径 \"\"\" file_list = os.listdir(dir_path) index = 0 for item in file_list: oldname = dir_path + r\"\\\\\" + file_list[index] newname = dir_path + r\"\\\\\" + \".jpg\" os.rename(oldname, newname) index += 1 &emsp;&emsp;这段代码的作用就是把文件夹下的图片依次命名为：0.jpg，1.jpg…，当然你也可以自己设置命名规则。代码比较简单，就不多做讲解了。 标注数据集&emsp;&emsp;有了数据集，接下来就是对数据集的每张照片进行人工标注了。这里推荐使用标注软件labelImg(自行百度下载即可)，其使用方法也十分简单。&emsp;&emsp;首先打开data中的predefined_classes.txt，将其信息修改为要标注的类别，比如stick，有几类就写多少。然后打开软件，首先选择Open Dir打开图像文件夹，然后选择Change Save Dir选择要保存的xml文件的文件路径（标注完成后会生成一个xml文件存放标注信息），然后点击Create RectBox创建矩形。&emsp;&emsp;在需要的区域拖拽鼠标即可，然后在弹出的对话框中选择类别的名称，最后点击save保存，并选择Next Image切换到下一张。这时就可以看到保存xml文件夹中会出现对应照片的xml文件了。 准备数据集&emsp;&emsp;有了原始数据集和标注文件后，我们就可以配置属于Yolo的数据集了。&emsp;&emsp;首先创建一个文件夹VOCdevkit，当然你也可以起个其他的名字，只不过Yolo作者是这么做的，其源代码也是照着这个来的，所以一般就起这个就可以了。然后将其放入到scripts文件夹下，因为后续要使用的vov_label.py在该文件夹下，所以会比较方便。然后再依次新建下列文件夹，最终的文件目录如下：123456VOCdevkit ——VOC2019 #文件夹的年份可以自己取————Annotations #放入所有的xml文件————ImageSets ——————Main ————JPEGImages #放入所有的图片文件 &emsp;&emsp;然后我们把图片放入JPEGImages文件夹中，把标注文件放入Annotations文件夹中。其中Main文件夹下需要再新建4个txt文件，分别为：test.txt(测试集)，train.txt(训练集)，val.txt(验证集)，trainval.txt(训练和验证集)，其中训练集和验证集是必须的，所以这里我只新建了2个txt文件。 生成train.txt和val.txt&emsp;&emsp;这两个文本文件存放的就是训练集和验证集中图片的文件名，注意这里只是文件名，不包含后缀。我们可以使用下面的voc_train.py(自己新建，放在scripts文件夹下)生成：123456789101112131415161718192021222324import osfrom os import listdir, getcwdfrom os.path import joinif __name__ == '__main__': source_folder='/home/cxx/Desktop/darknet/scripts/VOCdevkit/VOC2019/JPEGImages/' dest='/home/cxx/Desktop/darknet/scripts/VOCdevkit/VOC2019/ImageSets/Main/train.txt' dest2='/home/cxx/Desktop/darknet/scripts/VOCdevkit/VOC2019/ImageSets/Main/val.txt' file_list=os.listdir(source_folder) train_file=open(dest,'a') val_file=open(dest2,'a') for file_obj in file_list: file_path=os.path.join(source_folder,file_obj) file_name,file_extend=os.path.splitext(file_obj) file_num=int(file_name) if(file_num&lt;150): train_file.write(file_name+'\\n') else : val_file.write(file_name+'\\n') train_file.close()val_file.close() &emsp;&emsp;这里的源文件夹就是刚才放图片的文件夹JPEGImages(路径根据情况自行修改)，目标文件就是我们新建的train.txt和val.txt，然后利用splitext()分离文件名和后缀名。这里面的判断条件file_num&lt;150，可以根据需求自行修改，因为我这里只有300张数据集，所以将前150张作为训练集，后150张作为验证集。&emsp;&emsp;然后运行指令：python voc_train.py即可。打开Main文件夹中的train.txt和val.txt可以看出里面存放着图片的文件名了。(这里奇怪的是，代码中并没有乱序的函数，为啥生成的文件名是乱序的。) 生成2019_train.txt、2019_val.txt、train.txt&emsp;&emsp;有了刚才图片的文件名信息，我们就可以生成Yolo需要的图片路径信息和标注框信息了。这里Yolo的作者提供了相应的python转换代码voc_train.py(在scripts文件夹下)，修改相应信息直接运行即可：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import xml.etree.ElementTree as ETimport pickleimport osfrom os import listdir, getcwdfrom os.path import joinsets=[('2019', 'train'), ('2019', 'val')]classes = [\"stick\"]def convert(size, box): dw = 1./(size[0]) dh = 1./(size[1]) x = (box[0] + box[1])/2.0 - 1 y = (box[2] + box[3])/2.0 - 1 w = box[1] - box[0] h = box[3] - box[2] x = x*dw w = w*dw y = y*dh h = h*dh return (x,y,w,h)def convert_annotation(year, image_id): in_file = open('VOCdevkit/VOC%s/Annotations/%s.xml'%(year, image_id)) out_file = open('VOCdevkit/VOC%s/labels/%s.txt'%(year, image_id), 'w') tree=ET.parse(in_file) root = tree.getroot() size = root.find('size') w = int(size.find('width').text) h = int(size.find('height').text) for obj in root.iter('object'): difficult = obj.find('difficult').text cls = obj.find('name').text if cls not in classes or int(difficult)==1: continue cls_id = classes.index(cls) xmlbox = obj.find('bndbox') b = (float(xmlbox.find('xmin').text), float(xmlbox.find('xmax').text), float(xmlbox.find('ymin').text), float(xmlbox.find('ymax').text)) bb = convert((w,h), b) out_file.write(str(cls_id) + \" \" + \" \".join([str(a) for a in bb]) + '\\n')wd = getcwd()for year, image_set in sets: if not os.path.exists('VOCdevkit/VOC%s/labels/'%(year)): os.makedirs('VOCdevkit/VOC%s/labels/'%(year)) image_ids = open('VOCdevkit/VOC%s/ImageSets/Main/%s.txt'%(year, image_set)).read().strip().split() list_file = open('%s_%s.txt'%(year, image_set), 'w') for image_id in image_ids: list_file.write('%s/VOCdevkit/VOC%s/JPEGImages/%s.jpg\\n'%(wd, year, image_id)) convert_annotation(year, image_id) list_file.close()os.system(\"cat 2019_train.txt 2019_val.txt &gt; train.txt\") &emsp;&emsp;最后一行的意思是将2个文件合并到一个文件里面。&emsp;&emsp;首先将sets和classes列表中的内容更改为自己的，其中set里面的2019就是刚才新建文件夹的年份，后面的train和val就是Main文件夹中的2个txt文件。classes就是分类的类别，我这里只有1类，就是stick。最后将最后一行的文件夹名字更改一下即可。&emsp;&emsp;然后运行指令：python voc_label.py即可。打开VOC2019文件夹，可以看到里面有1个新的文件夹labels，打开可以发现就是刚才的标注框的信息，即[类别,x,y,w,h]。在scipts文件夹下，可以看到新建了3个txt文件，里面存放的是数据集的绝对路径，待会修改配置文件的时候需要用到。&emsp;&emsp;至此数据集的配置工作终于弄完了，下面就是修改一些配置文件了，相对来说比较轻松。 下载预先权重&emsp;&emsp;在修改配置文件之前，我们先下载一个权重系数文件。这里我们为什么要下载别人的权重系数，不直接自己训练出来呢？因为如果我们不使用别人的，通常的做法是随机生成一个，但我们的网络结构很大，一旦随机的不好，刚开始的时候其效果将会非常不好，导致训练的次数和时间上升，而如果用别人训练好的，虽然检测的目标不一样，但至少比随机产生的要好很多，收敛也会加快。其实这也就是迁移学习的思想。&emsp;&emsp;运行指令wget https://pjreddie.com/media/files/darknet53.conv.74下载即可，如果下载较慢，可以将网址复制到浏览器中下载。下载完放在scripts文件夹中。 修改配置文件&emsp;&emsp;我们一共要修改3个配置文件。 cfg/voc.data&emsp;&emsp;根据目录找到该文件，并打开：12345classes= 1 #classes为训练样本集的类别总数train = /home/cxx/Desktop/darknet/scripts/2019_train.txt #train的路径为训练样本集所在的路径valid = /home/cxx/Desktop/darknet/scripts/2019_train.txt #valid的路径为验证样本集所在的路径names = data/voc.names #names的路径为data/voc.names文件所在的路径 backup = backup &emsp;&emsp;比较简单，修改即可。最好是完整的路径。 data/voc.name&emsp;&emsp;根据目录找到该文件，并打开：1stick #修改为自己样本集的标签名 &emsp;&emsp;比较简单，修改即可。 cfg/yolov3-voc.cfg&emsp;&emsp;根据目录找到该文件，并打开。这里比较复杂，一共需要更改2个部分，共四处地方。&emsp;&emsp;第一部分是[net]部分，就是网络结构的参数。原始文件中batch = 64,subdivision = 16，其含义为每轮迭代会从所有训练集里随机抽取batch = 64个样本参与训练，所有这些 batch个样本又被均分为subdivision = 16次送入网络参与训练，以减轻内存占用的压力。&emsp;&emsp;这看起来很好，但如果显卡不行或者显存不够大的话，训练会很慢甚至崩溃掉，所以电脑不好的可以将这2个值改小一点，注意值最好是2的幂次。&emsp;&emsp;第二部分是softmax层的修改，也就是[yolo]和上一个[convolutional]，一共有3处yolo，每处都同样的改法。&emsp;&emsp;首先是[convolutional]中的filters大小，其计算公式为：3*(classes+5)，这里我的classes为1，所以更改为：3*(1+5)=18，其次是[yolo]中的classes，更改为1。最后的random，如果显存不好，将其设置为0。&emsp;&emsp; 至此，所有的配置都弄好了，下面我们就可以正式训练了。 开始训练&emsp;&emsp;训练指令十分简单，一行命令即可：1./darknet detector train cfg/voc.data cfg/yolov3-voc.cfg scripts/darknet53.conv.74 -gpus 0,1 &emsp;&emsp;注意相应的文件路径，如果是cpu训练的话，就把后面的gpu删掉即可。 配置文件详解及问题再看Yolo——内部原理Unified Detection(统一检测)&emsp;&emsp;首先将输入的图片分割成S*S的网格，然后每个单元格负责去检测那些中心点落在该格子内的目标。这句话比较绕口，可以反过来理解，即如果一个目标的中心点在某个单元格内，那么这个单元格就要负责预测这个目标(数据集都是提前标注好的，事先是知道每个目标的中心点的。)。例如在下图中，狗这个目标的中心落在左下角一个单元格内(第5行第2列)，那么该单元格负责预测这个狗。(对于单元格内没有目标的，当然就不用检测了，这里可以通过后面的公式看出，直接把没目标的单元格过滤掉了。) bounding box&emsp;&emsp;每个单元格一共会预测B个边界框bounding box(下图中间上面的黑色小框)，其中每个bounding box都包含5个confidence score(置信度得分)：[x,y,w,h,confidence]。其中x,y指的是bounding box的中心点坐标，w,h指的是bounding box的宽和高，confidence是置信度，具体由后面的公式计算得出。&emsp;&emsp;例如在YOLOv1中，S和B的取值为7和2，也就是一共有7*7*2=98个bounding box。&emsp;&emsp;其实这个和之前的two-stage目标检测算法，如CNN类似，这里的边界框相当于之前的候选区域，只不过之前是用滑动窗口来选择，这里采用的是1个单元格2个框的思想。因为如果是滑动窗口的话，遍历一张图，需要的窗口太多了，计算量很大，而且窗口都是固定大小，不能随意放缩，而且很多窗口都是冗余的。而yolo的思想就是利用置信度里的x,y,w,h来调节窗口的大小。而且每个单元格都会有相应的边界框，也不至于漏掉某个目标的检测。&emsp;&emsp;在YOLOv1中，采取的做法是1个grid cell(单元格)2个bounding box，然后利用后面的损失函数和网络结构不断地修正bounding box里面的参数，直到和真实框相接近。这样做会带来2个不好的结果：1、位置精确性差，对于小目标物体以及物体比较密集的也检测不好，比如一群小鸟。2、虽然可以降低将背景检测为物体的概率，但同时导致召回率较低。所以在YOLOv2中，针对bounding box做了点改进。 anchor box&emsp;&emsp;YOLOv1是利用全连接层直接预测bounding box的坐标，而YOLOv2借鉴了Faster R-CNN的思想，引入了anchor box(锚点框)。所谓锚点框就是提前设定好几个预测框的大小。&emsp;&emsp;在YOLOv2和YOLOv3中，为了得到更加精细的anchor box，其个数和大小都是由K-means聚类算法计算出来的(具体细节可百度其他博客)，在YOLOv2中k=5，而YOLOv3中k=9，也就是说，在YOLOv3中，会提前设定好9个anchor box的尺寸大小，这个可以在其源代码中看到：110,13, 16,30, 33,23, 30,61, 62,45, 59,119, 116,90, 156,198, 373,326 &emsp;&emsp;每个anchor prior由两个数字组成，一个代表高度另一个代表宽度(当然最后要归一化处理)。这里之所以取9个，是因为v3输出了3个不同尺度的feature map。采用多尺度来对不同尺寸的目标进行检测，越精细的grid cell就可以检测出越精细的物体，每个尺寸3个anchor box，所以一共是9个。如下图左边的框图所示，每个grid cell有9个anchor box(其边框可以超出图像边缘)。&emsp;&emsp;在之前的YOLOv1中，我们一共只有98个预测框，而在YOLOv3中，我们一共有13*13*9=1521(YOLOv3中将网格划分为13*13)。显然，预测框的个数越多，其准确率也就越高。&emsp;&emsp;在YOLOv3中，对anchor box还做了以下的改进： 9个anchor box会被三个输出张量平分的。根据大中小三种size各自取自己的anchor box。 每个输出y在每个自己的网格都会输出3个预测框，这3个框是9除以3得到的，这是作者设置的，我们可以从输出张量的维度来看，13x13x255。255是怎么来的呢，3*(5+80)。80表示80个种类，5表示位置信息和置信度，3表示要输出3个prediction。在代码上来看，3*(5+80)中的3是直接由num_anchors//3得到的。 作者使用了logistic回归来对每个anchor box包围的内容进行了一个目标性评分(objectness score)。根据目标性评分来选择anchor prior进行predict，而不是所有anchor prior都会有输出。 &emsp;&emsp;虽然现在我们已经有了这么多的预测框，但真正需要的并不多，接下来做的就是，从这么多预测框中筛选出我们需要的，然后在不断调整其参数，直至和真实框相接近。 IOU和NMS&emsp;&emsp;在理解这两个概念之前，我们先看一下bounding box里面的第5个参数confidence的计算公式：&emsp;&emsp;第一项的含义就是，如果grid cell里面没有object，则该项为0，那么confidence就是0，如果有，则为1，那么confidence就等于第二项的值。所以如何判断一个grid cell中是否包含object呢？答案是：如果一个object的ground truth(真实框)的中心点坐标在一个grid cell中，那么这个grid cell就是包含这个object，也就是说这个object的预测就由该grid cell负责。(这一步就过滤掉很多bounding box了。)&emsp;&emsp;第二项是IOU，即交并比，如下图所示：&emsp;&emsp;红色框表示真实框，紫色框表示预测框，交并比的含义就是2个框的交集除以2个框的并集，也就是图中黄色部分除以绿色部分。其值为0时，表示没有重叠，为1时表示完全重叠，我们可以设定一个阈值来判断其预测框是否有目标存在(一般设定为0.5，即IOU的值为0.5时，则认为检测到目标了)。&emsp;&emsp;最后每个grid cell还要预测C个类别概率(YOLO是一个多目标检测)，表示一个grid cell在包含object的条件下属于某个类别的概率，所以其最终的计算公式为：&emsp;&emsp;也就是每个bounding box的confidence和每个类别的score相乘，最终得到每个bounding box属于哪一类的confidence score。&emsp;&emsp;但是经过上面几步之后，仍然会存在一些一个目标下很多宽高接近的冗余框，所以最后我们还需要利用NMS(非极大值抑制)去掉重复率较大的bounding box。其原理也十分简单，就是选择IOU最大的那个框。 x,y,w,h&emsp;&emsp;对于YOLO中的bounding box部分，还有最后一部分，就是x,y,w,h的理解。在YOLOv1中，对x,y采取的直接预测，其值并没有加过多的限制，也就是说很可能出现anchor box预测的目标离该单元格很远，这样会导致模型不稳定，特别在早期迭代的时候，需要很长时间才能收敛，所以在YOLOv2中对此做了改进：采用相对预测的方法，即每一个anchor box只负责检测周围正负一个单位以内的目标bounding box。其计算公式如下：&emsp;&emsp;其实就是把预测框的值转换为预测框的实际位置。&emsp;&emsp;黑色虚线框是bounding box，蓝色矩形框就是预测的结果。首先将图像划分成13*13大小的网格，然后每个网格预测5个bounding box，然后每个bounding box预测5个值：tx,ty,tw,th,to(to就是confidence)。cx和cy表示cell和图像左上角的横纵距离，为了保证之前说的每一个anchor box只能预测该单元格内的目标，tx和ty都经过了sigmoid函数处理，这样其值的范围就在0到1之间，这样的归一化处理也使得模型训练更加稳定，当然最后的实际位置要加上之前的横纵距离；pw和ph表示bounding box的宽高，为了保证预测的和实际的之间是一种放缩关系，这里加入了e的指数次方，以保证后面的系数是大于0的。&emsp;&emsp;注：这里采用的思想就是通过平移和放缩来实现预测框和实际框的不断逼近。 总结&emsp;&emsp;总结一下，我对YOLO边界框的理解就是：先用Kmeans人为的设定9个anchor box，然后将输入图片分为S*S个网格，每个网络都将这9个anchor box遍历一遍，然后通过置信度计算公式筛选出最好的边界框，最后通过卷积网络和损失函数不断地训练学习，校正置信度里面(x,y,w,h)四个参数，以得到最好地边框效果。 网络结构&emsp;&emsp;YOLO从v1到v3，其网络结构也经历了较大的变化，从最开始的GoogLeNet到Darknet 53，模型变得越来越复杂，但其运行时间和精度确越来越好。 YOLOv1&emsp;&emsp;v1的网络结构主要是采用GoogLeNet模型，卷积层提取特征，全连接层预测类别概率和坐标。最后输出的结果是7*7*30。但v1稍微对里面的一些细节做了改进： 将Inception Module替换成1*1和3*3的卷积 v1一共有24层卷积，2个全连接层。 使用Leaky Relu作为激活函数。 在第一个全连接层后面加上一个ratio=0.5的Dropout层。&emsp;&emsp;训练时，首先利用ImageNet 1000-class的数据集预先训练v1网络中的前20个卷积层和一个平均池化层，最后再加一个全连接层。输入图像的大小为224*224。正是训练时，再采用v1网络，同时输入改为448*448。 YOLOv2&emsp;&emsp;YOLOv2的全名为YOLO9000：Better,Faster,Stronger，无论是精度还是速度上都得到了很大的提升。&emsp;&emsp;这是论文原文里面列出来的YOLOv2针对v1的改进，其中大部分都是针对网络结构的改进。 Batch Normalization&emsp;&emsp;在每一个卷积层后添加batch normalization。 High Resolution Classifier&emsp;&emsp;之前的预训练的输入图像大小是先224*224，然后再448*448,现在的做法是，将输入大小改成448*448，先在ImageNet数据集上训练10轮，这样训练后的网络就可以适应高分辨率的输入了。 New Network&emsp;&emsp;YOLOv2使用了一个新的分类网络作为特征提取部分，作者使用了较多的3*3卷积核，在每一次池化操作后把通道数翻倍。借鉴了network in network的思想，网络使用了全局平均池化，把1*1的卷积核置于3*3的卷积核之间，用来压缩特征。也用了batch normalization稳定模型训练。&emsp;&emsp;最终得出的基础模型就是Darknet-19，如下图，其包含19个卷积层、5个最大值池化层。 Loss Function&emsp;&emsp;从YOLOv1到YOLOv3中，损失函数几乎没有怎么改变，最多就是把其中几个的均方误差改成了交叉熵形式。&emsp;&emsp;损失函数如上图所示，里面包含3个部分，即坐标预测、bbox预测和类别预测。 坐标预测(坐标损失)&emsp;&emsp;坐标预测为公式中的前两行，第一行是box中心坐标(x,y)的预测，第二行为宽和高的预测。这里是用宽和高的平方根来代替原来的宽和高，这样做主要是因为，相同的宽和高误差，对于小的目标精度影响比大的目标要大。&emsp;&emsp;如上图所示，有2组坐标。第一个是不加平方根的，其误差值都一样，但对于加了平方根的，明显小目标的误差更大一点。&emsp;&emsp;这里前面的λ和1系数见下文分析。 bbox预测(confidencd损失)&emsp;&emsp;bbox预测为公式中的第三、四行。第三行为含有object时的置信度(confidence)预测，第四行为不含有时的预测。这里的bbox预测和之前的坐标预测，两者的λ系数是不一样的。&emsp;&emsp;因为很多grid cell是不包含物体的，这样的话很多grid cell的confidence score为0，如果权值一致，容易导致模型不稳定，训练发散。所以可以采用设置不同权重方式来解决，一方面提高坐标预测的权重，另一方面降低没有object的box的confidence loss权值，论文中将这2个权重系数分别设为5和0.5。而对于包含object的box权重系数还是原来的1。 类别预测(分类损失)&emsp;&emsp;第五行表示预测类别的误差，注意前面的系数只有在grid cell包含object的时候才为1。 实现过程&emsp;&emsp;以YOLOv1为例，输入N个图像，每个图像包含M个object，每个object包含4个坐标(x，y，w，h)和1个label。&emsp;&emsp;然后通过网络得到7*7*30大小的三维矩阵。每个1*30的向量前5个元素表示第一个bounding box的4个坐标和1个confidence，后5个元素表示第二个bounding box的4个坐标和1个confidence。最后20个表示这个grid cell所属类别。这30个都是预测的结果，也就是都是网络生成的值。&emsp;&emsp;然后就可以计算损失函数的第一、二 、五行，这一部分比较好理解，x,y,w,h都是输入值，是已知的，前面的1_ij^obj指的是判断第i个网格中第j个bbox是否负责这个object，那怎么判断呢？与object的ground truth box的IOU最大的bbox负责该object，也就是说IOU最大时，此系数为1，否则为0。第五行指的是类别概率，也是输入值，是已知的。其前面的系数1_i^obj表示判断是否有object的中心落在网格i中，也就是说有object时，此系数为1，否则为0 。&emsp;&emsp;比较难理解的是confident的损失。预测的confidence可以根据ground truth和预测的bounding box计算出的IOU，和是否有object的0,1值相乘得到(见上文分析)。而真实的confidence是0或1值，即有object则为1，没有object则为0。(1表示此时IOU最大，也就是真实框) 总结&emsp;&emsp;综上所述，并不是网络的所有输出都要计算loss的，具体地说： 有物体中心落入的grid cell，需要计算分类损失，两个预测框bounding box都要计算置信度损失，预测的bounding box与groud truth中IOU较大的那个预测框bounding box需要计算xywh损失。 最关键的部分，没有物体中心落入的grid cell，只需要计算置信度(confidence)损失。 另一种实现YOLO的框架——Keras安装环境&emsp;&emsp;首先我们需要安装Tensor Flow框架(直接pip安装即可)，如果显卡较好，可以安装GPU版本，具体安装过程这里就不叙述了。其次需要安装Keras框架(直接pip安装即可)。Keras是一个由Python编写的开源人工神经网络库，可以作为Tensorflow、Microsoft-CNTK和Theano的高阶应用程序接口，进行深度学习模型的设计、调试、评估、应用和可视化。最后再下载Keras-YOLO的源代码即可，GitHub网站。 文件结构 font：字体目录(不知道干啥用的)。 model_data：模型数据，主要存放数据集类别信息和anchor的大小。可以更改成自己的数据集信息。 yolo3：里面有2个py文件，一个是model.py，就是构建yolo3的主要模块文件，包含网络结构，损失函数等，另一个是utils.py，主要是一些model.py用到的辅助性的工具函数。 coco_annoatation.py：将.json文件转换为txt文件，voc_annoatation.py：将.xml文件转换为txt文件。最后生成的txt文件包括训练的图片的路径信息、标注框信息和类别信息。 convert.py：把darknet的.weights权重转换为keras的.h5权重文件。 kmeans.py：通过聚类得到数据最佳的anchors。 train.py：训练yolov3的文件。 yolo.py：构建以yolov3为底层构件的yolo检测模型，因为上面的yolov3还是分开的单个函数，功能并没有融合在一起，即使在训练的时候所有的yolov3组件还是分开的功能，并没有统一接口，供在模型训练完成之后，直接使用。通过yolo.py融合所有的组件。 yolo_video.py：使用yolo.py文件中的yolo检测模型，并且对视频或图像中的物体进行检测。 yolov3.cfg，yolov3-tiny.cfg 构建yolov3或yolov3-tiny检测模型的整个超参文件。 快速使用 首先需要下载一个权重文件：网址，然后将权重放在主文件夹下。 执行如下命令将darknet下的yolov3配置文件转换成keras适用的h5文件： 1python convert.py yolov3.cfg yolov3.weights model_data/yolo.h5 &emsp;&emsp;注：可能需要输入python3&emsp;&emsp;运行完会在model_data文件夹下生成yolo.h5文件。 运行预测图像程序1python yolo_video.py --image &emsp;&emsp;然后根据提示输入图片位置：&emsp;&emsp;其结果如下所示： 训练自己的数据集创建数据集文件夹VOCdevkit&emsp;&emsp;在最外面的文件夹下新建一个VOCdevkit文件夹，这里的VOCdevkit文件夹和darknet框架下的是一样的，这里就不再叙述了。&emsp;&emsp;这里提供另一个生成随机数据集的py文件：123456789101112131415161718192021222324252627282930313233343536import osimport random trainval_percent = 0.2train_percent = 0.8xmlfilepath = 'Annotations'txtsavepath = 'ImageSets\\Main'total_xml = os.listdir(xmlfilepath) num = len(total_xml)list = range(num)tv = int(num * trainval_percent)tr = int(tv * train_percent)trainval = random.sample(list, tv)train = random.sample(trainval, tr) ftrainval = open('ImageSets/Main/trainval.txt', 'w')ftest = open('ImageSets/Main/test.txt', 'w')ftrain = open('ImageSets/Main/train.txt', 'w')fval = open('ImageSets/Main/val.txt', 'w') for i in list: name = total_xml[i][:-4] + '\\n' if i in trainval: ftrainval.write(name) if i in train: ftest.write(name) else: fval.write(name) else: ftrain.write(name) ftrainval.close()ftrain.close()fval.close()ftest.close() &emsp;&emsp;将其放在JPEGImages文件夹的同级目录下，运行后，会在Main文件夹下生成4个txt文件，里面存放着随机的图片名字。&emsp;&emsp;这样我们的VOC数据集就制作完成了。 生成train.txt，val.txt和test.txt&emsp;&emsp;和Darknet一样，这些文件主要包含每张图片的位置信息、标记框的信息和类别信息。打开voc_annotation.py文件，修改sets和classes列表里面的信息，运行即可。&emsp;&emsp;运行结束后会在YOLO的源代码文件夹下产生这些文件。 修改配置文件&emsp;&emsp;这里一共需要修改2个配置文件信息，第一个是model_data文件夹里面的voc_class.txt文件，修改为自己的类别即可。第二个是最外面的文件夹中的训练文件train.py，将_main()函数里面的文件路径更改为自己的即可，注意这里的log日志文件夹需要自己新建。在训练前可以先运行kmeans.py生成最好的anchor box(注意修改里面的文件路径)，然后将其放入到model_data文件夹中。&emsp;&emsp;然后直接运行train.py即可训练。 训练&emsp;&emsp;整个训练过程分两次，每次50次迭代。第二次迭代时，如果Loss几乎没有变化会提前终止。 结果分析&emsp;&emsp;训练完之后，我们还可以计算每个类别的平均精度等信息，即AP和mAP等。 下载源代码&emsp;&emsp;首先需要下载2个源代码，网址1，网址2。下载完成后，将里面的内容全部放到YOLO的源代码文件夹中： 生成groundtruths&emsp;&emsp;首先生成真实框的信息，即：&lt;class_name&gt; &lt;left&gt; &lt;top&gt; &lt;right&gt; &lt;bottom&gt; [&lt;difficult&gt;]。&emsp;&emsp;先将class_list.txt里面的内容换成自己的类别信息(我这里用的是VOC2007数据集)：&emsp;&emsp;然后运行下面的命令即可：1python convert_keras-yolo3.py --gt test.txt &emsp;&emsp;convert_keras-yolo3.py就是刚才下载的转换文件，test.txt为测试集的txt文件，(我这里是2019_test.txt)，运行结束后，会在from_kerasyolo3文件夹中看到每张图片的真实框信息。(注，可能需要换成python3)。&emsp;&emsp;然后将里面所有的txt文件都复制到input-&gt;ground-truth文件夹里面。 生成detections&emsp;&emsp;其次生成预测框的信息，即：&lt;class_name&gt; &lt;confidence&gt; &lt;left&gt; &lt;top&gt; &lt;right&gt; &lt;bottom&gt;。&emsp;&emsp;首先更改config.yml里面的信息：&emsp;&emsp;前面4个信息就是一些文件的路径，model_name指的是用的是哪个模型训练的(yolo3文件夹里面的model.py里面的模型)，我这里是tiny_yolo_body，当然也可以是自己的模型(此处的模型需要和训练时候的模型一致)。log_dir指的是权重文件的路径，后面2个可以不用改。&emsp;&emsp;然后将刚才下载的文件夹里面的model.py文件替换掉YOLO原始源代码里面的yolo3文件夹里面的model.py。&emsp;&emsp;然后再运行下面的命令：1python yolo_new.py -g config.yml --weights logs/000/xx.h5 &emsp;&emsp;yolo_new.py就是刚才下载的转换文件，xx.h5就是权重文件。(可能要装一个第三方库)&emsp;&emsp;程序会显示一共用了多少时间和每个图片预测的时间。&emsp;&emsp;程序运行结束后，会在源代码文件夹中生成一个名字很长的txt文件，将其重命名为pred.txt。 &emsp;&emsp;最后运行下面的命令即可：1python convert_keras-yolo3.py --pred pred.txt &emsp;&emsp;运行结束后，会在from_kerasyolo3文件夹中看到每张图片的预测框信息：&emsp;&emsp;然后将里面所有的txt文件都复制到input-&gt;detection_results文件夹里面。 运行main.py&emsp;&emsp;在运行main.py之前，还需要将测试集的图片放到input-&gt;images-optional里面，虽然这一步原作者写的是可选，但如果不做的话程序会报错。(为了方便，可以把所有数据集都拷过来)&emsp;&emsp;最后就是运行main.py了，如果装了Opencv的话，会看到很酷的动画。&emsp;&emsp;最后会显示每个类别的AP值和mAP值。 另一种实现YOLO的框架——PyTorch安装环境&emsp;&emsp;这里详见我的另一篇博客PyTorch的简单使用 快速使用 首先从Github网站上下载PyTorch的源代码：网址。 下载Yolov3的权重文件：网址，然后将权重放在weights文件夹下。 将待检测图片放入到data/samples文件夹下。 运行检测程序 1python3 detect.py --cfg cfg/yolov3.cfg --weights weights/yolov3.weights &emsp;&emsp;在生成的output文件夹下会看到检测结果： 训练自己的数据集创建数据集&emsp;&emsp;将自己的数据集JPEGImages和标注文件Annotations放到data目录下，并新建文件ImageSets，labels文件夹，复制JPEGImages，重命名images。最终的文件目录格式为：123456data Annotations images ImageSets JPEGImages labels 生成train.txt，val.txt和test.txt&emsp;&emsp;首先在最外面的文件夹(yolov3)下创建2个py文件：&emsp;&emsp;create_txt.py：123456789101112131415161718192021222324252627282930313233343536import osimport randomtrainval_percent = 0.1train_percent = 0.9xmlfilepath = 'data/Annotations'txtsavepath = 'data/ImageSets'total_xml = os.listdir(xmlfilepath)num = len(total_xml)list = range(num)tv = int(num * trainval_percent)tr = int(tv * train_percent)trainval = random.sample(list, tv)train = random.sample(trainval, tr)ftrainval = open('data/ImageSets/trainval.txt', 'w')ftest = open('data/ImageSets/test.txt', 'w')ftrain = open('data/ImageSets/train.txt', 'w')fval = open('data/ImageSets/val.txt', 'w')for i in list: name = total_xml[i][:-4] + '\\n' if i in trainval: ftrainval.write(name) if i in train: ftest.write(name) else: fval.write(name) else: ftrain.write(name)ftrainval.close()ftrain.close()fval.close()ftest.close() &emsp;&emsp;voc_label.py：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# -*-coding:utf-8-*-import xml.etree.ElementTree as ETimport pickleimport osfrom os import listdir, getcwdfrom os.path import joinsets = ['train', 'test', 'val']classes = [\"stick\"]def convert(size, box): dw = 1. / size[0] dh = 1. / size[1] x = (box[0] + box[1]) / 2.0 y = (box[2] + box[3]) / 2.0 w = box[1] - box[0] h = box[3] - box[2] x = x * dw w = w * dw y = y * dh h = h * dh return (x, y, w, h)def convert_annotation(image_id): in_file = open('data/Annotations/%s.xml' % (image_id), encoding='utf-8') out_file = open('data/labels/%s.txt' % (image_id), 'w', encoding='utf-8') tree = ET.parse(in_file) root = tree.getroot() size = root.find('size') w = int(size.find('width').text) h = int(size.find('height').text) for obj in root.iter('object'): difficult = obj.find('difficult').text cls = obj.find('name').text if cls not in classes or int(difficult) == 1: continue cls_id = classes.index(cls) xmlbox = obj.find('bndbox') b = (float(xmlbox.find('xmin').text), float(xmlbox.find('xmax').text), float(xmlbox.find('ymin').text), float(xmlbox.find('ymax').text)) bb = convert((w, h), b) out_file.write(str(cls_id) + \" \" + \" \".join([str(a) for a in bb]) + '\\n')wd = getcwd()print(wd)for image_set in sets: if not os.path.exists('data/labels/'): os.makedirs('data/labels/') image_ids = open('data/ImageSets/%s.txt' % (image_set), encoding='utf-8').read().strip().split() list_file = open('data/%s.txt' % (image_set), 'w') for image_id in image_ids: list_file.write('data/images/%s.jpg\\n' % (image_id)) convert_annotation(image_id) list_file.close() &emsp;&emsp;voc_label.py中的classes列表改为自己的类别。&emsp;&emsp;运行完create_txt.py后，会在ImageSets文件夹中生成几个txt，里面存放的数据集的名字。运行完voc_label.py后，会在data文件夹中生成所需要的train.txt，test.txt，val.txt，这里存放的都是数据集的路径。 修改配置文件&emsp;&emsp;这里一共需要修改3个配置文件信息，首先是data文件夹里面的coco.names和coco.data。打开coco.names，然后输入自己的类别即可。然后打开coco.data，更改里面的配置信息：&emsp;&emsp;然后打开cfg文件夹下，选择想要训练的模型，并更改相应的参数，可以参照上文的darknet框架部分。&emsp;&emsp;附：配置文件解析 训练&emsp;&emsp;训练之前需要先下载预训练权重，并将其放入weights文件夹下，权重下载地址。注：tiny版本的权重为yolov3-tiny.conv.15。或百度云链接，提取码：jvwg。&emsp;&emsp;然后切换至主文件夹目录下，运行命令即可：1python train.py --data data/coco.data --cfg cfg/yolov3-tiny.cfg &emsp;&emsp;注：最近的官网源代码对train.py进行了更新，增加了权重文件的参数设置，所以运行命令更改为：1python train.py --data data/coco.data --cfg cfg/yolov3-tiny.cfg --weights weights/yolov3-tiny.conv.15 &emsp;&emsp;注：Ubuntu系统下可能为python3。 &emsp;&emsp;训练过程如图所示： 预测&emsp;&emsp;训练结束后，会在weights文件夹下生成很多权重文件，其中best.pt就是最好的权重。首先将需要检测的图片放到data文件夹下的samples文件夹下，然后切换至主文件夹下，运行以下命令：1python detect.py --data data/coco.data --cfg cfg/yolov3-tiny.cfg --weights weights/best.pt &emsp;&emsp;注：最近的官网源代码对detect.py进行了更新，将data参数设置改为了names参数设置，所以运行命令更改为：1python detect.py --names data/coco.names --cfg cfg/yolov3-tiny.cfg --weights weights/best.pt &emsp;&emsp;运行结束后，会在主文件夹下生成output文件夹，里面存放着预测结果。 结果分析&emsp;&emsp;训练结束后，除了生成权重文件外，还生成了results.txt文本文件，该文件记录了刚才训练过程中的日志信息，只需执行一条简单的命令就可以将其可视化。1python -c from utils import utils;utils.plot_results() &emsp;&emsp;运行结束后，会在主文件夹下生成一个result.png。&emsp;&emsp;注：不知道为啥Classification没有显示…","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://cxx0822.github.io/categories/深度学习/"}],"tags":[]},{"title":"基于卷积神经网络的猫狗分类器","slug":"基于卷积神经网络的猫狗分类器","date":"2019-06-04T00:26:56.000Z","updated":"2022-03-31T12:16:20.444Z","comments":true,"path":"2019/06/04/ji-yu-juan-ji-shen-jing-wang-luo-de-mao-gou-fen-lei-qi/","link":"","permalink":"http://cxx0822.github.io/2019/06/04/ji-yu-juan-ji-shen-jing-wang-luo-de-mao-gou-fen-lei-qi/","excerpt":"","text":"摘要&emsp;&emsp;Cats vs. Dogs（猫狗大战）是Kaggle大数据竞赛某一年的一道赛题，利用给定的数据集，用算法实现猫和狗的识别。本博客设计了一个简单的两层卷积神经网络，利用TensorFlow深度学习框架进行模型训练，最终得到一个简单的二分类器。&emsp;&emsp;本博客从数据集开始讲起，然后通过模型搭建、模型训练和模型测试依次讲解深度学习目标检测常用的步骤，并穿插着TensorFlow框架的基础知识讲解，语言通俗易懂，十分适合刚入门的初学者学习。 平台&emsp;&emsp;系统：Windows 10&emsp;&emsp;环境：python 3.5.4&emsp;&emsp;编译器：Visual Studio Code 数据集处理获取数据集&emsp;&emsp;我们可以使用Kaggle官网上提供的数据集，读者可以在GitHub上下载，网址，或者从百度云下载：data，提取码：z9kn。当然了，我们也可以自己拍摄或采集一些数据集，为了保持和官网数据集命名格式的一致性，可以使用python的os库对自己采集的数据集进行批量重命名(如果是用官网的数据集，可以先跳过这一部分)。 123456789101112131415161718import osdef rename_files(dir_path): \"\"\" 批量重命名文件 参数： dirPath：文件路径 \"\"\" file_list = os.listdir(dir_path) index = 0 for item in file_list: oldname = dir_path + r\"\\\\\" + file_list[index] newname = dir_path + r\"\\\\\" + \"dog.\" + str(index) + \".jpg\" os.rename(oldname, newname) index += 1 &emsp;&emsp;首先利用os.listdir()从文件夹中获取所有的文件名，返回值file_list依次存放着每个文件的名字。然后利用for循环依次遍历列表，最后利用os.rename()对其重命名。(如果需要重命名猫的照片，将dog替换成cat即可。) 123if __name__ == \"__main__\": image_dir = r\"D:\\\\TensorFlow\\\\dog_and_cat\\\\test\" renameFiles(image_dir) &emsp;&emsp;例如我在D:\\\\TensorFlow\\\\dog_and_cat\\\\test文件夹中存放着采集的数据集，调用rename_files()函数后，可以看到所有的文件名字已经全部重命名。 打乱数据集&emsp;&emsp;为了提高数据集的鲁棒性和防止采集数据时的人为性，我们可以先将数据集随机打乱，至于是读取数据时还是训练时打乱，读者可以自己选择。本博客采用读取数据时打乱。 123456789101112131415161718192021222324252627282930313233343536373839404142434445def get_all_files(file_path, is_random=True): \"\"\" 获取图片路径及其标签 参数： file_path: a string 图片所在目录 file_path：true or flase 是否乱序 返回值： imageList：a list 图像列表 lableList：a list 标签列表 \"\"\" image_list, label_list = [], [] cat_count, dog_count = 0, 0 # 从文件夹中读取文件名字 for item in os.listdir(file_path): # listdir()：返回指定路径下的文件和文件夹列表 item_path = file_path + '\\\\' + item item_label = item.split('.')[0] if os.path.isfile(item_path): # isfile()：判断某一路径是否为文件 image_list.append(item_path) else: raise ValueError('no file.') if item_label == 'cat': label_list.append(0) cat_count += 1 else: label_list.append(1) dog_count += 1 print(\"There are %d cats, %d dogs.\" % (cat_count, dog_count)) image_list = np.asarray(image_list) # 当数据源是ndarray时，array会copy出一个副本，占用新的内存，但asarray不会 label_list = np.asarray(label_list) if is_random: rnd_index = np.arange(len(image_list)) np.random.shuffle(rnd_index) # 将文件乱序 # shuffle()：将序列的所有元素随机排序 image_list = image_list[rnd_index] label_list = label_list[rnd_index] return image_list, label_list &emsp;&emsp;首先初始化存储数据和标签的列表，然后依次遍历文件夹并读取名字，如果是文件则将文件名存储到image_list列表中，并将文件名的第一个参数存储到label_list列表中，然后分别统计猫和狗的数量。最后我们利用numpy中的shuffle()函数将列表打乱。 1234if __name__ == \"__main__\": image_dir = r\"D:\\\\TensorFlow\\\\dogAndCat\\\\test\" train_list = get_all_files(image_dir) print(train_list) &emsp;&emsp;这里我们采用10张猫和10张狗的照片进行了一个简单的测试，其结果如图所示：&emsp;&emsp;可以看出所有的数据集都已经全部打乱。 数据集分批次处理&emsp;&emsp;这里的处理主要涉及到两个方面，第一，分批次获取数据集，因为一次性将所有25000张图片载入内存不现实也不必要，所以将图片分成不同批次进行训练，第二，由于采集的数据集大小并不统一，所以很有必要先将其调整到一个统一的大小。&emsp;&emsp;在讲解如何分批处理前，首先要知道TensorFlow是如何读取数据的。 tensorflow读取数据机制&emsp;&emsp;TensorFlow中为了充分利用GPU，减少GPU等待数据的空闲时间，使用了两个线程分别执行数据读入和数据计算。具体来说就是使用一个线程源源不断的将硬盘中的图片数据读入到一个内存队列中，另一个线程负责计算任务，所需数据直接从内存队列中获取。&emsp;&emsp;TensorFlow在内存队列之前，还设立了一个文件名队列，文件名队列存放的是参与训练的文件名，要训练N个epoch(1个epoch等于使用训练集中的全部样本训练一次)，则文件名队列中就含有N个批次的所有文件名。如图所示：&emsp;&emsp;在N个epoch的文件名最后是一个结束标志，当TensorFlow读到这个结束标志的时候，会抛出一个OutofRange 的异常，外部捕获到这个异常之后就可以结束程序了。&emsp;&emsp;而创建TensorFlow的文件名队列就需要使用到 tf.train.slice_input_producer()函数。 tf.train.slice_input_producer()&emsp;&emsp;tf.train.slice_input_producer()是一个tensor生成器，作用是按照设定，每次从一个tensor列表中按顺序或者随机抽取出一个tensor放入文件名队列。&emsp;&emsp;其函数头为：1slice_input_producer(tensor_list, num_epochs=None, shuffle=True, seed=None, capacity=32, shared_name=None, name=None) &emsp;&emsp;tensor_list是输入，格式为tensor的列表；一般为[data, label]，即由特征和标签组成的数据集，num_epochs是抽取batch(批次)的次数，如果没有给定值，那么将会抽取无数次batch(这会导致你训练过程停不下来)，如果给定值，那么在到达次数之后就会报OutOfRange的错误，shuffle是是否随机打乱，seed是随机种子，capcity是队列容量的大小，为整数，name是名称。&emsp;&emsp;其返回值为tensor的列表，其结果和tensor_list一致。例如将之前的train_list作为输入，其结果显示为：12345if __name__ == \"__main__\": image_dir = r\"D:\\\\TensorFlow\\\\dog_and_cat\\\\test\" train_list = get_all_files(image_dir, is_random=False) intput_queue = tf.train.slice_input_producer(train_list, shuffle=False) print(intput_queue) &emsp;&emsp;结果为：[&lt;tf.Tensor &#39;input_producer/GatherV2:0&#39; shape=() dtype=string&gt;, &lt;tf.Tensor &#39;input_producer/GatherV2_1:0&#39; shape=() dtype=int32&gt;]，其中第一个就是对应的image_list的向量，第二个为label_list。&emsp;&emsp;有了队列之后就可以使用tf.train.batch()或tf.train.shuffle_batch()来生成批次大小为batch_size的tensor。 tf.train.batch()和tf.train.shuffle_batch()&emsp;&emsp;其函数头为：1tf.train.batch([data, label], batch_size=batch_size, capacity=capacity,num_threads=num_thread,allow_smaller_final_batch=True) 1tf.train.shuffle_batch([data, label], batch_size=batch_size, capacity=capacity,num_threads=num_thread,allow_smaller_final_batch=True) &emsp;&emsp;[data，label]是输入的样本和标签，batch_size是batch的大小，capcity是队列的容量，num_threads是线程数，使用多少个线程来控制整个队列，allow_smaller_final_batch这个是当最后的几个样本不够组成一个batch的时候用的参数，如果为True则会重新组成一个batch。这2个区别在于一个是顺序产生，一个是随机产生(有shuffle是随机产生)。 batch取值&emsp;&emsp;这里比较重要的一个参数是batch的取值，batch_size(批尺寸)是机器学习/深度学习中一个重要参数。其含义及取值可以参考这篇博客：网址&emsp;&emsp;本博客采用的取值为batch_size=1，即每次只训练一个样本，也就是在线学习(Online Learning)。这也是Stochastic Gradient Descent(SGD，随机梯度下降算法)的更新规则，即：一次只进行一次更新，就没有冗余，而且比较快，并且可以新增样本。 生成数据集12345678910111213141516171819202122232425262728293031323334353637def get_batch(train_list, image_size, batch_size, capacity, is_random=True): \"\"\" 分批次获取图片 参数： train_list: 2-D list, [image_list, label_list] image_size: a int, 训练图像大小(image_size*image_size) batch_size: a int, 每个批次包含的样本数量 capacity: a int, 队列容量 is_random: True or False, 是否乱序 返回值： image_train_batch：图像批次 label_train_batch：标签批次 \"\"\" intput_queue = tf.train.slice_input_producer(train_list, shuffle=False) # 从路径中读取图片 image_train = tf.read_file(intput_queue[0]) image_train = tf.image.decode_jpeg(image_train, channels=3) # 这里是jpg格式 image_train = tf.image.resize_images(image_train, [image_size, image_size]) image_train = tf.cast(image_train, tf.float32) / 255. # 转换数据类型并归一化 # 图片标签 label_train = intput_queue[1] # 获取批次 if is_random: image_train_batch, label_train_batch = tf.train.shuffle_batch([image_train, label_train], batch_size=batch_size, capacity=capacity, min_after_dequeue=100, num_threads=2) else: image_train_batch, label_train_batch = tf.train.batch([image_train, label_train], batch_size=batch_size, capacity=capacity, num_threads=1) return image_train_batch, label_train_batch &emsp;&emsp;获取到图片队列后，首先用read_file()读取图片，然后按照图片格式进行解码。本博客中训练数据是jpg格式的，所以使用decode_jpeg()解码器，如果是其他格式，就要用其他解码器。注意decode出来的数据类型是uint8，之后模型卷积层里面conv2d()要求输入数据为float32类型，所以如果删掉标准化步骤之后，需要进行类型转换。最后还需要将图片裁剪成相同大小(img_W和img_H)。这里使用resize_images()对图像进行缩放，而不是裁剪，采用NEAREST_NEIGHBOR插值方法。标签队列比较简单，直接获取即可。然后在利用tf.train.batch()将其分批次处理。&emsp;&emsp;同样的我们进行简单的测试：12345if __name__ == \"__main__\": image_dir = r\"D:\\\\TensorFlow\\\\dog_and_cat\\\\test\" train_list = get_all_files(image_dir, is_random=False) image_train_batch, label_train_batch = get_batch(train_list, 256, 1, 200, False) print(image_train_batch, label_train_batch) &emsp;&emsp;这里我们将batch_size设置为1，也就是一次取一张照片，其输出结果为：Tensor(&quot;batch:0&quot;, shape=(1, 256, 256, 3), dtype=float32) Tensor(&quot;batch:1&quot;, shape=(1,), dtype=int32)。 数据集可视化&emsp;&emsp;之前的叙述都只是搭建模型，下面我们可以启动TensorFlow会话将图片显示出来。这里需要使用tf.train.Coordinator()来创建一个线程管理器(协调器)对象。1234567891011121314151617181920212223242526272829303132333435if __name__ == \"__main__\": import matplotlib.pyplot as plt image_dir = r\"D:\\\\TensorFlow\\\\dog_and_cat\\\\test\" train_list = get_all_files(image_dir, is_random=False) print(train_list) image_train_batch, label_train_batch = get_batch(train_list, 250, 1, 250, False) sess = tf.Session() coord = tf.train.Coordinator() # 创建一个线程管理器(协调器)对象 threads = tf.train.start_queue_runners(sess=sess, coord=coord) # 启动tensor的入队线程 try: for step in range(10): if coord.should_stop(): break image_batch, label_batch = sess.run([image_train_batch, label_train_batch]) # 返回列表的值 if label_batch[0] == 0: label = 'Cat' else: label = 'Dog' # 显示图片 plt.imshow(image_batch[0]) plt.title(label) plt.show() except tf.errors.OutOfRangeError: print('Done.') finally: coord.request_stop() coord.join(threads=threads) sess.close() &emsp;&emsp;在讲解这部分代码之前，我们首先要简单了解一下TensorFlow的多线程概念。&emsp;&emsp;TensorFlow的Session对象是支持多线程的，可以在同一个会话(Session)中创建多个线程，并行执行。在Session中的所有线程都必须能被同步终止，异常必须能被正确捕获并报告，会话终止的时候， 队列必须能被正确地关闭。&emsp;&emsp;TensorFlow提供了两个类来实现对Session中多线程的管理：tf.Coordinator和tf.QueueRunner，这两个类往往一起使用。Coordinator类用来管理在Session中的多个线程，可以用来同时停止多个工作线程并且向那个在等待所有工作线程终止的程序报告异常，该线程捕获到这个异常之后就会终止所有线程。使用tf.train.Coordinator()来创建一个线程管理器(协调器)对象。&emsp;&emsp;QueueRunner类用来启动tensor的入队线程，可以用来启动多个工作线程同时将多个tensor(训练数据)推送入文件名称队列中，具体执行函数是tf.train.start_queue_runners，只有调用 tf.train.start_queue_runners之后，才会真正把tensor推入内存序列中，供计算单元调用，否则会由于内存序列为空，数据流图会处于一直等待状态。 &emsp;&emsp;结合上述理论，我们再次了解一下TensorFlow的数据读取机制： 调用 tf.train.slice_input_producer，从本地文件里抽取tensor，准备放入Filename Queue（文件名队列）中; 调用 tf.train.batch，从文件名队列中提取tensor，使用单个或多个线程，准备放入文件队列; 调用 tf.train.Coordinator() 来创建一个线程协调器，用来管理之后在Session中启动的所有线程; 调用tf.train.start_queue_runners, 启动入队线程，由多个或单个线程，按照设定规则，把文件读入Filename Queue中。函数返回线程ID的列表，一般情况下，系统有多少个核，就会启动多少个入队线程（入队具体使用多少个线程在tf.train.batch中定义）; 文件从 Filename Queue中读入内存队列的操作不用手动执行，由tf自动完成; 调用sess.run 来启动数据出列和执行计算; 使用 coord.should_stop()来查询是否应该终止所有线程，当文件队列（queue）中的所有文件都已经读取出列的时候，会抛出一个OutofRangeError 的异常，这时候就应该停止Sesson中的所有线程了; 使用coord.request_stop()来发出终止所有线程的命令，使用coord.join(threads)把线程加入主线程，等待threads结束。 &emsp;&emsp;有了上述2个理论基础，我们就可以理解之前的代码了，首先启动会话，然后启动线程管理器，然后将之前的训练数据依次放入队列中，这里加了一个图片显示，主要是利用matplotlib这个库，最后在依次终止所有的线程和会话。&emsp;&emsp;这是其中的一张图片的显示结果。 模型搭建&emsp;&emsp;有了数据集后，我们就可以正式搭建卷积神经网络的结构了。这里主要是仿照TensorFlow的官方例程cifar-10网络结构来写的。就是两个卷积层（每个卷积层后加一个池化层），两个全连接层，最后一个softmax输出分类结果。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import tensorflow as tfdef inference(images, batch_size, n_classes): # conv1, shape = [kernel_size, kernel_size, channels, kernel_numbers] with tf.variable_scope(\"conv1\") as scope: weights = tf.get_variable(\"weights\", shape=[3, 3, 3, 16], dtype=tf.float32, initializer=tf.truncated_normal_initializer(stddev=0.1, dtype=tf.float32)) biases = tf.get_variable(\"biases\", shape=[16], dtype=tf.float32, initializer=tf.constant_initializer(0.1)) conv = tf.nn.conv2d(images, weights, strides=[1, 1, 1, 1], padding=\"SAME\") pre_activation = tf.nn.bias_add(conv, biases) conv1 = tf.nn.relu(pre_activation, name=\"conv1\") # pool1 &amp;&amp; norm1 with tf.variable_scope(\"pooling1_lrn\") as scope: pool1 = tf.nn.max_pool(conv1, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding=\"SAME\", name=\"pooling1\") norm1 = tf.nn.lrn(pool1, depth_radius=4, bias=1.0, alpha=0.001/9.0, beta=0.75, name='norm1') # conv2 with tf.variable_scope(\"conv2\") as scope: weights = tf.get_variable(\"weights\", shape=[3, 3, 16, 16], dtype=tf.float32, initializer=tf.truncated_normal_initializer(stddev=0.1, dtype=tf.float32)) biases = tf.get_variable(\"biases\", shape=[16], dtype=tf.float32, initializer=tf.constant_initializer(0.1)) conv = tf.nn.conv2d(norm1, weights, strides=[1, 1, 1, 1], padding=\"SAME\") pre_activation = tf.nn.bias_add(conv, biases) conv2 = tf.nn.relu(pre_activation, name=\"conv2\") # pool2 &amp;&amp; norm2 with tf.variable_scope(\"pooling2_lrn\") as scope: pool2 = tf.nn.max_pool(conv2, ksize=[1, 3, 3, 1], strides=[1, 2, 2, 1], padding=\"SAME\", name=\"pooling2\") norm2 = tf.nn.lrn(pool2, depth_radius=4, bias=1.0, alpha=0.001/9.0, beta=0.75, name='norm2') # full-connect1 with tf.variable_scope(\"fc1\") as scope: reshape = tf.reshape(norm2, shape=[batch_size, -1]) dim = reshape.get_shape()[1].value weights = tf.get_variable(\"weights\", shape=[dim, 128], dtype=tf.float32, initializer=tf.truncated_normal_initializer(stddev=0.005, dtype=tf.float32)) biases = tf.get_variable(\"biases\", shape=[128], dtype=tf.float32, initializer=tf.constant_initializer(0.1)) fc1 = tf.nn.relu(tf.matmul(reshape, weights) + biases, name=\"fc1\") # full_connect2 with tf.variable_scope(\"fc2\") as scope: weights = tf.get_variable(\"weights\", shape=[128, 128], dtype=tf.float32, initializer=tf.truncated_normal_initializer(stddev=0.005, dtype=tf.float32)) biases = tf.get_variable(\"biases\", shape=[128], dtype=tf.float32, initializer=tf.constant_initializer(0.1)) fc2 = tf.nn.relu(tf.matmul(fc1, weights) + biases, name=\"fc2\") # softmax with tf.variable_scope(\"softmax_linear\") as scope: weights = tf.get_variable(\"weights\", shape=[128, n_classes], dtype=tf.float32, initializer=tf.truncated_normal_initializer(stddev=0.005, dtype=tf.float32)) biases = tf.get_variable(\"biases\", shape=[n_classes], dtype=tf.float32, initializer=tf.constant_initializer(0.1)) softmax_linear = tf.add(tf.matmul(fc2, weights), biases, name=\"softmax_linear\") softmax_linear = tf.nn.softmax(softmax_linear) return softmax_linear &emsp;&emsp;整体主要分为三个部分，即卷积+池化层，全连接层，softmax输出。&emsp;&emsp;在正式讲解前，我们先了解几个比较重要的函数。 tf.nn.conv2d()：卷积函数函数头为：tf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, name=None)input：输入图像，形式为：[batch, in_height, in_width, in_channels]，即训练一个batch的图片数量，图片高度，图片宽度，图像通道数。filter：相当于卷积核，形式为：[filter_height, filter_width, in_channels, out_channels]，具体含义为：[卷积核的高度，滤波器的宽度，图像通道数，滤波器个数]，这里的第三维in_channels就是参数input的第四维。strides：卷积时在图像每一维的步长，是一个一维的向量，长度为4，其中strides[0]=strides[3]=1，strides[1]表示输入图像in_height的滑动步长，strides[2]表示输入图像in_weight的滑动步长。padding：当其值为VALID时，表示边缘不填充，当其值为SAME时，表示填充。 tf.nn.max_pool()：池化函数函数头为：tf.nn.max_pool(input, ksize, strides, padding, name=None)这里面的input,strides和padding和之前的卷积函数里面的几乎一样，唯一有点不同的是ksize，这个表示池化窗口的大小，一般是[1,height,width,1]，因为一般我们不在batch和channels上做池化，所以这两个维度都设为1。 tf.nn.lrn()：局部响应归一化函数函数头为：tf.nn.lrn(input,depth_radius=None,bias=None,alpha=None,beta=None,name=None)局部响应归一化原理是仿造生物学上活跃的神经元对相邻神经元的抑制现象(侧抑制)，其公式如下：计算方法如下：sqr_sum[a, b, c, d] = sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2),output = input / (bias + alpha * sqr_sum) ** beta。N表示通道数(channel)。a,n/2,k,α,β分别表示函数中的input,depth_radius,bias,alpha,beta。具体含义可以参考这篇博客：网址。 卷积+池化层&emsp;&emsp;这里一共有2层，首先利用tf.variable_scope()定义变量的作用域并重命名，下同。然后利用tf.get_variable()分别创建weights变量和biases变量，下同。truncated_normal_initializer()和tf.constant_initializer()都是参数初始化函数，读者可以自己查阅。然后利用tf.nn.conv2d()函数进行卷积，其中input为图像，也就是函数的输入，filter为weights，这里的取值为[3,3,3,16]，前面的2个3表示滤波器的大小为3*3，后面的3是因为图像的通道数为3，最后的16表示一共使用16个3*3的滤波器。stride取值为1，即步长为1，且边缘填充。最后将其和偏差相加并输入到Rule激活函数中，下同。&emsp;&emsp;接下来就是一个池化层，相比较卷积层要简单了很多，这里的input就是刚才的池化层1，即conv1，ksize取值为[1,3,3,1]，即滤波器的大小为3*3，这里的stride取值为2，且边缘填充。最后使用tf.nn.lrn()进行局部响应归一化。&emsp;&emsp;第二个的卷积和池化层和第一个类似，这里就不再叙述了。值得注意的是第二个卷积层中的[3,3,16,16]里面的第1个16表示的是上一层卷积层的第四个维度16，即16个滤波器的16。 全连接层&emsp;&emsp;全连接层是将所有的元素平整化为一个一维向量。每个全连接层的权重长度为2，分别为上一层的长度和该层的长度，从代码可以看出，两个全连接层的长度都是128，其中第一个全连接层的上一层长度是根据之前的池化层算出来的，也就是将所有的特征图的参数相乘，具体见下文分析。 softmax&emsp;&emsp;最后一个是softmax层，也就是最后的分类输出，其最后的网络输出长度也就是分类的个数，也就是函数的输入n_classes。 损失函数及评估&emsp;&emsp;搭建好网络结构后，后面的损失函数及评估就十分简单了，这里使用的是交叉熵损失函数，tf.nn.in_top_k()的使用方法也比较简单，读者可以自己查阅。1234567891011121314def losses(logits, labels): with tf.variable_scope('loss'): cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels) loss = tf.reduce_mean(cross_entropy) return lossdef evaluation(logits, labels): with tf.variable_scope(\"accuracy\"): correct = tf.nn.in_top_k(logits, labels, 1) correct = tf.cast(correct, tf.float16) accuracy = tf.reduce_mean(correct) return accuracy 网络结构再分析&emsp;&emsp;我们以208*208*3的输入图像为例，将卷积网络结构的形状、大小及参数汇总到如下的表格中：&emsp;&emsp;表中的第一列为每一层维度大小，第一个卷积层的16也就是该层使用的滤波器个数，而池化层会将之前的维度减半，后面的全连接层是一个一维列向量。表中的第二列为每一层的激活值尺寸，即将之前的维度全部相乘得到的值，第三列是每一层的参数个数。卷积层的计算公式为：(滤波器参数+1)*滤波器个数，其中1表示偏差。池化层没有参数，全连接层的计算公式为：(上一层维度+1)*这一层维度，这里的1也表示偏差。&emsp;&emsp;我们也可以用TensorFlow里面的tf.trainable_variables()将训练的变量找到并计算其数量：1234567891011121314if __name__ == '__main__': image_dir = r'D:\\\\TensorFlow\\\\dog_and_cat\\\\data\\\\train' sess = tf.Session() train_list = get_all_files(image_dir, True) image_train_batch, label_train_batch = get_batch(train_list, 208, 8, 200, True) train_logits = inference(image_train_batch, 2) var_list = tf.trainable_variables() for v in var_list: print(v, end='\\n') paras_count = tf.reduce_sum([tf.reduce_prod(v.shape) for v in var_list]) print('The number of parameters are :%d' % sess.run(paras_count), end='\\n\\n') &emsp;&emsp;结果显示为：&emsp;&emsp;可以看出，其结果和之前我们计算的一致。注：paras_count计算步骤为：先找到每个变量的维度，然后再计算各个维度相乘的积，最后再求和。&emsp;&emsp;由表可见，随着卷积网络的加深，激活值尺寸由开始的692224，慢慢地减少到43264，最后减少到softmax层的2，当然如果激活尺寸下降太快，也会影响神经网络的性能。我们还能观察到其大部分的参数都是集中在全连接层。&emsp;&emsp;当然了，这个卷积网络的参数也可以取其他的值。读者可以在代码中自行修改。 模型训练&emsp;&emsp;下面就是将之前的函数综合起来进行模型训练。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import timefrom load_data import *from model import *import matplotlib.pyplot as plt# 训练模型def training(): N_CLASSES = 2 IMG_SIZE = 208 BATCH_SIZE = 8 CAPACITY = 200 MAX_STEP = 10000 LEARNING_RATE = 1e-4 # 测试图片读取 image_dir = r'D:\\\\TensorFlow\\\\dog_and_cat\\\\data\\\\train_2' sess = tf.Session() train_list = get_all_files(image_dir, True) image_train_batch, label_train_batch = get_batch(train_list, IMG_SIZE, BATCH_SIZE, CAPACITY, True) train_logits = inference(image_train_batch, N_CLASSES) train_loss = losses(train_logits, label_train_batch) train_acc = evaluation(train_logits, label_train_batch) train_op = tf.train.AdamOptimizer(LEARNING_RATE).minimize(train_loss) saver = tf.train.Saver() sess.run(tf.global_variables_initializer()) coord = tf.train.Coordinator() threads = tf.train.start_queue_runners(sess=sess, coord=coord) s_t = time.time() try: for step in range(MAX_STEP): if coord.should_stop(): break _, loss, acc = sess.run([train_op, train_loss, train_acc]) if step % 100 == 0: # 实时记录训练过程并显示 runtime = time.time() - s_t print('Step: %6d, loss: %.8f, accuracy: %.2f%%, time:%.2fs, time left: %.2fhours' % (step, loss, acc * 100, runtime, (MAX_STEP - step) * runtime / 360000)) s_t = time.time() saver.save(sess, r'D:\\\\TensorFlow\\\\dog_and_cat\\\\log\\\\model.cpkt') except tf.errors.OutOfRangeError: print('Done.') finally: coord.request_stop() coord.join(threads=threads) sess.close() &emsp;&emsp;首先初始化一些参数，其中分类类别为2，图像大小为208*208，batch_size为8，即一次训练8张图片，容量为200，迭代次数为10000，学习率为1e-4。然后初始化图片存放的位置。&emsp;&emsp;下面就正式启动会话，开始训练。先用get_all_files()函数将图片全部读入到train_list列表中，然后将该列表放到get_batch中获取训练批次image_train_batch和label_train_batch，其次放入到之前设计好的卷积网络模型中，得到模型的输出train_logits，并依次进行损失函数和评估处理以得到正确率。最后使用自适应矩估计算法AdamOptimizer()进行反向传播的参数优化。&emsp;&emsp;接下来是用Saver()将训练好的模型保存，因为卷积网络的计算量很大，每次运行都耗费很长时间，所以很有必要将训练好的模型保存以便下次处理。&emsp;&emsp;再往下就是调用run()函数实际运行了，首先初始化所有变量，然后调用线程(见上文分析)，最后就是迭代训练，每100次显示训练的正确率。&emsp;&emsp;注：如果设置迭代次数为10000次，一次训练大概需要2个小时左右。 模型测试&emsp;&emsp;训练好模型后，就可以拿测试集数据来检验模型的正确性了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546def eval(): N_CLASSES = 2 IMG_SIZE = 208 BATCH_SIZE = 1 CAPACITY = 200 MAX_STEP = 10 test_dir = r'D:\\\\TensorFlow\\\\dog_and_cat\\\\data\\\\test' sess = tf.Session() train_list = get_all_files(test_dir, is_random=True) image_train_batch, label_train_batch = get_batch(train_list, IMG_SIZE, BATCH_SIZE, CAPACITY, True) train_logits = inference(image_train_batch, N_CLASSES) train_logits = tf.nn.softmax(train_logits) # 用softmax转化为百分比数值 # 载入模型 saver = tf.train.Saver() saver.restore(sess, 'log\\\\model.cpkt') coord = tf.train.Coordinator() threads = tf.train.start_queue_runners(sess=sess, coord=coord) try: for step in range(MAX_STEP): if coord.should_stop(): break image, prediction = sess.run([image_train_batch, train_logits]) print('prediction', prediction) max_index = np.argmax(prediction) if max_index == 0: label = '%.2f%% is a cat.' % (prediction[0][0] * 100) else: label = '%.2f%% is a dog.' % (prediction[0][1] * 100) plt.imshow(image[0]) plt.title(label) plt.show() except tf.errors.OutOfRangeError: print('Done.') finally: coord.request_stop() coord.join(threads=threads) sess.close() &emsp;&emsp;程序和训练模型的程序几乎一致，唯一的区别在于，这里放入run()函数运行的部分是image_train_batch和train_logits，即图像批次和训练结果。这里的prediction也就是每个类别的置信度，即是猫或是狗的概率。接下来就是分析该概率，接近于0则表示是猫，否则为狗。最后用matplotlib库将图像显示出来：&emsp;&emsp;这是某一张图的结果，从结果可以看出，该模型的输出结果为[0.0494897,0.9505103]，即认为4%的概率是猫，95%的概率是狗。 结论&emsp;&emsp;本博客利用TensorFlow搭建了一个简单的两层卷积神经网络结构，基本实现了猫狗分类器，正确率和置信度总体上还可以，基本上能达到要求，毕竟我们只是使用了一个非常简单的卷积网络，但正确率和置信度仍有提高的空间，读者可以适当的增加网络层数，并设置好相应的参数，以改变模型的正确率。&emsp;&emsp;由于本人也是初学深度学习，有写的不好或写错的地方还望读者多多留言指出，以便后续的改进。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://cxx0822.github.io/categories/深度学习/"}],"tags":[]},{"title":"NAO比赛视觉系统设计（python高级版）","slug":"NAO比赛视觉系统设计（python高级版）","date":"2019-04-27T07:18:47.000Z","updated":"2022-03-31T12:03:38.691Z","comments":true,"path":"2019/04/27/nao-bi-sai-shi-jue-xi-tong-she-ji-python-gao-ji-ban/","link":"","permalink":"http://cxx0822.github.io/2019/04/27/nao-bi-sai-shi-jue-xi-tong-she-ji-python-gao-ji-ban/","excerpt":"","text":"概述&emsp;&emsp;之前初级版的视觉系统设计只是通过opnecv简单处理了NAO获得的图像，然后再加上一些判断条件（主要是颜色条件），最后如果满足条件则认为是该目标。虽然总体上可以实现目标的识别，但很容易受到现场环境的影响，不是特别稳定。&emsp;&emsp;在高级版的设计中，我们采用了机器学习中的分类算法。首先根据opencv中的检测算法得到候选区域，然后通过对候选区域的特征提取获得其特征向量，最后通过这些特征向量离线训练分类器模型，从而得到一个较好的分类器。而且该方法适用于任何目标的检测。 候选区域&emsp;&emsp;候选区域的提取是传统图像处理的第一步，能否正确提取到候选区域直接决定着能否检测到目标，现在的机器学习分类算法在分类结果上基本上都能达到很好效果，正确率也能满足要求，但往往在特征区域的提取上会出现偏差甚至检测不到。所以特征提取这一步至关重要。&emsp;&emsp;下面创建一个通用的目标检测类TargetDetection，想用什么方法获得候选区域，就在类中封装成一个方法即可，最后统一返回候选区域(矩形)的左上角和右下角坐标，以便后续的处理。 预处理&emsp;&emsp;之前初级版并没有对原图进行过多的预处理，虽然在比赛时，背景颜色比较单一，不加预处理也可以得到理想的效果，但是为了提高检测的精确度和应用的广泛性，这里稍微加了几个图像处理的方法。&emsp;&emsp;首先介绍几个常见的预处理方法。 灰度化&emsp;&emsp;将彩色图像转化成为灰度图像的过程称为图像的灰度化处理。彩色图像中的每个像素的颜色有R、G、B三个分量决定，而每个分量的取值为[0, 255]，每个像素一共有255*255*255种情况。而灰度图像是R、G、B三个分量相同的一种特殊的彩色图像，所以每个像素一共只有255种情况，所以在数字图像处理种一般先将各种格式的图像转变成灰度图像以使后续的图像的计算量变得少一些。&emsp;&emsp;灰度图像的描述与彩色图像一样仍然反映了整幅图像的整体和局部的色度和亮度等级的分布和特征。图像的灰度化处理可用两种方法来实现。&emsp;&emsp;第一种方法是求出每个像素点的R、G、B三个分量的平均值，然后将这个平均值赋予给这个像素的三个分量。第二种方法是根据YUV的颜色空间中，Y的分量的物理意义是点的亮度，由该值反映亮度等级，根据RGB和YUV颜色空间的变化关系可建立亮度Y与R、G、B三个颜色分量的对应：Y=0.3R+0.59G+0.11B，以这个亮度值表达图像的灰度值。(一般采用第二种方法。)&emsp;&emsp;opencv中实现：cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) 二值化&emsp;&emsp;将图像上点的灰度置为0或255的过程称为二值化处理，也就是将整个图像呈现出明显的黑白效果(非黑即白)。&emsp;&emsp;所有灰度大于或等于阀值的像素被判定为属于特定物体，其灰度值为255表示，否则这些像素点被排除在物体区域以外，灰度值为0，表示背景或者例外的物体区域。&emsp;&emsp;opencv中实现：cv2.threshold(src, threshold, maxValue, method) 图像滤波&emsp;&emsp;图像滤波，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。&emsp;&emsp;高斯滤波是一种线性平滑滤波，可以消除高斯噪声。每一个像素点的值，都由其本身和领域内的其他像素值经过加权平均(高斯函数)后得到。&emsp;&emsp;opencv中实现：cv2.GaussianBlur(img, ksize, sigmaX) HSV空间的二值化&emsp;&emsp;预处理的主要思想是，先将颜色通道转换为HSV空间，当然也可以转到其他的颜色空间，只是实际测试下来发现，HSV空间更加稳定，适合比赛的环境。其次根据HSV空间颜色分布表，设置相应的阈值，将符合的颜色区间二值化，得到一个只有目标区域的图像分布，最后加上几个简单的滤波算法去除噪声。&emsp;&emsp;上表为HSV颜色空间表，即每个颜色对应的三个通道的范围。HSV即色相(Hue)、饱和度(Saturation)和明度(Value)。根据其范围，我们就可以将我们需要的颜色提取出来，并二值化处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# coding: utf-8import cv2import cv2.cv as cvimport numpy as npclass TargetDetection(object): ''' Target Detection：目标检测基类，主要用于图像的预处理，以便后续检测更加精确 ''' def __init__(self, img): self.img = img def preProcess(self, img, object): ''' Pre Process：预处理 Arguments: img：图像 object：红球(redball)/足球(football)/黄杆(stick) Return: binImg：二值化后的图像 ''' if object == \"redball\": HSVImg = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) # 转到HSV空间 # HSV空间颜色判断，具体参见表格 smin1, vmin1, hmax1, hmin2 = 9, 21, 39, 153 # 调用滑动条函数（sliderObjectHSV）得到理想值 minHSV1 = np.array([0, smin1, vmin1]) maxHSV1 = np.array([hmax1, 255, 255]) minHSV2 = np.array([hmin2, smin1, vmin1]) maxHSV2 = np.array([180, 255, 255]) # 二值化处理 binImg1 = cv2.inRange(HSVImg, minHSV1, maxHSV1) binImg2 = cv2.inRange(HSVImg, minHSV2, maxHSV2) binImg = np.maximum(binImg1, binImg2) # 图像滤波处理（腐蚀，膨胀，高斯） binImg = self.filter(binImg)) else: print('''Please input \"redball\" or \"football\" or \"stick\" in preProcess()''') return binImg def filter(self, img): ''' 图像滤波处理（腐蚀，膨胀，高斯） Arguments: img：图像 Return: resImg：处理后的图像 ''' kernelErosion = np.ones((3, 3), np.uint8) kernelDilation = np.ones((3, 3), np.uint8) resImg = cv2.erode(img, kernelErosion, iterations=2) resImg = cv2.dilate(resImg, kernelDilation, iterations=3) resImg = cv2.GaussianBlur(resImg, (9, 9), 1.5) return resImg &emsp;&emsp;首先利用cvtColor()将其转换为HSV空间，然后由表可知目标的颜色范围，从而得到其上限和下限(红色有2个区间)，最后利用inRange()将其二值化。inRange()：将在两个阈值内的像素值设置为白色(255)，而不在阈值区间内的像素值设置为黑色(0)。 最后加个几个简单的滤波处理算法。这里给出了红球的二值化代码，足球和黄杆的代码读者可以先自行考虑。 123456789if __name__ == '__main__': srcImg = cv2.imread(\"./redball_1/5.jpg\") # 红球 tarDet = TargetDetection(srcImg) binImg = tarDet.preProcess(srcImg, \"redball\") # 红球 cv2.imshow(\"srcImg\", srcImg) cv2.imshow(\"binImg\", binImg) cv2.waitKey(0) cv2.destroyAllWindows() &emsp;&emsp;为了克服比赛时场地和光线的干扰，这里的阈值参数可以通过滑动条函数来获得。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def sliderObjectHSV(self, object): ''' HSV滑动条函数，为了获得理想的HSV阈值 Arguments: object：红球(redball)/足球(football)/黄杆(stick) ''' if object == \"redball\": cv2.namedWindow(\"redball\") # 创建滑动条 cv2.createTrackbar(\"hmax1\", \"redball\", 1, 20, self.nothing) cv2.createTrackbar(\"smin1\", \"redball\", 30, 60, self.nothing) cv2.createTrackbar(\"vmin1\", \"redball\", 30, 60, self.nothing) cv2.createTrackbar(\"hmin2\", \"redball\", 156, 175, self.nothing) img = self.img.copy() HSVImg = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) while True: srcImg = img.copy() # 获取滑动条的值 hmax1 = cv2.getTrackbarPos(\"hmax1\", \"redball\") smin1 = cv2.getTrackbarPos(\"smin1\", \"redball\") vmin1 = cv2.getTrackbarPos(\"vmin1\", \"redball\") hmin2 = cv2.getTrackbarPos(\"hmin2\", \"redball\") # HSV空间颜色判断 minHSV1 = np.array([0, smin1, vmin1]) maxHSV1 = np.array([hmax1, 255, 255]) minHSV2 = np.array([hmin2, smin1, vmin1]) maxHSV2 = np.array([180, 255, 255]) binImg1 = cv2.inRange(HSVImg, minHSV1, maxHSV1) binImg2 = cv2.inRange(HSVImg, minHSV2, maxHSV2) binImg = np.maximum(binImg1, binImg2) # 图像滤波处理 binImg = self.filter(binImg) cv2.imshow(\"srcImg\", img) cv2.imshow(\"redball\", binImg) cv2.waitKey(1) cv2.destroyAllWindows() else: print('''Please input \"redball\" or \"football\" or \"stick\" in sliderObjectHSV()''')def nothing(self, x): pass &emsp;&emsp;将其HSV空间的临界值设置为滑动条参数即可。现场调试时，根据实际情况选择一个最优的参数。这里同样只给出红球的代码实例。 霍夫圆检测&emsp;&emsp;针对NAO比赛中的红球和足球，我们可以采用opencv中的霍夫圆检测技术将其检测出来。其函数声明为：HoughCircles(img, method, dp, minDist, param1=100, param2=100, minRadius=0, maxRadius=0)，其中method一般为霍夫梯度法，即cv2.cv.CV_HOUGH_GRADIENT，dp=1, param1=100, param2=20，比较重要的参数是圆之间的距离minDist，圆的最小和最大半径minRadius和maxRadius。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class HoughDetection(TargetDetection): ''' Hough Detection：霍夫圆检测 ''' def __init__(self, img): super(HoughDetection, self).__init__(img) def houghDetection(self, img, minDist=100, minRadius=25, maxRadius=80, isShow=False): ''' 霍夫圆检测 Arguments: img：图像 minDist：两圆之间最小间距 minRadius：圆的最小半径 maxRadius：圆的最大半径 isShow：是否显示结果 Return: circles：检测出来的圆 ''' srcImg = self.img.copy() circles = cv2.HoughCircles(img, cv.CV_HOUGH_GRADIENT, 1, minDist, param1=100, param2=20, minRadius=minRadius, maxRadius=maxRadius) if circles is None: circles = [] print(\"no circle\") else: circles = circles[0, ] if isShow is True: self.showHoughResult(srcImg, circles) return circles def circle2Rect(self, circle, k=1): ''' 圆的信息转换为矩阵信息，以便后续处理 Arguments: circle：圆的信息：圆心坐标，半径 k：放缩因子 Return: rect：矩阵信息：左上角和右下角的坐标 ''' rect = [] x, y, r = int(circle[0]), int(circle[1]), int(circle[2]) initX, initY = x - k * r, y - k * r endX, endY = x + k * r, y + k * r rect = [initX, initY, endX, endY] return rect def showHoughResult(self, img, circles, timeMs=0): ''' 显示霍夫圆检测结果 Arguments: img：图像 circles：圆 timeMs：延迟时间，0表示一直显示 ''' for circle in circles: rect = self.circle2Rect(circle) initX, initY = rect[0], rect[1] endX, endY = rect[2], rect[3] cv2.rectangle(img, (initX, initY), (endX, endY), (0, 0, 255), 2) # 画矩形 x, y, r = int(circle[0]), int(circle[1]), int(circle[2]) cv2.circle(img, (x, y), r, (0, 0, 255), 2) # 画圆 cv2.imshow(\"Hough Result\", img) cv2.waitKey(timeMs) cv2.destroyAllWindows() &emsp;&emsp;在调用霍夫圆检测时，首先要将图片进行预处理。这里将比较重要的3个参数作为函数的参数，以便后续的红球和足球的处理。circle2Rect函数的作用是将圆的信息转换为矩阵的信息，并提供一个比例的参数接口，以便后续的矩形区域的调整，showHoughResult函数的作用是在原图中画出圆和矩阵。&emsp;&emsp;下面进行简单的测试，首选读取一张带有红球/足球的图片，然后创建对象并调用预处理方法和霍夫圆检测方法，并将isShow的参数设置为True将其结果显示出来。 12345678if __name__ == '__main__': srcImg = cv2.imread(\"./redball_1/5.jpg\") # 红球 # srcImg = cv2.imread(\"./img_1/5.jpg\") # 足球 hogDet = HoughDetection(srcImg) binImg = hogDet.preProcess(srcImg, \"redball\") # 红球 # binImg = hogDet.preProcess(srcImg, \"football\") # 足球 hogDet.houghDetection(binImg, minDist=100, minRadius=10, maxRadius=50, isShow=True) # 红球 # hogDet.houghDetection(binImg, minDist=100, minRadius=25, maxRadius=80, isShow=True) # 足球 &emsp;&emsp;实际测试发现，经过二值化处理后再用霍夫圆检测的效果要比之前直接霍夫圆检测好很多，基本上每次都能选中目标区域。&emsp;&emsp;注：实际测试发现，足球用霍夫圆检测效果并不是太好，轮廓检测(见下文分析)对于足球效果更好。可能因为红球是纯色，二值化后圆的特征比较明显，而足球呈黑白色，圆的特征不是太明显。 轮廓检测&emsp;&emsp;而对于NAO比赛中的黄杆，我们可以采用opencv中的轮廓检测算法。其函数声明为：cv2.findContours(image, mode, method[, contours[, hierarchy[, offset ]]])，其中mode表示轮廓的检索模式，这里选择cv2.RETR_EXTERNAL，即只检测外轮廓，method表示轮廓的近似办法，这里选择cv2.CHAIN_APPROX_NONE，即存储所有的轮廓点。其返回值有2个，contours和hierarchy，分别表示轮廓本身和每条轮廓对应的属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class ContoursDetection(TargetDetection): def __init__(self, img): super(ContoursDetection, self).__init__(img) def contoursDetection(self, img, minPerimeter=300, mink=2, isShow=False): ''' 轮廓检测 Arguments: img：图像 minPerimeter：轮廓最小周长 isShow：是否显示结果 Return: resultContours：检测出来的轮廓 ''' srcImg = self.img.copy() rects = [] contours, _ = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) resultContours = [] # 简单的轮廓周长及长宽比判断 for contour in contours: x, y, w, h = cv2.boundingRect(contour) k = h / w perimeter = cv2.arcLength(contour, True) if perimeter &gt; minPerimeter and k &gt;= mink: resultContours.append(contour) if resultContours == []: print(\"no contours\") else: if isShow is True: self.showContourResult(srcImg, resultContours) return resultContours def showContourResult(self, img, contours, timeMs=0): ''' 显示轮廓检测结果 Arguments: img：图像 contours：轮廓 timeMs：延迟时间，0表示一直显示 ''' cv2.drawContours(img, contours, -1, (0, 0, 255), 2) # 画出轮廓的外接矩阵 for contour in contours: rect = self.contour2Rect(contour) cv2.rectangle(img, (rect[0], rect[1]), (rect[2], rect[3]), (0, 0, 255), 2) cv2.imshow(\"Contour_result\", img) cv2.waitKey(timeMs) cv2.destroyAllWindows() def contour2Rect(self, contour): ''' 轮廓的信息转换为矩阵信息，以便后续处理 Arguments: contour：轮廓的信息：若干个点组成的轮廓 Return: rect：矩阵信息：左上角和右下角的坐标 ''' rect = [] x, y, w, h = cv2.boundingRect(contour) # 返回值为外接矩阵的顶点坐标和长宽 rect = [x, y, x + w, y + h] return rect &emsp;&emsp;该轮廓算法是将所有的轮廓都检测出来，但其中有些结果并不是我们所需要的，所以我们可以采用一些简单的判断条件进行筛选，比如轮廓的周长和轮廓矩形的长宽比等，并将其作为函数的参数以便实际比赛时候的调整。contour2Rect函数的作用是将轮廓的信息转换为矩阵的信息，showContourResult函数的作用是在原图中画出轮廓和矩阵。&emsp;&emsp;下面进行简单的测试，首选读取一张带有黄杆的图片，然后创建对象并调用预处理方法和轮廓检测方法，并将isShow的参数设置为True将其结果显示出来。 特征提取&emsp;&emsp;检测到目标后，下面就要对其进行特征的提取，从而获得分类器的输入向量。和之前候选区域的提取一样，将所有的特征提取方法封装成一个类，并统一返回向量(列表)的形式。 球类目标颜色特征&emsp;&emsp;首先对于足球和红球最容易想到的就是其颜色特征，之前初级版的设计只是简单的判断颜色所占比例，这并不是一个非常好的标准，因为受到光线等其他因素的影响，在图像中实际的颜色并非我们想象的那样，所以我们采用另一种判断标准。&emsp;&emsp;将每个通道的颜色区间分为若干份，即将[0, 255]区间分成若干个子区间，一般取16比较适中，然后分别统计每个通道的每个像素点属于哪一个子区间，最后统计每个子区间有多少个像素点。例如，R通道的第1个像素点的值为46，属于[32, 47]这个区间，则该区间就+1。这样一共有3*16=48个特征向量，3表示3个通道，16表示16个区间，当然也可以取其他值。 12345678910111213141516171819202122232425class ColorFeature(object): def __init__(self, img, number=16): self.img = img self.number = number assert type(self.number % 16) == int, \"number should be divided by 16.\" def splitChannal(self, img): # 分离通道 Channel1, Channel2, Channel3 = cv2.split(img) Channel1, Channel2, Channel3 = Channel1.flatten(), Channel2.flatten(), Channel3.flatten() Channels = [Channel1, Channel2, Channel3] return Channels def colorExtract(self, img): # 颜色提取 Channels = self.splitChannal(img) size = Channels[0].shape[0] colorVector = [] for Channel in Channels: Channel = Channel / self.number # 商即为分类类别 Channel = np.append(Channel, 15) colorVector.extend(np.round((1.0 * np.bincount(Channel) / size), 4)) # 统计个数，并计算概率 return colorVector &emsp;&emsp;首先通过opencv中的split()方法将图像分成3个通道，然后对每个通道进行颜色特征提取。Channel是一个列表，包含了该通道的每个像素点的值，将其除以总区间个数就可以知道属于第几个区间。例如刚才的像素值46，因为46/16=2，所以属于第2个区间(区间从0开始计)，也就是[32, 47]这个区间，即之前的像素点46转换为现在的区间类别2。然后在利用numpy中的bincount()统计方法计算每个区间有多少个像素，注意这里最好在Channel中添加一个元素15，因为图像中不一定存在第16个区间内的像素值，如果不存在，则特征向量的个数就会不同，影响后续的分类器训练，最后在除以总像素个数得到归一化的结果并保留4位小数。&emsp;&emsp;注：python3中需要用//。12345if __name__ == \"__main__\": img = cv2.imread(\"./img_3/1.jpg\") colorFeature = ColorFeature(img) colorVector = colorFeature.colorExtract(img) print(len(colorVector), colorVector) &emsp;&emsp;输出结果为：1(48, [0.0158, 0.0035, 0.0037, 0.0083, 0.0254, 0.1115, 0.226, 0.2418, 0.1169, 0.065, 0.0429, 0.0272, 0.0223, 0.026, 0.0227, 0.0411, 0.0186, 0.0036, 0.0065, 0.0177, 0.0486, 0.1404, 0.1927, 0.2202, 0.1531, 0.0649, 0.028, 0.0242, 0.0265, 0.0203, 0.0125, 0.0223, 0.0201, 0.0038, 0.0057, 0.0158, 0.0486, 0.1376, 0.1863, 0.2099, 0.172, 0.0964, 0.0419, 0.0261, 0.0145, 0.0107, 0.0067, 0.0039]) HOG特征&emsp;&emsp;HOG特征指的是梯度方向直方图，顾名思义，就是选用梯度方向的分布作为特征。一张图像的梯度（x和y方向的导数）在边缘和拐角（强度变化剧烈的区域）处的梯度幅值很大，而且边缘和拐角比其他平坦的区域包含更多关于物体形状的信息。&emsp;&emsp;首先需要将图像分成小的连通区域，称之为细胞单元。然后采集细胞单元中各像素点的梯度或边缘的方向直方图。最后把这些直方图组合起来就可以构成特征描述器。&emsp;&emsp;这里主要参考了以下两篇博客的：梯度方向直方图，80行Python实现-HOG梯度特征提取。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class HogFeature(): def __init__(self, img, cell_size=4, bin_size=8): self.img = img self.img = np.sqrt(img / float(np.max(img))) self.img = self.img * 255 self.cell_size = cell_size self.bin_size = bin_size self.angle_unit = 360 / self.bin_size assert type(self.bin_size) == int, \"bin_size should be integer,\" assert type(self.cell_size) == int, \"cell_size should be integer,\" assert type(self.angle_unit) == int, \"bin_size should be divisible by 360\" def hog_extract(self): height, width = self.img.shape gradient_magnitude, gradient_angle = self.global_gradient() gradient_magnitude = abs(gradient_magnitude) cell_gradient_vector = np.zeros((int(round(1.0 * height / self.cell_size)), int(round(1.0 * width / self.cell_size)), self.bin_size)) for i in range(cell_gradient_vector.shape[0]): for j in range(cell_gradient_vector.shape[1]): cell_magnitude = gradient_magnitude[i * self.cell_size:(i + 1) * self.cell_size, j * self.cell_size:(j + 1) * self.cell_size] cell_angle = gradient_angle[i * self.cell_size:(i + 1) * self.cell_size, j * self.cell_size:(j + 1) * self.cell_size] cell_gradient_vector[i][j] = self.cell_gradient(cell_magnitude, cell_angle) hog_image = self.render_gradient(np.zeros([height, width]), cell_gradient_vector) hog_vector = [] for i in range(cell_gradient_vector.shape[0] - 1): for j in range(cell_gradient_vector.shape[1] - 1): block_vector = [] block_vector.extend(cell_gradient_vector[i][j]) block_vector.extend(cell_gradient_vector[i][j + 1]) block_vector.extend(cell_gradient_vector[i + 1][j]) block_vector.extend(cell_gradient_vector[i + 1][j + 1]) mag = lambda vector: math.sqrt(sum(i ** 2 for i in vector)) magnitude = mag(block_vector) if magnitude != 0: normalize = lambda block_vector, magnitude: [element / magnitude for element in block_vector] block_vector = normalize(block_vector, magnitude) hog_vector.append(block_vector) return hog_vector, hog_image def global_gradient(self): gradient_values_x = cv2.Sobel(self.img, cv2.CV_64F, 1, 0, ksize=5) gradient_values_y = cv2.Sobel(self.img, cv2.CV_64F, 0, 1, ksize=5) gradient_magnitude = cv2.addWeighted(gradient_values_x, 0.5, gradient_values_y, 0.5, 0) gradient_angle = cv2.phase(gradient_values_x, gradient_values_y, angleInDegrees=True) return gradient_magnitude, gradient_angle def cell_gradient(self, cell_magnitude, cell_angle): orientation_centers = [0] * self.bin_size for i in range(cell_magnitude.shape[0]): for j in range(cell_magnitude.shape[1]): gradient_strength = cell_magnitude[i][j] gradient_angle = cell_angle[i][j] min_angle, max_angle, mod = self.get_closest_bins(gradient_angle) orientation_centers[min_angle] += (gradient_strength * (1 - (mod / self.angle_unit))) orientation_centers[max_angle] += (gradient_strength * (mod / self.angle_unit)) return orientation_centers def get_closest_bins(self, gradient_angle): idx = int(gradient_angle / self.angle_unit) mod = gradient_angle % self.angle_unit if idx == self.bin_size: return idx - 1, (idx) % self.bin_size, mod return idx, (idx + 1) % self.bin_size, mod def render_gradient(self, image, cell_gradient): cell_width = self.cell_size / 2 max_mag = np.array(cell_gradient).max() for x in range(cell_gradient.shape[0]): for y in range(cell_gradient.shape[1]): cell_grad = cell_gradient[x][y] cell_grad /= max_mag angle = 0 angle_gap = self.angle_unit for magnitude in cell_grad: angle_radian = math.radians(angle) x1 = int(x * self.cell_size + magnitude * cell_width * math.cos(angle_radian)) y1 = int(y * self.cell_size + magnitude * cell_width * math.sin(angle_radian)) x2 = int(x * self.cell_size - magnitude * cell_width * math.cos(angle_radian)) y2 = int(y * self.cell_size - magnitude * cell_width * math.sin(angle_radian)) cv2.line(image, (y1, x1), (y2, x2), int(255 * math.sqrt(magnitude))) angle += angle_gap return image &emsp;&emsp;首先在一幅图中选取若干像素组合成一个cell，例如8*8个像素，然后选取2*2个cell，即16*16个像素，组合成一个block。然后将0°-360°划分为若干个区间，比如8个区间，在这8个区间内，统计每个block中的每个cell中的梯度方向直方图(具体见博客)，所以一个block有4*8=32个特征向量(因为一个block有4个cell，1个cell有8个直方图特征)，然后按照step的大小在图像中移动block，通常step设置为一个cell的大小，即下次移动的时候会和之前的有重复。最后统计一幅图中有多少个block即可算出所有的特征向量个数。例如一个640*480的原始图，其横向有640/8-1=79个block，纵向有480/8-1=59个block,那么其特征向量一个有79*59=4661个，每一个都是一个32维的向量。 123456if __name__ == \"__main__\": img = cv2.imread(\"./img_3/1.jpg\") img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) hogFeature = HogFeature(img) hogVector, _ = hogFeature.hog_extract() print(np.array(hogVector).shape) &emsp;&emsp;输出结果为(4661, 32)。当然了，这是整幅图的特征向量，实际的特征提取中，只是针对候选区域的(不会太大)，所以我们可以将整个候选区域当作一个block，这样特征向量的个数就缩减为32个。 分类器&emsp;&emsp;有了特征向量后，我们就可以选择分类器来训练模型。 Logistic回归&emsp;&emsp;Logistic回归是一个简单的线性二分类的分类算法，其基本原理就是在每个特征上都乘以一个回归系数，然后把所有的结果相加，将这个总和代入到Sigmoid函数中，进而得到一个范围在0~1之间的数值，最后判断当大于0.5的时候就被分为1类，小于0.5就被分为0类。&emsp;&emsp;x即输入的特征向量，w即回归系数。下面的问题就是如何找到w的最优解。这里我们采用的优化算法是梯度上升法。其w的更新公式为：&emsp;&emsp;程序实现：123456789101112131415161718192021222324252627282930313233343536# coding uft-8import numpy as npimport mathclass Logistic(object): def __init__(self, filename, maxCycle): self.filename = filename self.maxCycle = maxCycle def loadDateSet(self): data = np.loadtxt(self.filename) dataMat = data[:, 0: -1] classLabels = data[:, -1] # dataMat = np.insert(dataMat, 0, 1, axis=1) return dataMat, classLabels def sigmoid(self, z): return 1 / (1 + np.exp(-z)) def gradDescent(self, dataMat, classLabels): dataMatrix = np.mat(dataMat) labelMat = np.mat(classLabels).transpose() m, n = np.shape(dataMatrix) weights = np.ones((n, 1)) alpha = 0.001 for i in range(self.maxCycle): h = self.sigmoid(dataMatrix * weights) error = labelMat - h weights = weights + alpha * dataMatrix.transpose() * error return np.round(weights, 4) def classifyVector(self, inX, weights): prob = self.sigmoid(sum(np.dot(inX, weights))) return prob 模型训练&emsp;&emsp;有了特征向量和分类器，我们就可以训练模型了。模型中分为正样本和负样本，其训练方法也是不同的。 球类目标正样本&emsp;&emsp;对于正样本来说，通常的做法是利用数据标注来获得候选区域。常用的数据标注软件有labelImg。该软件不用安装，且使用方法十分简单(自行百度下载)。&emsp;&emsp;打开软件后，首先选择Open Dir打开图像文件夹，然后选择Change Save Dir选择要保存的xml文件的文件路径（标注完成后会生成一个xml文件存放标注信息），然后点击Create RectBox创建矩形，&emsp;&emsp;在需要的区域拖拽鼠标即可，然后在弹出的对话框中选择类别的名称，最后点击save保存，并选择Next Image切换到下一张。&emsp;&emsp;下面就要从生成的xml文件中提取出我们需要的信息。1234567891011121314151617181920212223242526&lt;annotation&gt; &lt;folder&gt;img_2&lt;/folder&gt; &lt;filename&gt;0.jpg&lt;/filename&gt; &lt;path&gt;D:\\NAO\\visual_cxx\\img_2\\0.jpg&lt;/path&gt; &lt;source&gt; &lt;database&gt;Unknown&lt;/database&gt; &lt;/source&gt; &lt;size&gt; &lt;width&gt;640&lt;/width&gt; &lt;height&gt;480&lt;/height&gt; &lt;depth&gt;3&lt;/depth&gt; &lt;/size&gt; &lt;segmented&gt;0&lt;/segmented&gt; &lt;object&gt; &lt;name&gt;ball&lt;/name&gt; &lt;pose&gt;Unspecified&lt;/pose&gt; &lt;truncated&gt;0&lt;/truncated&gt; &lt;difficult&gt;0&lt;/difficult&gt; &lt;bndbox&gt; &lt;xmin&gt;47&lt;/xmin&gt; &lt;ymin&gt;315&lt;/ymin&gt; &lt;xmax&gt;189&lt;/xmax&gt; &lt;ymax&gt;454&lt;/ymax&gt; &lt;/bndbox&gt; &lt;/object&gt;&lt;/annotation&gt; &emsp;&emsp;这是其中的一个xml文件，可以看出我们想要的信息在object项中的第1个和第4个中，即name和bndbox中。利用python内置的ElementTree库就可以解析出我们想要的结果。1234567891011121314151617181920# coding uft-8import xml.etree.ElementTree as ETdef parseXml(xml_file): classes_num = &#123;\"ball\": 1, \"noball\": 0&#125; labels = [] tree = ET.parse(xml_file) root = tree.getroot() for item in root: if item.tag == \"object\": obj_name = item[0].text obj_num = classes_num[obj_name] xmin = int(item[4][0].text) ymin = int(item[4][1].text) xmax = int(item[4][2].text) ymax = int(item[4][3].text) labels.append([xmin, ymin, xmax, ymax, obj_num]) return labels &emsp;&emsp;返回的labels列表就包括了候选矩形区域的2个顶点坐标及类别。 &emsp;&emsp;接下来就是使用之前的特征提取和分类器进行离线训练，在训练之前，我们针对模型进行小小的改进。将整个候选区域分成若干份，比如分成4份，每份都执行同样的特征提取，这样既增加了特征向量的个数，也提高了模型的鲁棒性。&emsp;&emsp;候选区域一般为矩形，所以直接上下等分即可：1234567891011121314151617181920def reshapeBallRect(rawRect, numbers): n = int(math.sqrt(numbers)) + 1 newPoint = np.zeros((n, n, 2)) newRect = np.zeros((n - 1, n - 1, 4)) initX, initY, endX, endY = rawRect[0], rawRect[1], rawRect[2], rawRect[3] # 初始化参数 # 找出每个小矩阵的顶点坐标 for i in range(n): for j in range(n): newPoint[i][j][0] = int(initX + ((endX - initX) / (n - 1) * j)) newPoint[i][j][1] = int(initY + ((endY - initY) / (n - 1) * i)) # 根据坐标构造新矩阵 for i in range(n - 1): for j in range(n - 1): newInitX, newInitY = int(newPoint[0 + i][0 + j][0]), int(newPoint[0 + i][0 + j][1]) newEndX, newEndY = int(newPoint[1 + i][1 + j][0]), int(newPoint[1 + i][1 + j][1]) newRect[i][j][0], newRect[i][j][1], newRect[i][j][2], newRect[i][j][3] = newInitX, newInitY, newEndX, newEndY return newRect &emsp;&emsp;针对球类目标，我们选择颜色和HOG特征提取：123456789101112131415def calColorFeature(img, number=16): # 计算颜色特征 color = ColorFeature(img, number) result = color.colorExtract(img) return np.round(result, 4)def calHOGFeature(img, cell_size): # 计算HOG特征 rectBallArea = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) hog = HogFeature(rectBallArea, cell_size) vector, image = hog.hog_extract() return np.round(vector[0], 4) &emsp;&emsp;最后统一保留4位小数。 &emsp;&emsp;然后就是采集大量的正样本图片(越多越好，至少上百张)，最后将这些特征向量全部合并到一个列表中，并保存到txt文件里，以便后续分类器的处理。1234567891011121314151617181920212223242526272829303132def calPosVector(writeFilename, labelNumbers): with open(writeFilename, 'w') as f: for i in range(labelNumbers): print('test ' + str(i)) resultTotal = [] xmlFile = \"./label_2/\" + str(i) + \".xml\" labels = parseXml(xmlFile) img = cv2.imread(\"./img_2/\" + str(i) + \".jpg\") initX, initY, endX, endY = labels[0][0], labels[0][1], labels[0][2], labels[0][3] Rect = [initX, initY, endX, endY] newRects = reshapeHoughRect(Rect, 4) for newRectRow in newRects: for newRect in newRectRow: newInitX, newInitY = int(newRect[0]), int(newRect[1]) newEndX, newEndY = int(newRect[2]), int(newRect[3]) rectBallArea = img[newInitY:newEndY, newInitX:newEndX, :] # 矩形区域(宽，高，通道) cv2.rectangle(img, (newInitX, newInitY), (newEndX, newEndY), (0, 0, 255), 2) # 画矩形 resultColor = calColorFeature(rectBallArea, 16) cellSize = min(newEndX - newInitX, newEndY - newInitY) result_HOG = calHOGFeature(rectBallArea, cellSize / 2) resultTotal.extend(resultColor) resultTotal.extend(result_HOG) print('resultTotal', len(resultTotal)) cv2.imshow(\"Original\", img) cv2.waitKey(0) row = ' '.join(list(map(str, resultTotal))) + ' ' + str(labels[0][4]) + '\\n' f.write(row) &emsp;&emsp;首先从标注文件xml中获得lables信息，然后依次打开正样本图片，并根据信息获得其中的候选区域，再对其4等分处理，对每一个等分矩阵进行颜色和HOG特征的提取，注意此时的HOG特征中的block区域为整个等分矩阵区域，所以其cell_size大小的选取应为长宽中的最小值的一半。（cell_size一般为block的一半）。所以单个等分矩阵的HOG特征的特征向量一共有4*8=32个，颜色特征的特征向量个数为16*3=48个，即总的候选区域的特征向量个数为80*4=320个。&emsp;&emsp;单张图片的实验结果，特征向量太多了，这里就不显示了。 负样本&emsp;&emsp;而对于负样本的训练，就不能采用标注的方法了，而是直接调用之前的霍夫圆检测算法检测原图，当然了，原图不应该包含我们的球类目标，而且二值化的阈值范围要放大一点，以防止检测不出足球/红球。这里我们直接只使用灰度化处理，不进行二值化处理。其算法检测出来多少个圆就当作多少个负样本，最后在对其特征向量的提取并存放在txt文件中，以便后续的分类器训练。123456789101112131415161718192021222324252627282930313233def calNegVector(writeFilename, labelNumbers): with open(writeFilename, 'w') as f: for i in range(labelNumbers): print('test ' + str(i)) srcImg = cv2.imread(\"./img_3/\" + str(i) + \".jpg\") hogDec = HoughDetection(srcImg) preImg = cv2.cvtColor(srcImg, cv2.COLOR_BGR2GRAY) circles = hogDec.houghDetection(preImg, minDist=100, minRadius=25, maxRadius=80) for circle in circles: resultTotal = [] rect = hogDec.circle2Rect(circle) if rect[0] &lt; 0 or rect[1] &lt; 0 or rect[2] &gt; 640 or rect[3] &gt; 480: continue newRects = reshapeHoughRect(rect, 4) for newRectRow in newRects: for newRect in newRectRow: newInitX, newInitY = int(newRect[0]), int(newRect[1]) newEndX, newEndY = int(newRect[2]), int(newRect[3]) rectBallArea = srcImg[newInitY:newEndY, newInitX:newEndX, :] # 矩形区域(宽，高，通道) cv2.rectangle(srcImg, (newInitX, newInitY), (newEndX, newEndY), (0, 0, 255), 2) # 画矩形 resultColor = calColorFeature(rectBallArea, 16) cellSize = min(newEndX - newInitX, newEndY - newInitY) result_HOG = calHOGFeature(rectBallArea, cellSize / 2) resultTotal.extend(resultColor) resultTotal.extend(result_HOG) print('resultTotal', len(resultTotal)) cv2.imshow(\"Original\", srcImg) cv2.waitKey(0) row = ' '.join(list(map(str, resultTotal))) + ' ' + str(0) + '\\n' f.write(row) &emsp;&emsp;最后一行的label标签需要更改为0。 结果测试&emsp;&emsp;有了正负样本的特征向量后，就可以放入到分类器里面去训练参数了，这里将所有的特征向量都合并到一个txt文件里面。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960def resultTest(method): trainingSet = [] trainingLabels = [] with open(\"data.txt\", 'r') as f: for line in f.readlines(): currLine = line.strip().split() lineArr = [] for i in range(320): lineArr.append(float(currLine[i])) trainingSet.append(lineArr) trainingLabels.append(float(currLine[320])) if method == \"Logistic\": log = Logistic(\"data.txt\", 500) trainingWeights = log.gradDescent(trainingSet, trainingLabels) numbers = 39 for i in range(numbers): print(\"test\" + str(i)) srcImg = cv2.imread(\"./images/\" + str(i) + \".jpg\") conDet = ContoursDetection(srcImg) preImg = conDet.preProcess(srcImg, \"football\") rects = conDet.contoursDetection(preImg, minPerimeter=200, minK=0) if rects == []: print(\"test\" + str(i) + \" no rects\") for rect in rects: resultTotal = [] rect = conDet.contour2Rect(rect) if rect[0] &lt; 0 or rect[1] &lt; 0 or rect[2] &gt; 640 or rect[3] &gt; 480: print(\"out of bound\") continue newRects = reshapeHoughRect(rect, 4) for newRectRow in newRects: for newRect in newRectRow: newInitX, newInitY = int(newRect[0]), int(newRect[1]) newEndX, newEndY = int(newRect[2]), int(newRect[3]) rectBallArea = srcImg[newInitY:newEndY, newInitX:newEndX, :] resultColor = calColorFeature(rectBallArea, 16) cellSize = min(newEndX - newInitX, newEndY - newInitY) resultHOG = calHOGFeature(rectBallArea, cellSize / 2) resultTotal.extend(resultColor) resultTotal.extend(resultHOG) resultTotal = np.array(resultTotal).reshape(1, -1) classify = log.classifyVector(resultTotal, trainingWeights) if classify &gt; 0.5: classifyResult = \"yes\" cv2.rectangle(srcImg, (rect[0], rect[1]), (rect[2], rect[3]), (0, 0, 255), 2) else: classifyResult = \"no\" cv2.rectangle(srcImg, (rect[0], rect[1]), (rect[2], rect[3]), (0, 255, 255), 2) print('classify', classifyResult) cv2.imshow(\"test \" + str(i), srcImg) cv2.waitKey(0) &emsp;&emsp;首先打开特征向量的文本文件，将所有的特征向量和标签分布放到2个列表中，然后放到分类器里面得到权重参数，然后对每一张图片进行目标检测，并获得该目标区域的特征向量，在放到分类器里面得到预测的结果，最后如果概率大于0.5，则认为是，否则为不是。&emsp;&emsp;下图为其中一张的测试结果：&emsp;&emsp;其中红色为正确的目标，黄色为错误的目标。实际测试下来，几乎可以达到实时检测，正确率也达到了比赛的标准。 黄杆类目标&emsp;&emsp;黄杆类目标的模型训练和球类目标基本上一致，重复性的工作这里就不再叙述，读者可以自行考虑代码设计。&emsp;&emsp;这里同样对模型进行一点改进，由于黄杆是细条型的矩形框，所以不能采用之前的均分方法。这里采用一种新的等分方法：首先找到黄杆的矩形框，然后将其左右延申，将landmark标记也框在矩形框内，然后为了克服随机性，将矩形框上下延申至图像的顶部和底部，最后再将其四等分。如图所示：123456789101112def reshapeStickRect(rawRect, numbers): newRect = np.zeros((numbers, 4)) initX, initY, endX, endY = rawRect[0], rawRect[1], rawRect[2], rawRect[3] # 初始化参数 # 找出每个小矩阵的顶点坐标 for i in range(numbers): newRect[i][0] = initX newRect[i][1] = initY + ((endY - initY) / numbers) * i newRect[i][2] = endX newRect[i][3] = initY + ((endY - initY) / numbers) * (i + 1) return newRect &emsp;&emsp;特征向量的提取和之前的球类目标类似，这样总的特征向量仍然为320个。 总结&emsp;&emsp;高级版的设计其实也就是传统的目标检测方法，一般分为三个阶段：首先在给定的图像上选择一些候选的区域，然后对这些区域提取特征，最后使用训练的分类器进行分类。&emsp;&emsp;随着技术的发展，现在目标检测的普遍做法是利用深度学习来训练模型，得到的分类器更具体一般性，效果也更好。这里就不再过多的叙述了，以后有机会也会发布深度学习版的NAO比赛目标检测。","categories":[{"name":"NAO高尔夫比赛","slug":"NAO高尔夫比赛","permalink":"http://cxx0822.github.io/categories/NAO高尔夫比赛/"}],"tags":[]},{"title":"python高级编程","slug":"python高级编程","date":"2019-04-25T13:56:20.000Z","updated":"2022-03-21T06:19:12.672Z","comments":true,"path":"2019/04/25/python-gao-ji-bian-cheng/","link":"","permalink":"http://cxx0822.github.io/2019/04/25/python-gao-ji-bian-cheng/","excerpt":"","text":"推导式&emsp;&emsp;推导式comprehensions（又称解析式），是Python的一种独有特性。推导式是可以从一个数据序列构建另一个新的数据序列的结构体。 列表推导式1[expression for item in iterable if condition] &emsp;&emsp;例：1num = [num + 1 for num in range(0, 5) if num % 2 == 1] &emsp;&emsp;程序输出：1[2, 4] 字典推导式1&#123;key_expression:value_expression for expression in iterable if condition&#125; &emsp;&emsp;例：12A = &#123;\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4&#125;A = &#123;v: k for k, v in A.items()&#125; &emsp;&emsp;程序输出：1&#123;1: 'a', 2: 'b', 3: 'c', 4: 'd'&#125; &emsp;&emsp;例：12A = [\"apple\", \"orange\", \"banana\", \"pear\"]A = &#123;key: value for key, value in enumerate(A) if value == \"apple\"&#125;&#125; &emsp;&emsp;程序输出：1&#123;0: 'apple'&#125; 集合推导式1&#123;expression for expression in iterable if condition&#125; &emsp;&emsp;例：12A = [\"apple\", \"orange\", \"banana\", \"pear\"]A = &#123;len(s) for s in A&#125; &emsp;&emsp;程序输出：1[5, 6, 6, 4] 可迭代对象定义&emsp;&emsp;可迭代对象：实现了__iter__()方法的对象都是可迭代对象。如果没有实现__iter__而实现了__getitem__方法，并且其参数是从零开始的索引，这种对象，如序列，也是可迭代的。&emsp;&emsp;迭代器：实现了__iter__和__next__()方法的对象都是迭代器。&emsp;&emsp;由定义可知，除了内置的序列和字典之外，我们还可以自己定义可迭代对象。 iter()&emsp;&emsp;该方法返回的是当前对象的迭代器类的实例。因为可迭代对象与迭代器都要实现这个方法，因此有以下两种写法。 用于可迭代对象类的写法，返回该可迭代对象的迭代器类的实例。 用于迭代器类的写法，直接返回self（即自己本身），表示自身即是自己的迭代器。 next()&emsp;&emsp;表示获取迭代器对象中下一个值。 创建可迭代对象1234567891011121314151617181920212223from collections import Iterable # 自定义可迭代对象class MyList(object): def __init__(self): # 定义一个空列表，保存用户添加的数据 self.my_list = list() # 在列表中添加元素 def append_data(self, data): self.my_list.append(data) # 在类里面提供__iter__方法,使该对象是可迭代对象 def __iter__(self): pass # 通过自定义可迭代类型创建自定义可迭代对象my_iterable = MyList() # 查看my_iterable是不是指定类型：Iterableresult = isinstance(my_iterable, Iterable)print(result) &emsp;&emsp;在创建的类中，由于定义了__iter__()方法，即使该方法为空，但已经满足了可迭代对象的定义，所以用isinstance()检测是否为可迭代对象时，输出的结果为true。&emsp;&emsp;可迭代对象的本质是通过迭代器帮助可迭代对象依次迭代对象中的每一个数据，所以真正完成获取数据的操作是通过迭代器完成的。 创建迭代器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyList(object): def __init__(self): self.my_list = list() def append_data(self, data): self.my_list.append(data) # 使用__iter__()的第一种写法 def __iter__(self): my_iterator = MyIterator(self.my_list) return my_iterator # 自定义迭代器类class MyIterator(object): def __init__(self, current_list): # 保存外界传入过来的数据对象 self.current_list = current_list # 记录获取数据的下标 self.current_index = 0 # 使用__iter__()的第二种写法 def __iter__(self): return self # 使用__next__方法获取指定对象中的数据 def __next__(self): # 判断下标是否越界 if self.current_index &lt; len(self.current_list): # 根据下标获取数据对象中的指定数据 value = self.current_list[self.current_index] # 获取数据成功对下标加上1 self.current_index += 1 return value else: # 代码执行到此说明下标越界，停止取值操作，抛出停止迭代异常 raise StopIterationif __name__ == \"__main__\": # 通过自定义可迭代类创建出自定义可迭代对象，添加数据 my_iterable = MyList() my_iterable.append_data(1) my_iterable.append_data(2) for value in my_iterable: print(value, end=',') &emsp;&emsp;输出结果为：1,2。迭代器的标配就是__iter__和__next__方法，每个迭代器都有，这种方法是自从它被创建出来的时候就有。真正的迭代是由__next__来执行的，也就是__next__每次从迭代器中取出一个元素来操作，直到所有的元素被取完。&emsp;&emsp;当然也可以用python内置的迭代器函数生成迭代器。iter()函数表示获取可迭代对象的迭代器，会调用可迭代对象身上的__iter__方法，next()函数表示获取迭代器对象中下一个值，会调用迭代器对象身上的__next__方法。例：1234567891011if __name__ == \"__main__\": # 创建迭代器对象 it = iter([1, 2, 3, 4, 5]) while True: try: # 获得下一个值: x = next(it) print(x, end=',') except StopIteration: # 遇到StopIteration就退出循环 break &emsp;&emsp;输出结果为：1,2,3,4,5。首先使用iter()使列表成为迭代器（列表是可迭代对象，但不是迭代器），然后一直调用next()函数不停地获取迭代器里面的值。注意，一定要加异常处理，因为一旦获取不到迭代器里面的值就会报错。 迭代器应用&emsp;&emsp;使用迭代器生成斐波那契数列。123456789101112131415161718192021222324252627282930# 迭代器完成斐波那契数列class Fibonacci(object): def __init__(self, num): # num:表示根据个数生成数列 self.num = num # 保存斐波那契数列前两个值 self.first = 0 self.second = 1 # 记录生成斐波那契数列的下标 self.current_index = 0 def __iter__(self): return self def __next__(self): if self.current_index &lt; self.num: result = self.first self.first, self.second = self.second, self.first + self.second # 生成数据完成以后对下标加上1 self.current_index += 1 return result else: # 表示数列生成完成 raise StopIterationif __name__ == \"__main__\": # 创建生成斐波那契数列的对象 fib = Fibonacci(5) for i in fib: print(i, end=',') &emsp;&emsp;输出结果为0,1,1,2,3,。使用迭代器可以节省空间，没有上限控制。迭代器不会把每次生成的值保存起来，只会根据你的算法生成一个值。即可以用多少创建多少，而且可以无限创建。 创建生成器&emsp;&emsp;生成器属于轻装版的迭代器，但生成器仍然是迭代器，不过是改进的。可以实现一边循环一边计算。1234567891011121314151617# 生成器完成斐波那契数列def fibonacci(num): # num：表示生成器根据个数创建指定个数的fibonacci数列 first = 0 second = 1 current_index = 0 # 循环判断条件是否成立，表示是否生成斐波那契数列 while current_index &lt; num: result = first first, second = second, first + second current_index += 1 yield resultif __name__ == \"__main__\": generator = fibonacci(5) for a in generator: print(a, end=',') &emsp;&emsp;输出结果为0,1,1,2,3,。生成器函数的定义方式和普通函数几乎一样，只不过它有一个yield语句。当函数执行到yield的时候，该函数被挂起，等待下次被next()激活。带有yield的函数不再是一个普通函数，而是一个生成器generator, yield相当于return返回一个值，并且记住这个返回的位置，下次迭代时，代码从yield的下一条语句开始执行。&emsp;&emsp;生成器相比较迭代器，更加简洁，且功能完全相同，相当于内置了next()函数。","categories":[{"name":"Python","slug":"Python","permalink":"http://cxx0822.github.io/categories/Python/"}],"tags":[]},{"title":"NAO比赛视觉系统设计（python初级版）","slug":"NAO比赛视觉系统设计（python初级版）","date":"2019-03-20T10:12:26.000Z","updated":"2022-03-31T12:00:48.989Z","comments":true,"path":"2019/03/20/nao-bi-sai-shi-jue-xi-tong-she-ji-python-chu-ji-ban/","link":"","permalink":"http://cxx0822.github.io/2019/03/20/nao-bi-sai-shi-jue-xi-tong-she-ji-python-chu-ji-ban/","excerpt":"","text":"概述&emsp;&emsp;初级版的内容主要分为两部分，第一部分是如何利用NAO的视觉传感器，即上下摄像头，来获取图片及如何利用opencv显示获得的图片。第二部分是如何利用opencv里面的视觉算法从NAO获取的图片中找到所需目标，并返回需要的目标信息。 视觉系统框架设计&emsp;&emsp;首先要搭建好视觉系统的程序框架，python是一种面向对象的编程语言，而面向对象最重要的特征就是类的封装，所以我们可以将整个视觉系统分为若干类，每个类实现相应的功能。 ConfigureNAO类12345678910111213141516from naoqi import ALProxyclass ConfigureNao(object): def __init__(self, IP=\"169.254.67.213\", PORT=9559): self.IP = IP self.PORT = PORT self.cameraProxy = ALProxy(\"ALVideoDevice\", self.IP, self.PORT) self.landMarkProxy = ALProxy(\"ALLandMarkDetection\", self.IP, self.PORT) self.motionProxy = ALProxy(\"ALMotion\", self.IP, self.PORT) self.postureProxy = ALProxy(\"ALRobotPosture\", self.IP, self.PORT) self.tts = ALProxy(\"ALTextToSpeech\", self.IP, self.PORT) self.memoryProxy = ALProxy(\"ALMemory\", self.IP, self.PORT) &emsp;&emsp;首先定义NAO机器人的IP和端口号，并将此作为类的参数，其次声明一些常用的类，如视觉、运动、姿势和存储类等。只有实例化后的类才可以使用。 VisualBasis类123456789101112131415161718192021222324252627282930313233# coding: utf-8from configureNao import ConfigureNaofrom naoqi import ALProxyimport numpy as npimport almath import mathimport timeimport sysimport osimport cv2import cv2.cv as cvimport vision_definitions as vdclass VisualBasis(ConfigureNao): def __init__(self, IP, PORT, cameraID=vd.kBottomCamera, resolution=vd.kVGA): super(VisualBasis, self).__init__(IP, PORT) self.cameraID = cameraID self.resolution = resolution self.colorSpace = vd.kBGRColorSpace self.fps = 20 self.frameHeight = 320 self.frameWidth = 640 self.frameChannels = 0 self.frameArray = None self.cameraPitchRange = 47.64 / 180 * np.pi self.cameraYawRange = 60.97 / 180 * np.pi &emsp;&emsp;这里使用了naoqi系统的宏定义vision_definitions，为了书写方便，将其简写为vd，其中这里使用了摄像头ID的宏定义：vd.kBottomCamera(下摄像头)和vd.kTopCamera(上摄像头)、分辨率宏定义vd.kVGA和颜色空间宏定义vd.kBGRColorSpace。(具体含义见下文分析)。另外将图像本身(frameArray)及其高度、宽度、通道，摄像头的俯仰角作为类的属性，以便后续方法的调用。&emsp;&emsp;因为NAO读取球目标和黄杆目标分别使用的是上面和下面的摄像头，所以将摄像头ID作为类的参数以便后续调整。基类的第二个参数为分辨率，方便后续图像的清晰度调整。IP和PORT是为了继承父类所需的参数。 获取图片12345678910111213141516171819def updateFrame(self): if self.cameraProxy.getActiveCamera() != self.cameraID: self.cameraProxy.setActiveCamera(self.cameraID) videoClient = self.cameraProxy.subscribe(\"cxx\", self.resolution, self.colorSpace, self.fps) frame = self.cameraProxy.getImageRemote(videoClient) self.cameraProxy.unsubscribe(videoClient) self.frameWidth = frame[0] self.frameHeight = frame[1] self.frameChannels = frame[2] self.frameArray = np.frombuffer(frame[6], dtype=np.uint8).reshape([frame[1], frame[0], frame[2]]) # frombuffer将data以流的形式读入转化成ndarray对象, 第一参数为stream,第二参数为返回值的数据类型 # frame[6]: binary array of size height * width * nblayers containing image data. if self.frameArray is None: print(\"no frame find\") return np.array([]) return self.frameArray &emsp;&emsp;让NAO读取一张图片大致可以分为3个步骤。1.激活摄像头。2.订阅。3.读取图像。&emsp;&emsp;调用setActiveCamera()函数即可激活摄像头，其次就是调用subscribe()函数订阅该摄像头，该函数的函数头为std::string ALVideoDeviceProxy::subscribe(const std::string&amp; Name, const int&amp; resolution, const int&amp; colorSpace, const int&amp; fps)，一共需要4个参数。第1个为订阅者的名字，随便写一个字符串即可，第2个是分辨率，NAO最高支持1280*960的分辨率，但是越高的分辨率意味着越大的数据量，所以我们选择的是640*480的分辨率，其宏定义为vd.kVGA，第3个参数为颜色空间，这里选择的是一般的BGR空间，其宏定义为vd.kBGRColorSpace，最后一个为帧数，这里选择20即可。&emsp;&emsp;订阅完之后，就可以调用getImageRemote()函数来获得图像了。其参数为之前的订阅者，返回值为图像的容器，具体内容如下：&emsp;&emsp;其中0-5都是图像的基本信息，即宽、高、通道、颜色空间和时间戳。第6个索引值存放的内容就是我们需要的图像信息，使用numpy里面的reshape()函数将其简单的处理成我们需要的宽*高*通道类型的数组。&emsp;&emsp;最后使用unsubscribe()取消订阅以释放内存即可。 显示图片12345678def showFrame(self, frameArray, timeMs=1000, isSave=False): if frameArray is None: print(\"please get an image from Nao with the method updateFrame()\") else: cv2.imshow(\"current frame\", frameArray) cv2.waitKey(timeMs) if isSave is True: cv2.imwrite(\"test.jpg\", frameArray) &emsp;&emsp;opencv中常用的显示图片的函数为imshow()，该函数需要传入2个参数，即显示图像窗口的名称和图像内容。然后调用waitKey()函数延迟显示一段时间，单位为ms。最后提供了一个是否保存的参数接口，以便后续需要保存获得的图像。 FootBallDetect&emsp;&emsp;针对足球和红球，主要的流程为检测-&gt;筛选-&gt;定位。首先对NAO获得的图像进行检测，从而获得足球/红球或类似的目标，其次对其进行简单的判断筛选，以确保是我们需要的目标，最后进行定位，返回需要的目标信息。 初始化12345678class FootBallDetect(VisualBasis): def __init__(self, IP, PORT, cameraID=vd.kBottomCamera, resolution=vd.kVGA): super(FootBallDetect, self).__init__(IP, PORT, cameraID, resolution) self.ballData = &#123;\"centerX\": 0, \"centerY\": 0, \"radius\": 0&#125; self.ballPosition = [0, 0, 0] self.minDist = 100 # int(self._frameHeight/30.0) self.minRadius = 25 self.maxRadius = 80 # int(self._frameHeight/10.0) &emsp;&emsp;首先将足球的基本信息和位置信息作为类的属性，然后将霍夫圆检测算法(具体见下文分析)中的参数也作为类的属性。 检测1234567891011def findCirclesV0(self, img, minDist=100, minRadius=25, maxRadius=80): grayImg = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) circles = cv2.HoughCircles(grayImg, cv.CV_HOUGH_GRADIENT, 1, minDist, param1=100, param2=20, minRadius=minRadius, maxRadius=maxRadius) if circles is None: circles = [] print(\"no circle\") else: circles = circles[0, ] return circles &emsp;&emsp;初级版采用的检测球的算法是霍夫变换圆检测算法，该算法比较简单，而且opencv有现成的函数，直接调用即可。函数头为：1cv2.HoughCircles(image, method, dp, minDist, circles, param1, param2, minRadius, maxRadius) &emsp;&emsp;image：输入图像，必须为灰度图像，这里使用opencv中的cvtColor()函数将其从BGR转为GRAY即可。method为检测方法，常用的是霍夫梯度法HOUGH_GRADIENT（opencv2的写法为：cv2.cv.CV_HOUGH_GRADIENT）。dp为检测内侧圆心的累加器图像的分辨率于输入图像之比的倒数，如dp=1，累加器和输入图像具有相同的分辨率，如果dp=2，累计器便有输入图像一半那么大的宽度和高度（取1即可）。minDist表示两个圆之间圆心的最小距离。param1是method设置的检测方法的对应的参数，对于霍夫梯度法，它表示传递给canny边缘检测算子的高阈值，而低阈值为高阈值的一半。param2是method设置的检测方法的对应的参数，对于霍夫梯度法，它表示在检测阶段圆心的累加器阈值，它越小，就越可以检测到更多根本不存在的圆，而它越大的话，能通过检测的圆就更加接近完美的圆形了。minRadius表示圆半径的最小值，maxRadius表示圆半径的最大值。&emsp;&emsp;由上述分析可知，霍夫圆检测算法的参数十分重要，如果设置的不合理，很难达到预期的要求。 筛选&emsp;&emsp;将球检测出来后，下一步就是进行筛选并找到我们需要的球。初级版采用的策略是颜色概率法。如下图所示：&emsp;&emsp;检测出圆形后，外接一个正方形，其边长d为2(k*r)，r为圆的半径，k为比例。这样就可以通过各个颜色出现的概率判断是否是绿地毯上的红球或足球（黑白球）。&emsp;&emsp;opencv中有两种常用的颜色通道空间：HSV空间和BGR空间。实际测试下来发现HSV空间比较稳定。 12345678910111213141516171819202122232425262728293031323334353637383940def selectCircleV0(self, circles): img = self.frameArray.copy() HSV = cv2.cvtColor(self.frameArray, cv2.COLOR_BGR2HSV) circleSelected = [] BWRatiomin = 1.0 k = 1.5 for circle in circles: centerX, centerY, radius = circle[0], circle[1], circle[2] initX, initY = int(centerX - int(k * radius)), int(centerY - int(k * radius)) endX, endY = int(centerX + int(k * radius)), int(centerY + int(k * radius)) if initX &lt; 0 or initY &lt; 0 or endX &gt; img.shape[1] or endY &gt; img.shape[0] or radius &lt; 1: continue rectBallArea = HSV[initY:endY, initX:endX, :] HFlat, SFlat, VFlat = rectBallArea[:, :, 0].flatten(), rectBallArea[:, :, 1].flatten(), rectBallArea[:, :, 2].flatten() size = HFlat.shape[0] onesArray = np.ones((size,)) # 参考HSV颜色分布表 GScoreHL = np.uint8(35 * onesArray &lt;= HFlat) GScoreHR = np.uint8(HFlat &lt;= 77 * onesArray) GScoreSL = np.uint8(43 * onesArray &lt;= SFlat) GScoreVL = np.uint8(46 * onesArray &lt;= VFlat) GScore = float(np.sum(GScoreHL * GScoreHR * GScoreSL * GScoreVL)) WScoreSR = np.uint8(SFlat &lt;= 35 * onesArray) WScoreVL = np.uint8(221 * onesArray &lt;= VFlat) WScore = float(np.sum(WScoreSR * WScoreVL)) BScoreVR = np.uint8(VFlat &lt;= 46 * onesArray) BScore = float(np.sum(BScoreVR)) GRatio, BRatio, WRatio = GScore * 1.0 / size, BScore * 1.0 / size, WScore * 1.0 / size WhiteBlackRatio = BScore * 1.0 / size + WScore * 1.0 / size if WhiteBlackRatio &gt; 0.1 and np.abs(WhiteBlackRatio - 0.34) &lt; BWRatiomin and GRatio &gt; 0.1: BWRatiomin = np.abs(WhiteBlackRatio - 0.34) circleSelected = circle circleSelected = np.array(circleSelected) return circleSelected &emsp;&emsp;首先将图像空间转换为HSV空间，然后对于检测出来的圆利用for循环依次遍历筛选。对于每个圆，首先根据比例k和圆心、半径求出矩形的左上角和右下角，对于超出图像边界的矩形框不予讨论，其次将HSV空间根据通道索引将其分解成3个部分，然后将每个部分根据HSV空间颜色分布表求出每个部分的颜色得分，全部设置为1，然后求和，算出每个颜色的总得分，然后除以总数，即可得到概率，最后根据概率即可判断是否是我们需要的目标。 &emsp;&emsp;可以利用opencv的circle()函数将结果显示出来：123456def drawCircle(self, img, circle): x, y, r = int(circle[0]), int(circle[1]), int(circle[2]) cv2.circle(img, (x, y), r, (0, 0, 255), 2) cv2.imshow(\"result\", img) cv2.waitKey(0) cv2.destroyAllWindows() &emsp;&emsp;下面进行一个简单的测试，将之前的函数综合调用一下，并画出检测的结果。1234567891011if __name__ == \"__main__\": footBallDet = FootBallDetect(\"192.168.1.101\", 9559) footBallDet.postureProxy.goToPosture(\"StandInit\", 0.5) img = footBallDet.updateFrame() circles = footBallDet.findCirclesV0(img) if circles == []: print(\"no ball\") else: circleSelected = footBallDet.selectCircleV0(circles) footBallDet.drawCircle(img, circleSelected) &emsp;&emsp;结果显示在图中可以大致框出足球范围。 定位&emsp;&emsp;灰色矩形区域是摄像头拍摄的图像区域，其中图像原点位于矩形的左上角，坐标轴方向如图所示。蓝点表示摄像头，红点表示球的位置。摄像头的pitch（张角）和yaw（仰角）的正方向如图所示。红线表示摄像头的张角范围（左右视角范围），紫线表示仰角范围（上下视角范围）。球的位置坐标为(x,y)。&emsp;&emsp;如果球正好位于图像的中心位置(320,240)，那么摄像头-球-机器人双脚中心正好可以构成一个平面的直角三角形，如下图所示：&emsp;&emsp;摄像头离地面的 &emsp;&emsp;注：初级版只是为了NAO足球比赛的，完整的NAO比赛视觉系统设计参见高级版的博客。","categories":[{"name":"NAO高尔夫比赛","slug":"NAO高尔夫比赛","permalink":"http://cxx0822.github.io/categories/NAO高尔夫比赛/"}],"tags":[]},{"title":"C++重难点：重载与模板","slug":"C++重难点：重载与模板","date":"2019-03-15T01:51:24.000Z","updated":"2022-03-21T06:19:12.441Z","comments":true,"path":"2019/03/15/c-chong-nan-dian-chong-zai-yu-mo-ban/","link":"","permalink":"http://cxx0822.github.io/2019/03/15/c-chong-nan-dian-chong-zai-yu-mo-ban/","excerpt":"","text":"&emsp;&emsp;在之前的C语言编程中，一个函数实现一个功能，但有时候我们需要实现几个功能类似的函数，只是有些细节不同，如果按照C语言的编程方式，我们需要重新定义函数，这会使得代码十分不美观。但在C++中，我们可以使用重载或模板很好的解决这个问题。 函数重载定义&emsp;&emsp;在同一作用域类中，一组函数名相同，参数列表（函数特征标）不同（参数个数不同/参数类型不同/参数排列顺序不同），返回值可同可不同的函数。&emsp;&emsp;重载函数通常用来命名一组功能相似的函数，这样做减少了函数名的数量，对于程序的可读性有很大的好处。 示例&emsp;&emsp;先看一个简单的加法函数重载：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int fun(int, int);int fun(int *, int *);int fun(int a, int b)&#123; cout &lt;&lt; \"int a + int b : \"; return a + b;&#125;int fun(int * a, int * b)&#123; cout &lt;&lt; \"int *a + int *b : \"; return *a + *b;&#125;int main(void)&#123; int a1 = 1, b1 = 2; int a2 = 2, b2 = 3; int *p = &amp;a2, *q = &amp;b2; cout &lt;&lt; fun(a1, b1) &lt;&lt; endl; cout &lt;&lt; fun(p, q) &lt;&lt; endl; return 0;&#125; &emsp;&emsp;定义了2个fun函数，其参数类型分别为int和int *类型，返回值都是int类型，为了更好的说明，在每个函数中都加入输出提示。最终输出结果为： 12int a int b : 3int *a + int *b : 5 &emsp;&emsp;这个例子很好理解，但如果此时在定义一个double类型变量，并调用fun函数，会显示什么？如下所示： 12double a3 = 1.2, b3 = 2.9;cout &lt;&lt; fun(a3, b3) &lt;&lt; endl; 输出结果： 1int a int b: 3 &emsp;&emsp;为什么此时没有报错呢？明明没有定义参数列表是double类型的fun函数。如果再定义个fun函数的重载，将参数类型设置为int &amp;，即引用参数，如下所示： 123456int fun(int &amp;, int &amp;);int fun(int &amp; a, int &amp; b)&#123; cout &lt;&lt; \"&amp; a + &amp; b : \"; return a + b;&#125; &emsp;&emsp;此时再调用刚才的cout &lt;&lt; fun(a1, b1) &lt;&lt; endl;程序会报错：error C2668: “fun”: 对重载函数的调用不明确。这又有什么会报错呢？见下文解析。 原理如何解决命名冲突&emsp;&emsp;编译器在编译当前作用域里的同名函数时，会根据函数形参的类型和顺序会对函数进行重命名（不同的编译器在编译时对函数的重命名标准不一样）。在visual studio编译器中，根据返回值类型（不起决定性作用）+形参类型和顺序（起决定性作用）的规则重命名并记录在map文件中。&emsp;&emsp;右击工程名，然后选择属性，在依次选择配置属性-&gt;链接器–&gt;调试，将其中的生成映射文件和映射导出都设置为是，映射文件名为生成的map文件名，可以自己命名也可以用默认的。点击确定，并运行程序后，会在工程文件夹中的Debug文件夹下生成一个.map的文件夹，将其拖拽至编译器内即可打开。 &emsp;&emsp;从图中可以看到，虽然函数名相同，但在map中的生成的名称去不一样。？表示名称开始，？后边是函数名，@@YA表示参数表开始，后边的3个字符分别表示返回值类型，参数类型。@Z表示名称结束。由上述分析可知，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。 如何解决调用匹配&emsp;&emsp;除了利用函数重载可以实现相同的函数名实现不同的功能，函数模板同样的也可以实现。为了更好的解释其中的调用匹配问题，在讲完函数模板后，再重新解释（刚才提到的问题属于调度匹配问题）。 作用及意义&emsp;&emsp;函数重载是属于多态中的静态多态，即在编译时的多态，而虚函数与虚继承属于动态多态，即在运行时的多态，其两者都是为了减少函数名的数量，避免名字空间的污染，提高程序的可读性。 模板定义&emsp;&emsp;模板也是一种C++支持参数化多态的工具，使用模板可以为类或函数声明一种一般模式，使得类中的某些数据成员、成员函数的参数、返回值取得任意类型。&emsp;&emsp;模板通常有两种形式：函数模板和类模板，函数模板针对仅参数类型不同的函数；类模板针对仅数据成员和成员函数类型不同的类。（本博客只讨论函数模板。）&emsp;&emsp;模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。 函数模板&emsp;&emsp;函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的类型(如int或double)替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型(而不是具体类型)的方式编写程序，因此有时也被称为通用编程。由于类型是用参数表示的，因此模板特性有时也被称为参数化类型。 示例&emsp;&emsp;先看一个简单的函数模板定义：12345678910111213141516#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;T fun(T a, T b)&#123; return a * b;&#125;int main(void)&#123; int a1 = 1, b1 = 2; cout &lt;&lt; fun(a1, b1) &lt;&lt; endl; return 0;&#125; &emsp;&emsp;程序输出：2&emsp;&emsp;函数模板的一般定义格式如下：template &lt;typename T&gt;返回值 函数名(T 参数){}，其中typename可以替换为class。&emsp;&emsp;函数模板有两种类型的参数，第一种是模板参数，位于函数模板名称的前面，在一对尖括号内部进行声明；第二种是调用参数，位于函数模板名称之后，在一对圆括号内部进行声明。&emsp;&emsp;如果可以由调用参数来决定模板参数，则模板函数调用是不需要指明模板参数，但如果不能则必须指明，例如以下情况：12double a2 = 1.2, b2 = 2.3;cout &lt;&lt; fun(a1, b2) &lt;&lt; endl; &emsp;&emsp;此时再调用的话，就会报错：C2782 “double fun(T,T)”: 模板 参数“T”不明确，因为此时变量a1和b2不是同一个类型，而函数模板定义中并没有说明这一点，所以正确的定义和调用应该如下所示：1234567891011121314151617#include &lt;iostream&gt;using namespace std;template &lt;typename T1, typename T2, typename T3&gt;T3 fun(T1 a, T2 b)&#123; return a * b;&#125;int main(void)&#123; int a1 = 1, b1 = 2; double a2 = 1.2, b2 = 2.3; cout &lt;&lt; fun&lt;int, double, double&gt;(a1, b2) &lt;&lt; endl; return 0;&#125; &emsp;&emsp;总之，调用和定义时的类型必须保持一致，当编译器无法判断时，需要显示地指明参数类型。&emsp;&emsp;当然模板也是可以重载的，比如再定义一个可以将2个数组中的各个元素相乘的函数。1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;template &lt;typename T1, typename T2&gt;void fun(T1 a, T2 b)&#123; cout &lt;&lt; a * b &lt;&lt; endl;&#125;template &lt;typename T1, typename T2&gt;void fun(T1 *a, T2 *b, int n)&#123; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] * b[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl;&#125;int main(void)&#123; int a1 = 1, b1 = 2; double a2 = 1.2, b2 = 2.3; double a3[2] = &#123; 1.2, 2.3 &#125;, b3[2] = &#123; 2.3, 3.4 &#125;; fun&lt;int, double&gt;(a1, b2); fun&lt;double, double&gt;(a3, b3, 2); return 0;&#125; &emsp;&emsp;程序输出结果为：122.32.76 7.82 &emsp;&emsp;那么面对如此多的相同名字的函数，编译器到底是如何选择的呢？","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://cxx0822.github.io/categories/C-学习/"}],"tags":[]},{"title":"C++重难点：友元","slug":"C++重难点：友元","date":"2019-03-12T01:09:44.000Z","updated":"2022-03-21T06:19:12.440Z","comments":true,"path":"2019/03/12/c-chong-nan-dian-you-yuan/","link":"","permalink":"http://cxx0822.github.io/2019/03/12/c-chong-nan-dian-you-yuan/","excerpt":"","text":"&emsp;&emsp;C++由于其封装的特性，通常使用类对数据进行了隐藏和封装，类的数据成员一般都定义为私有成员。虽然在有些时候这对类中的数据是一种很好的保护措施，但是有时候也需要定义一些函数或类来访问类中的非公有成员，比如运算符重载或两个类不是继承关系，但需要共享数据的时候，这时通常我们令其他类或函数成为它的友元来解决这类问题。 友元概念&emsp;&emsp;友元机制允许一个类将对其非公有成员的访问权授予指定的函数或者类，友元的声明以friend开始，它只能出现在类定义的内部，友元声明可以出现在类中的任何地方：友元不是授予友元关系的那个类的成员（友元不属于该类），所以它们不受其声明出现部分的访问控制影响（可以是公有，也可以是私有）。通常，友元声明成组地放在类定义的开始或结尾。 友元分类&emsp;&emsp;C++中一共有3种友元，即友元函数，友元类和友元成员函数。 友元函数概念&emsp;&emsp;友元函数是指虽然不是类成员函数却能够访问类的所有成员的函数。本身是一个类外的普通函数，但函数的声明只能在类的内部，定义在类的外部。&emsp;&emsp;格式：friend 类型 函数名(形参); 实现123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class A&#123;public: friend void fun(A &amp;a); //友元函数声明 private: int data;&#125;;void fun(A &amp;a) //友元函数定义&#123; a.data = 0; cout &lt;&lt; a.data &lt;&lt; endl;&#125;int main()&#123; class A a; fun(a); return 0;&#125; &emsp;&emsp;程序结果：10 注意 友元函数的声明可以放在类的私有部分，也可以放在公有部分，它们是没有区别的，都说明是该类的一个友元函数。 一个函数可以是多个类的友元函数，只需要在各个类中分别声明。 友元函数的调用与一般函数的调用方式和原理一致。 友元函数能定义在类的内部，这样的函数是隐式内联的。 友元类概念&emsp;&emsp;如果希望一个类可以访问另一个类的非公有成员在内的所有成员，可以将一个类指定为另一类的友元类。友元类的所有成员函数都是另一个类的友元函数。&emsp;&emsp;格式：friend class 类名; 实现1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class A&#123;public: friend class B; //友元类声明 private: int data;&#125;;class B &#123;public: void fun(A &amp;a) &#123; a.data = 0; cout &lt;&lt; a.data &lt;&lt; endl; &#125;&#125;;int main(void)&#123; class A a; class B b; b.fun(a); return 0;&#125; &emsp;&emsp;程序结果：10 注意 友元关系不能被继承，就像父亲的朋友未必是儿子的朋友。 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。 友元成员函数概念&emsp;&emsp;有时候我们仅需要将特定的类成员函数成为另一个类的友元，而不是整个类。我们可以这样做：使类B中的特定成员函数成为类A的友元函数，这样类B的该成员函数就可以访问类A的所有成员了。&emsp;&emsp;但是这样做会比较麻烦，必须要排列好各种声明和定义的顺序。&emsp;&emsp;比如在上例的友元类中，将类B中的函数fun定义为A的友元成员函数：friend void B::fun(A &amp;a) {a.data = 0; cout &lt;&lt; a.data &lt;&lt; endl;}。但是编译器在处理这条语句时，必须要知道类B的定义，否则无法判断B是一个类，所以需要将B的定义放在A的前面。但B中的fun函数方法又提到了A对象，所以A的定义应该在B的前面，这样就陷入了循环中，为此需要利用前向声明来避免这种问题。所以最终的排序顺序如下：123class A; //前向声明class B &#123;...&#125;;class A &#123;...&#125;; &emsp;&emsp;但此时又会出现另外一个问题，即B中的fun函数是内联函数，用到了A中的数据，但A的定义在后面，所以通常将fun的声明放在前面，fun的定义使用外部定义的方法放在后面。 实现&emsp;&emsp;最终的实现如下：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class A; //前向声明class B &#123;public: void fun(A &amp;a) ;&#125;;class A&#123;public: friend void B::fun(A &amp;a); //友元成员函数声明 private: int data;&#125;;void B::fun(A &amp;a) //友元函数的定义 &#123; a.data = 0; cout &lt;&lt; a.data &lt;&lt; endl; &#125;int main(void)&#123; class A a; class B b; b.fun(a); return 0;&#125; &emsp;&emsp;程序结果：10 小结优点： 可以灵活地实现需要访问若干类的私有或受保护的成员才能完成的任务； 便于与其他不支持类概念的语言(如C语言、汇编等)进行混合编程； 通过使用友元函数重载可以更自然地使用C++语言的IO流库。 缺点： 一个类将对其非公有成员的访问权限授予其他函数或者类，会破坏该类的封装性，降低该类的可靠性和可维护性。","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://cxx0822.github.io/categories/C-学习/"}],"tags":[]},{"title":"C++重难点：虚函数与虚继承","slug":"C++重难点：虚函数与虚继承","date":"2019-03-07T00:49:19.000Z","updated":"2022-03-21T06:19:12.441Z","comments":true,"path":"2019/03/07/c-chong-nan-dian-xu-han-shu-yu-xu-ji-cheng/","link":"","permalink":"http://cxx0822.github.io/2019/03/07/c-chong-nan-dian-xu-han-shu-yu-xu-ji-cheng/","excerpt":"","text":"&emsp;&emsp;C++是一种面向对象的编程语言，其主要的特点是封装、继承和多态。其中继承指的是可以将一个类作为基类，并将另一个类继承于它，作为它的派生类。但在多重继承或存在一些复杂的继承关系时，可能会出现一些二义性，通常我们可以用虚函数与虚继承来避免这些问题。 虚函数&emsp;&emsp;在某基类中声明为virtual并在一个或多个派生类中被重新定义的成员函数称为虚函数。主要用于多继承时，由于成员函数名称相同，调用出现二义性的问题。&emsp;&emsp;声明格式：virtual 函数返回类型 函数名(参数表){函数体}; 问题出现&emsp;&emsp;假设现在有1个基类，2个派生类都继承该基类，且每个类中都有1个名称相同的成员函数。如：123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;class A&#123;public: void fun1() &#123;cout &lt;&lt; \"A::fun1\" &lt;&lt; endl;&#125;&#125;;class B :public A&#123;public: void fun1() &#123;cout &lt;&lt; \"B::fun1\" &lt;&lt; endl;&#125;&#125;;class C :public A&#123;public: void fun1() &#123;cout &lt;&lt; \"C::fun1\" &lt;&lt; endl;&#125;&#125;; &emsp;&emsp;A是基类，B，C是派生类，都继承于A类，且都有1个函数名为fun1的函数，如果我们使用各自的类类型实例化各自的对象，则调用fun1函数完全没问题，如：12345678910int main()&#123; A a1; B *b1 = new B; C c1; a1.fun1(); b1-&gt;fun1(); c1.fun1(); return 0;&#125; &emsp;&emsp;程序输出为：123A::fun1B::fun1C::fun1 &emsp;&emsp;但当我们想用基类A去声明2个派生类B，C的对象时（B，C都是继承于A，当然可以用基类去声明派生类），如：12345678int main()&#123; A *a2 = new B; a2-&gt;fun1(); A *a3 = new C; a3-&gt;fun1(); cout &lt;&lt; endl;&#125; &emsp;&emsp;此时，我们预期的结果是输出B::fun1 C::fun1但实际输出的结果是A::fun1 A::fun1。这就是因为3个类中的fun1函数名都相同，出现了二义性，都调用了基类的fun1函数。 解决办法&emsp;&emsp;解决的办法就是在基类中的fun1成员函数最前面的修饰符中加上虚函数的关键字virtual（当然派生类的成员函数前面也可以加上），这样fun1就是一个虚函数，类在调用的时候则会根据实际情况调用。如：1234567891011virtual void fun1() &#123;cout &lt;&lt; \"A::fun1\" &lt;&lt; endl;&#125;int main()&#123; A *a2 = new B; a2-&gt;fun1(); A *a3 = new C; a3-&gt;fun1(); cout &lt;&lt; endl; return 0;&#125; &emsp;&emsp;程序输出为：12B::fun1C::fun1 应用场景&emsp;&emsp;当然，我们可能会觉得这样不是更复杂么？直接声明各自的对象不就可以了么？如果是那样的话，C++就体现不会多态的特性了。比如，我们声明一个对象数组，该数组中的每个元素都是一个对象，但是数组的数据格式必须统一，不能既是A的对象又是B的对象，那这样我们就不能调用各自类中的函数，那么也就体现不出C++多态的特性了。&emsp;&emsp;但我们可以这样做，声明一个指向基类A的对象数组，即数组里面都是指向A类的指针，然后通过加入虚函数特性，这样在调用各自的成员函数时，就不会出现二义性问题，数组的数据格式也是一样的。这也反映了多态的思想。如：12345678910int main()&#123; A *a[2]; a[0] = new B; a[1] = new C; a[0]-&gt;fun1(); a[1]-&gt;fun1(); return 0;&#125; &emsp;&emsp;程序结果：12B::fun1C::fun1 基本原理——动态联编&emsp;&emsp;由于C++的函数可以重载，再加上指针和引用，使得程序在调用函数时，特别是多个重名的函数时，使用哪个可执行的代码块是一个非常复杂的问题。&emsp;&emsp;将源代码中的函数调用解释为执行特定的函数代码块称为函数名联编。C++一共有2种方式，一种是静态联编，即编译器可以在编译过程中完成联编，另一种是动态联编，即由于编译器不知道该选择哪种类型的对象，必须生成能够在程序运行时选择正确的虚方法的代码。&emsp;&emsp;动态联编主要与指针和引用的调用方法有关。C++不允许将一种类型的地址赋值给另一种类型的指针，比如12double x = 1.2;int *p = &amp;x; long &amp;r = x; &emsp;&emsp;但是指向基类的引用或指针可以引用派生类对象，虽然基类和派生类并不是同一种数据类型（类也是一种数据类型，即用户自定义数据类型），但派生类是由基类继承而来，所以这种引用被称为向上强制转换。但向下是不可以的。&emsp;&emsp; 向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编，C++使用虚成员函数来满足这种要求。 &emsp;&emsp;例如在上例中，如果fun1函数没有声明为虚的，当利用指针创建A *a2 = new B;和A *a3 = new C;对象并调用fun1()函数时，a2和a3将根据指针类型A *来调用A::fun1()，指针类型在编译时已知，因此编译器对非虚方法使用静态联编。&emsp;&emsp;但是，当fun1函数声明为虚函数时，a2和a3将根据对象类型来确定，其中a2为B类，a3为C类，由此可见，编译器生成的代码是在程序执行时才根据对象类型将fun1关联到B::fun1()或C::fun1()，所以编译器对虚方法使用的是动态联编。 &emsp;&emsp;在大多数情况下，动态联编很好，因为程序能够选择为特定类型设计的方法，但是静态联编的效率更高，因为动态联编需要额外的内存开销（见深层原理分析），所以一般我们可以这样设计：如果要在派生类中重新定义基类的方法，则将它设置为虚方法，否则设置为非虚方法。 深层原理——虚函数表&emsp;&emsp;编译器处理虚函数的方法是：给每个对象添加一个隐藏成员，该隐藏成员中保存了一个指向函数地址数组的指针，这种数组称为虚函数表。虚函数表中存储了为类对象进行声明的虚函数的地址。&emsp;&emsp;虚函数表的变化：如下图所示，类A是基类，类B是派生类，每个对象都有1个针对虚函数的虚函数表，其中基类A有2个虚函数，地址分别为4064和6400，类B有3个虚函数，其中第一个虚函数是继承于基类A的并且未重新定义，则类B的虚函数表直接将基类A对应的虚函数地址复制下来；第二个虚函数也是继承于基类A的，但是已经重新定义了，则会产生一个新的虚函数地址；第三个虚函数是类B本身的，所以该虚函数地址也是新的。&emsp;&emsp;每个类只有1个虚函数表，每次只需要在表中添加1个地址，只是表的大小不同而已。&emsp;&emsp;当调用虚函数，首先会找到该虚函数表（该表也是有地址的），然后在表中找到相应的函数地址，最后根据地址调用函数。所以这也就是为什么虚函数需要额外的开销。因为首先要占用一定的存储空间来存放虚函数地址表，其次根据在表中寻找合适的函数地址也需要一定的运行时间。 注意事项 构造函数构造函数不能是虚函数。因为在创建派类对象时，将调用派生类的构造函数，而不是基类的构造函数。 析构函数析构函数应该是虚函数，除非不用做基类。 12A *p = new B;delete p; &emsp;&emsp;在上例中，当delete对象时，如果不是虚函数，将调用基类A的析构函数，这将释放基类指向的内存，但不会释放派生类的内存，但如是虚函数，则会先释放派生类的内存，在释放基类的内存。所以通常给基类提供一个虚析构函数。 友元友元不能是虚函数，因为友元不是类成员，只有成员才能是虚函数。 虚继承&emsp;&emsp;在继承定义中包含了virtual关键字的继承关系被称为虚继承，在虚继承体系中的通过virtual继承而来的基类被称为虚基类。主要用于多重继承(如菱形继承)时，函数不知归属于哪个类的问题。&emsp;&emsp;声明格式：class 派生类类名： virtual [继承方式] 基类类名。 问题出现&emsp;&emsp;假设现在有一种复杂的多重继承方式，如有1个基类A，2个派生类B，C都继承于基类A，派生类D又继承于B和C。如下图所示：12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;class A&#123;public: void fun1() &#123;cout &lt;&lt; \"A::fun1\" &lt;&lt; endl;&#125;&#125;;class B :public A&#123;&#125;;class C :public A&#123;&#125;;class D :public B, public C&#123;&#125;; &emsp;&emsp;当我们利用派生类D去声明一个对象，并调用fun1函数时，会出现问题。123456int main()&#123; D d; d.fun1(); return 0;&#125; &emsp;&emsp;程序会报错，即error C2385: 对“fun1”的访问不明确，因为派生类B和C都继承于A，所以派生类D中会有2份fun1函数，这样编译器就不知道该选择哪个函数了。 解决办法&emsp;&emsp;有一种解决办法就是将fun1函数在派生类D重写或者调用时指明用哪个类的fun1，如D.B::fun1();，但这种并不是最好的解决办法，因为这样会有2个副本，占用额外的内存空间。&emsp;&emsp;还有一种比较好的解决办法是将继承方式声明为虚继承。12345678910111213141516171819class A&#123;public: void fun1() &#123;cout &lt;&lt; \"A::fun1\" &lt;&lt; endl;&#125;&#125;;class B :virtual public A&#123;&#125;;class C :virtual public A&#123;&#125;;class D :public B, public C&#123;&#125;; &emsp;&emsp;public和virtual的位置无所谓。这样的话，继承关系不变，但它们只会保留一个副本(这个副本既不来自于B，也不来自于C，是从A中单独拷贝出来的)，在调用的时候也不会产生错误。 实现原理&emsp;&emsp;为了更好的分析其实现原理，我们可以调用visual studio的内存布局管理。&emsp;&emsp;在解决方案管理器中选择.cpp文件，然后右击选择属性，在打开的窗口中选择命令行，然后在其他选项中输入查看内存布局的命令：12/d1 reportSingleClassLayout[className] //查看单个类/d1 reportAllClassLayout //查看所有类 &emsp;&emsp;确认后，按下F7即可查看内存布局情况。1234567891011121314151617181920212223class A&#123;public: int a;&#125;; class B : public A&#123;public: int b;&#125;; class C : public A&#123;public: int c;&#125;; class D : public B, public C&#123;public: int d;&#125;; &emsp;&emsp;B，C声明为普通继承时，D的内存布局：&emsp;&emsp;左边的数字表示类中成员在类中排列的起始地址。由图易知，类D一共有20个字节，1个int占4个，一共有5个，为什么有5个int？因为类A的int a在类B和类C中都复制了一份，所以在调用的时候当然不知道该调用哪一个了。&emsp;&emsp;我们再将B，C声明为虚继承，查看D的内存布局：&emsp;&emsp;可以看出，和之前的内存分布还是很不一样的，现在大概分成了3块，两块是B和C的数据加上一个vbptr的指针，该指针是虚基类表指针，指向一个虚表（和上文提到的虚函数表类似），表的内容在下面有显示，第二项表示vbptr到共有基类元素之间的偏移量，比如类B中的vbptr指向了虚表D::$vbtable@B@，可以看出，公共基类A的成员变量a距离类B开始处的位移为20（为什么一个是20一个是12查了很多资料也没搞明白，还望有会的大佬留言指教），这样根据这个虚表就可以找到基类中的数据了。&emsp;&emsp;还有一块是基类A中的数据，这也就是为什么利用虚继承只会出现一个副本。 纯虚函数&emsp;&emsp;除了虚函数和虚继承，关于virtual关键字还有一种用法：纯虚函数。一般用于声明一个函数但不实现它，让派生类去实现。&emsp;&emsp;声明格式：virtual 函数返回类型 函数名(参数表)=0;&emsp;&emsp;至少有1个虚函数是纯虚函数的基类称为抽象类。抽象类不可实例化，相当于一个接口。1234567891011121314#include &lt;iostream&gt;using namespace std;class A&#123;public: virtual void fun1() = 0;&#125;;int main()&#123; A a; return 0;&#125; &emsp;&emsp;程序会报错：error C2259: “A”: 不能实例化抽象类。 实例1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class A&#123;public: virtual void fun1() = 0;&#125;;class B :virtual public A&#123;public: void fun1() &#123;cout &lt;&lt; \"B::fun1()\" &lt;&lt; endl;&#125;&#125;;class C :virtual public A&#123;public: void fun1() &#123;cout &lt;&lt; \"C::fun1()\" &lt;&lt; endl;&#125;&#125;;int main()&#123; B b; C *c = new C; b.fun1(); c-&gt;fun1(); return 0;&#125; &emsp;&emsp;程序结果： B::fun1() C::fun1() 总结&emsp;&emsp;从一个大佬的博客上拷贝下来的，有些地方仍然不是太理解(学无止境啊)。 虚基类1. 一个类可以在一个类族中既被用作虚基类，也被用作非虚基类。 2.在派生类的对象中，同名的虚基类只产生一个虚基类子对象，而某个非虚基类产生各自的子对象。 3.虚基类子对象是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的。 4.最派生类是指在继承结构中建立对象时所指定的类。 5.派生类的构造函数的成员初始化列表中必须列出对虚基类构造函数的调用；如果未列出，则表示使用该虚基类的缺省构造函数。 6.从虚基类直接或间接派生的派生类中的构造函数的成员初始化列表中都要列出对虚基类构造函数的调用。但只有用于建立对象的最派生 类的构造函数调用虚基类的构造函数，而该派生类的所有基类中列出的对虚基类的构造函数的调用在执行中被忽略，从而保证对虚基类子对象 只初始化一次。 7.在一个成员初始化列表中同时出现对虚基类和非虚基类构造函数的调用时，虚基类的构造函数先于非虚基类的构造函数执行。 虚函数1.虚函数是非静态的、非内联的成员函数，而不能是友元函数，但虚函数可以在另一个类中被声明为友元函数。 2.虚函数声明只能出现在类定义的函数原型声明中，而不能在成员函数的函数体实现的时候声明。 3.一个虚函数无论被公有继承多少次，它仍然保持其虚函数的特性。 4.若类中一个成员函数被说明为虚函数，则该成员函数在派生类中可能有不同的实现。当使用该成员函数操作指针或引用所标识的对象时 ，对该成员函数调用可采用动态联编。 5.定义了虚函数后，程序中声明的指向基类的指针就可以指向其派生类。在执行过程中，该函数可以不断改变它所指向的对象，调用不同 版本的成员函数，而且这些动作都是在运行时动态实现的。虚函数充分体现了面向对象程序设计的动态多态性。 纯虚函数 版本的成员函数，而且这些动作都是在运行时动态实现的。虚函数充分体现了面向对象程序设计的动态多态性。 纯虚函数1.当在基类中不能为虚函数给出一个有意义的实现时，可以将其声明为纯虚函数，其实现留待派生类完成。 2.纯虚函数的作用是为派生类提供一个一致的接口。 3.纯虚函数不能实化化，但可以声明指针。","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://cxx0822.github.io/categories/C-学习/"}],"tags":[]},{"title":"Linux的文件与目录","slug":"Linux的文件与目录","date":"2019-03-05T09:02:56.000Z","updated":"2022-03-21T06:19:12.449Z","comments":true,"path":"2019/03/05/linux-de-wen-jian-yu-mu-lu/","link":"","permalink":"http://cxx0822.github.io/2019/03/05/linux-de-wen-jian-yu-mu-lu/","excerpt":"","text":"&emsp;&emsp;在Linux系统中，所有的软件和硬件都是以文件的形式存在的。 文件&emsp;&emsp;在Linux中的每一个文件或目录都包含有访问权限，这些访问权限决定了谁能访问和如何访问这些文件和目录。 用户与用户组&emsp;&emsp;Linux是一个多用户、多任务的环境，一般将用户分为3个类别：owner，group和others，每个类别各有read，write和execute等权限。此外，还有1个超级用户root，可以访问任何类别的任何文件。&emsp;&emsp;一般身份和root的相关信息记录在/etc/passwd文件内，个人的密码记录在/etc/shadow文件内，组名的信息记录在etc/group文件内。&emsp;&emsp;切换用户命令：su [-] ownername。不加-表示只能获得执行权限，加了表示获得环境变量及执行权限。ownername默认为root。普通用户切换到root需要密码，root切换到普通用户不需要密码，root输入exit可以退出root。注：如果进入root权限时显示su:Authentication failure则是因为之前没有设置过root的密码，输入命令sudo passwd并按照提示即可设置密码。 文件属性（图）输入命令查看文件 &emsp;&emsp;第一列：文件的类型和权限&emsp;&emsp;第一列一共有10个字符，第1个字符表示的是文件是目录或文件。| d | - | l | b | c || :———: | :———: | :———: | :———: | :———: ||目录|文件|链接文件|可供存储的接口设备|串行端口设备|&emsp;&emsp;接下来的9个字符，3个为1组，一共有3组，分别为r(可读)，w(可写)和x(可执行)权限，如果没有权限则用-表示。3组分别为文件所有者的权限，同用户组的权限和其他非本用户组的权限。&emsp;&emsp;read：可以读取文件的内容，write：可以编辑、增加或修改文件的内容（但不能删除），execute：可以被系统执行。 &emsp;&emsp;第二列：有多少个文件名连接到此节点&emsp;&emsp;第三列：所有者账号&emsp;&emsp;第四列：所属用户组&emsp;&emsp;第五列：容量大小，单位为B&emsp;&emsp;第六列：创建日期或最近的修改日期&emsp;&emsp;第七列：文件名 改变文件属性与权限&emsp;&emsp;常用的有3个命名：chgrp，chown和chmod。 chgrp&emsp;&emsp;命令格式：chgrp groupame dirname/filename chown&emsp;&emsp;命令格式：chgrp ownerame dirname/filename chmod&emsp;&emsp;设置权限的方式有两种，分别是数字和符号，比较常用的是数字设置。其中read是4，write是2，execute是1。每个类别的权限为这3种权限的和。例有一个文件的权限为rwxrwx---，则owner的数字为：4+2+1=7，group的数字为：4+2+1=7，others的数字为0+0+0=0，总的数字为774。命令格式为：chmod xyz dirname/filename。（xyz为各个类别的数字。） 文件种类&emsp;&emsp;常见的Linux文件类型有：普通文件、目录、连接文件、设备文件、套接字(sockets,s)和管道(pipe,p)。文件类型可以在文件属性的第一个字符中查到。 普通文件(-)&emsp;&emsp;普通文件又可以分为纯文本文件、二进制文件和数据格式文件。 目录(directory,d)连接文件(link,l)&emsp;&emsp;类似于Windows系统的快捷方式。 设备与设备文件(device)&emsp;&emsp;与系统外设及存储等相关的文件，集中在/dev目录下。又分为两种，一种是块设备文件(block,b)，如硬盘，软盘等，另一种是字符设备(character,c)，如键盘，鼠标等。","categories":[{"name":"Linux系统","slug":"Linux系统","permalink":"http://cxx0822.github.io/categories/Linux系统/"}],"tags":[]},{"title":"基于Ubuntu系统的NAO开发01：安装系统并配置python环境","slug":"基于Ubuntu系统的NAO开发01：安装系统并配置python环境","date":"2019-02-26T05:14:15.000Z","updated":"2022-03-21T06:19:12.787Z","comments":true,"path":"2019/02/26/ji-yu-ubuntu-xi-tong-de-nao-kai-fa-01-an-zhuang-xi-tong-bing-pei-zhi-python-huan-jing/","link":"","permalink":"http://cxx0822.github.io/2019/02/26/ji-yu-ubuntu-xi-tong-de-nao-kai-fa-01-an-zhuang-xi-tong-bing-pei-zhi-python-huan-jing/","excerpt":"","text":"安装Ubuntu系统&emsp;&emsp;Ubuntu是基于linux的免费开源桌面PC操作系统。本博客是在Windows10系统基础上，安装Ubuntu双系统，为了配合NAO机器人的使用，选择安装Ubuntu14.04版本。 制作系统盘&emsp;&emsp;首先准备一个空u盘（格式化后的）制作系统盘。可以选择UltraISO软件制作，制作过程也十分简单。先下载Ubuntu14.04的镜像文件(选择桌面版desktop-amd64)。&emsp;&emsp;然后打开UltraISO软件，选择文件-&gt;打开，选择下载好的镜像文件，然后选择启动-&gt;写入硬盘镜像，最后在弹出的对话框中依次选择格式化、写入即可。&emsp;&emsp;注：如果安装系统时出现failed to load ldlinux.c32错误，将写入方式改为RAW，重新写入即可。 硬盘分区&emsp;&emsp;建议先分区，再安装双系统。利用Win10自带的磁盘管理功能分区。&emsp;&emsp;右击电脑，选择管理-&gt;磁盘管理，选择任意一个空间较大的盘符，比如选择D盘符，然后右击选择压缩卷，输入压缩空间量即可实现硬盘的分区。比如从D盘分100G的空间给Ubuntu，则输入1000*1024MB = 102400MB即可。&emsp;&emsp;压缩完后不要进行任何操作，以便安装Ubuntu系统的时候可以直接找到该空间。 正式安装Ubuntu系统&emsp;&emsp;在安装前，先检查一下BIOS是否关闭安全启动（禁止安装其他没有经过微软验证的系统）：在BIOS中找到Security-&gt;Secure Boot，选择Disabled。&emsp;&emsp;然后插入制作好的系统盘，重启电脑并选择u盘启动，即可进入Ubuntu的安装界面。&emsp;&emsp;在启动界面中选择第一个Try Ubuntu without installing或第二个Install Ubuntu。&emsp;&emsp;语言环境建议选择英文，方面后面的文件路径处理。&emsp;&emsp;这个可以勾选也可以不勾选，安装完系统后再装也行。&emsp;&emsp;这一步是最重要的分区界面，建议选择最后一个自定义分区。&emsp;&emsp;进入后可以看到整个硬盘的空间分布，在Linux系统中，所有的软件和硬件都是以文件的形式存在的，硬盘也是文件，在根目录下的dev文件夹下，其中SCSI/SATA/USB硬盘都是以sd+序号开头的，如图可以看到并没有C,D,E,F盘的概念，只有sd1-sd6。其中白色区域的free space就是刚才压缩的盘符。（这里为50G。）在列表中找到该区域，左下角会出现+按钮，点击即可进行分区。 Ubuntu分区：对于整个linux系统来说，至少要有两个分区，一个是/分区，就是根分区，一个是swap分区，就是交换分区。 根分区/根目录：是所有目录的绝对路径的起始点，Ubuntu 中的所有文件和目录都在跟目录下。相当于Windows的C盘（假设只有1个盘）。 Swap分区：在系统的物理内存不够用的时候，把硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。相当于Windows的虚拟内存。&emsp;&emsp;在Red Hat Enterprise Linux中建议的Swap分区大小。 物理内存 Swap分区 &lt;=4 GB 至少4 G 4~16 GB 至少8 G 16~64 GB 至少16 G 64~256 GB 至少32 G &emsp;&emsp;但一般不建议只分2个区，Linux系统没有盘符的概念，所有的东西都存储在根目录下面的文件夹中，如果只有2个区，则相当于Windows系统中只有C盘，没有program files，documents and settings这种文件夹，这样用户数据和Windows都在一个分区里，这是十分危险的。所以在Ubuntu系统中，至少要划出/分区，/home分区和swap三个分区。其中/home分区就是存放用户数据和应用程序设置的文件夹，相当于Windows下的documents and settings文件夹。重新安装系统，会格式化/分区，这样/home分区的内容就可以保留了。&emsp;&emsp;一般只需划分这3个分区即可，其余默认即可。&emsp;&emsp;以下是我的分区方案，也可以自己选择。 分区名称 含义 / 根目录，是所有目录的绝对路径的起始点，Ubuntu 中的所有文件和目录都在跟目录下 /etc 此目录非常重要，绝大多数系统和相关服务的配置文件都保存在这里，这个目录的内容一般只能由管理员进行修改。像密码文件、设置网卡信息、环境变量的设置等都在此目录中 /home 系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~test表示用户test的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据 /bin 此目录中放置了所有用户能够执行的命令 /sbin 此目录中放置了一般是只有系统管理有才能执行的命令 /dev 存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount/dev/cdrom/mnt /mnt 此目录主要是作为挂载点使用 /usr 此目录包含了所有的命令、说明文件、程序库等，此目录下有很多重要的目录，常见的有：/usr/local 这个目录包含管理员自己安装的程序；/usr/share 包含文件的帮助文件；/usr/bin 和/usr/sbin 包含了所有的命令 /var 包含了日志文件、计划性任务和邮件等内容 /lib 包含了系统的函数库文件 /lost+found 包含了系统修复时的回复文件 /tmp 包含了临时的文件。一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下 /boot 系统的内核所在地，也是启动分区。放置linux系统启动时用到的一些文件。/boot/vmlinuz为linux的内核文件，以及/boot/gurb /media 主要用于挂载多媒体设备 /root 系统管理员的宿主目录 更新系统&emsp;&emsp;Ubuntu系统安装完成后，通常还需要进行换源、更新等操作。所谓换源就是将系统默认的软件下载地址(Ubuntu默认的在国外的服务器)换成国内的下载地址。更新就是类似于windows下面的系统更新。 换源&emsp;&emsp;打开终端，执行命令，复制之前的源文件：1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak &emsp;&emsp;打开源文件，全部删除并替换成国内阿里云源的：1sudo gedit /etc/apt/sources.list 12345678910deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse &emsp;&emsp;附1：ubuntu16.04阿里云源：12345678910deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse &emsp;&emsp;附1：ubuntu18.04阿里云源：12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse &emsp;&emsp;更新系统1sudo apt-get update 1sudo apt-get upgrade 配置NAO环境&emsp;&emsp;配置方法可以参考NAO的官方文档。&emsp;&emsp;注：下载的python-linux-SDK版本（32/64）要和Ubuntu系统一致。 安装python&emsp;&emsp;Ubuntu系统自带python2，所以无需安装。 安装python SDK&emsp;&emsp;根据官网的提示，进入NAO社区下载。我安装的系统是Ubuntu64位，所以选择64位的python SDK。百度云链接 提取码：8acy。&emsp;&emsp;先压缩下载好的文件，可以选择命令行压缩也可以直接右击文件选择Extract Here。压缩命令为：tar -xvf soft.tar.gz.tar，要先进入目标文件夹，如：12cd /home/cxx/NAO/NAOUbuntutar -xvf pynaoqi-python2.7-2.1.4.13-linux64.tar.gz.tar （按TAB键盘可自动补全） &emsp;&emsp;解压后将文件夹名改为python-sdk。 添加环境变量&emsp;&emsp;常用的方法是修改Ubuntu系统中存储环境变量的文件，如/etc/profile或/etc/bashrc，修改需要root权限。&emsp;&emsp;打开终端，进入文件夹后，使用Ubuntu自带的gedit打开文件，如：12cd /etcsudu gedit profile &emsp;&emsp;打开文件后，在最后一行输入官方文档给的环境变量名+文件路径：export PYTHONPATH=${PYTHONPATH}:/home/cxx/NAO/NAOUbuntu/python-sdk。保存并重启，然后在终端依次输入：python和import naoqi，如果没有报错则安装成功。 安装Choregraphe软件&emsp;&emsp;和python SDK一样，进入社区下载软件，百度云链接提取码：i2s7。然后用命令行或右击解压文件，解压命令tar -xzvf soft.tar.gz，如：12cd /home/cxx/NAO/NAOUbuntutar -xzvf choregraphe-suite-2.1.4.13-linux64.tar.gz &emsp;&emsp;解压完成后会进入文件夹，并打开bin文件夹中的choregraphe-bin即可。 NAO测试&emsp;&emsp;python环境的NAO测试，可以参考另一篇博客：基于python的NAO机器人开发01","categories":[{"name":"NAO开发与应用","slug":"NAO开发与应用","permalink":"http://cxx0822.github.io/categories/NAO开发与应用/"}],"tags":[]},{"title":"基于C++的NAO机器人开发01：配置C++环境","slug":"基于C++的NAO机器人开发01：配置C++环境","date":"2019-01-10T05:40:43.000Z","updated":"2022-03-21T06:19:12.761Z","comments":true,"path":"2019/01/10/ji-yu-c-de-nao-ji-qi-ren-kai-fa-01-pei-zhi-c-huan-jing/","link":"","permalink":"http://cxx0822.github.io/2019/01/10/ji-yu-c-de-nao-ji-qi-ren-kai-fa-01-pei-zhi-c-huan-jing/","excerpt":"","text":"基于C++的NAO机器人开发01：配置C++环境&emsp;&emsp;NAOdocument提供了官方的配置说明文档，官方文档，本博客也是基于这篇文档配置的。本博客基于Windows平台建立，其他平台可参考官方文档。 所需软件 操作系统：windows10 64位 编译器：Visual Studio 2010 qiBuild：生成交叉编译工程(具体见后面解释) CMake：跨平台编译软件，生成qiBuild所需的工程 python2&emsp;32位 naoqi C++ SDK 安装Visual Studio 2010&emsp;&emsp;百度云：链接：https://pan.baidu.com/s/1W58DQagcEN-AWlgNchaVUw提取码：0gey。下载解压后正常安装即可。软件大小约6.8G。&emsp;&emsp;只能是2010版的！官方文档说的2013版本装了编译不了，太坑了，可能是还没有C++SDK的vs2013版的。 为什么要装qibuild和CMake&emsp;&emsp;编译一共分2种：本地编译和交叉编译。本地编译：在当前编译平台下，编译出来的程序放到当前平台下运行。交叉编译：在当前编译平台下，编译出来的程序运行在体系结构不同的另一种目标平台上。因为我们是在本地计算机上面编译代码，然后要运行在NAO的操作系统里面，两者系统结构并不一样，所以需要使用交叉编译。&emsp;&emsp;qiBuild就是一个可以产生交叉编译工程文件的工具。&emsp;&emsp;CMake是一个跨平台的编译工具，可以用简单的语句来描述所有平台的编译过程。他能够输出各种各样的makefile或者project文件，包括Windows, Mac, Linux 和NAOqi OS。所以我们使用CMake来编译qiBuild产生的交叉编译工程文件，并写入NAO操作系统中。&emsp;&emsp;也就是说我们首先使用qiBuild生成一个可以交叉编译的文件，然后用CMake去编译，从而生成visual studio的工程文件，这样我们下次再去编写代码时，只需要在visual studio里面修改了，而且CMake编译的文件可以跨平台使用，可以直接传给NAO的操作系统使用。 (以上均个人理解) 安装CMake和python2&emsp;&emsp;CMake需要2.8.3以上的版本，网址。 尽量选择32位版本的，且是.msi的文件。&emsp;&emsp;注：安装时选择添加环境变量至所有用户，安装路径不要有中文。&emsp;&emsp;检查是否安装成功：进入cmd命令行：输入cmake，显示信息则安装正确。&emsp;&emsp;python的安装参考另一篇博客：基于python的NAO机器人开发01。 qiBuild的安装与配置&emsp;&emsp;qiBuild使用python的pip包管理来安装，进入cmd命令行，输入pip install qibuild即可。(如果安装了python2和3，一定要先切换到python2再安装。)&emsp;&emsp;安装完首先初始化设置，继续输入qibuild config --wizard并按照提示完成相应配置(选择visual studio 2010)，当然也可以再次输入重新配置。这一步相当于指定编译器类型。&emsp;&emsp;新建一个文件夹myWorktree(可以是其他名字)作为工作路径(不能放在中文文件夹下)，然后用cd命令切换到该文件夹下，初始化工作路径，输入命令：qibuild init。完成后会生成一个.qi的文件夹。 安装C++ SDK并配置&emsp;&emsp;进入NAO社区网站并下载windows版本的naoqi C++ SDK，网址。链接：https://pan.baidu.com/s/1Cic_8saHFx_uo_ge_sGDag提取码：o2qe，下载并解压重命名为naoqi-sdk，和之前的工作路径文件夹myWorktree放在同级目录。&emsp;&emsp;创建一个工具链，即建立一个交叉编译环境，输入命令：qitoolchain create mytoolchain /.../naoqi-sdk/toolchain.xml。mytoolchain为工具链的名字，/…/naoqi-sdk/toolchain.xml为naoqi的文件路径(可以先进入naoqi所在盘符名，在输入该命令，如qitoolchain create mytoolchain /NAO/naoqi-sdk/toolchain.xml)，最后cd进入工作路径文件夹myWorktree，生成配置文件qibuild add-config myconfig -t mytoolchain --default。&emsp;&emsp;注：我之前配置过，所以显示already exists。 新建qiBuild工程并测试hello world&emsp;&emsp;首先建立一个不涉及NAOqi库的工程。具体步骤见官方文档：官方文档。&emsp;&emsp;cd命令进入工作路径文件夹myWorktree，然后新建一个工程文件：1qisrc create myFirstExample &emsp;&emsp;cd命令进入该工程文件：1cd myFirstExample &emsp;&emsp;然后使用qibuild配置该文件1qibuild configure &emsp;&emsp;最后使用qibuild生成编译文件1qibuild make &emsp;&emsp;在生成的build-myconfig文件夹中可以找到visual studio的工程文件(后缀为.sln的文件)。&emsp;&emsp;打开后会发现一个有5个工程文件，其中只有my_first_example文件包含main.cpp，其余4个可以移除。并右击设置该文件夹为启动项。&emsp;&emsp;打开并编译运行main.cpp，可以看到输出的hello world。当然也可以用cd命令行找到其exe可执行文件直接运行，在build-myconfig/sdk/bin中。12cd build-myconfig/sdk/binmyfirstexample_d.exe moveHead&emsp;&emsp;下面建立一个包含naoqi库的一个案例，可以参考旧版的官方文档。官方文档。&emsp;&emsp;首先要建立一个工程文件movehead(即qisrc create movehead)，此时会生成一些文件，具体含义见官方文档说明。&emsp;&emsp;其次就是修改其中的main.cpp和CMakeLists.txt文件。我们采用官方文档的一个例子：movehead。&emsp;&emsp;将main.cpp里面的内容替换成movehead.cpp的内容(文件名也要修改为movehead.cpp)，CMakeLists.txt的内容替换成该例子中CMakeLists的内容。 CMakeLists.txt文件说明&emsp;&emsp;该文件一共有5行命令。具体含义见官方文档注释。比较重要的一行是最后一行，其含义为编译文件所需要包含的naoqi库文件，且均大写，也就是你编写的NAO代码需要用到哪些库，比如movehead这个例子，其头文件为12#include &lt;alerror/alerror.h&gt;#include &lt;alproxies/almotionproxy.h&gt; &emsp;&emsp;那么就需要将相应的的库放在最后一行。 编译工程文件&emsp;&emsp;编译方法有2种，一种是之前的命令行编译，还有一种是使用CMake软件编译，其原理是一样的。下面介绍CMake编译(编译之前要先建立工程文件夹)：&emsp;&emsp;打开CMake软件，在最上面的Source中选择工程文件夹，Build中选择工程文件夹中的Build文件夹(需要自己新建，和main.cpp位于同级目录)。&emsp;&emsp;然后点击下面的configure，选择VS2010编译器和交叉编译，在选择toolchain，在之前的naoqi-sdk文件夹下的toolchain-pc.cmake。&emsp;&emsp;等待一会，会全部红色高亮，再次点击Congfigure和Generate。此时打开build文件夹，找到vs2010的工程文件，打开编译执行即可。&emsp;&emsp;如果报错检查CMakeLists.txt中的项目文件夹名，.cpp文件名和相应的库名是否正确。&emsp;&emsp;注：如果不是第一次configure，需要清除缓存。file-&gt;Delete Cache。 Choregraphe调试&emsp;&emsp;打开Choregraphe软件，连接一个虚拟机器人，并在movehead.cpp中输入相应的ip地址和端口号，(删除main()中的if判断，并修改其中一行改为：AL::ALMotionProxy motion(&quot;127.0.0.1&quot;, 60770);，具体IP和端口号查看Choregraphe软件。)编译执行即可在机器人视图中看到效果。其实现方法和python类似，可参考另一篇博客基于python的NAO机器人开发01。","categories":[{"name":"NAO开发与应用","slug":"NAO开发与应用","permalink":"http://cxx0822.github.io/categories/NAO开发与应用/"}],"tags":[]},{"title":"K均值算法","slug":"K均值算法","date":"2019-01-08T05:17:54.000Z","updated":"2022-03-21T06:19:12.449Z","comments":true,"path":"2019/01/08/k-jun-zhi-suan-fa/","link":"","permalink":"http://cxx0822.github.io/2019/01/08/k-jun-zhi-suan-fa/","excerpt":"","text":"K均值算法一、基本原理&emsp;&emsp;K-均值算法属于无监督的聚类算法，所谓无监督就是原始数据集中的分类标签是未知的，聚类的意思为将相似的对象归到同一个簇中。k指的是将数据集分成几个簇，而均值的意思是，判断是否为相同类别的标准为数据的均值。&emsp;&emsp;K-均值算法首先随机确定k个初始点作为质心(均值)，然后计算数据集中每个点和每个质心的距离，并将其分配给距离最近的质心的类别中，这样就会产生了k个类别，然后再更新每个类别的质心，重复计算，直到每个类别的质心不在变化或满足迭代次数。&emsp;&emsp;伪代码为：1234567创建k个点作为起始质心(随机选择)当任意一个点的簇分配结果发生改变时 对数据集的每个数据点 对每个质心 计算质心与数据点之间的距离 将数据点分配到距离最近的簇 对每一个簇，计算簇中所有点的均值并将均值作为质心 二、算法实现准备数据集123456783.275154 2.957587 -3.344465 2.603513 0.355083 -3.376585 1.852435 3.547351...2.960769 3.079555-3.275518 1.5770680.639276 -3.412840 &emsp;&emsp;数据集由一系列的二维坐标构成，用制表符隔开，首先用open函数打开文本文件，然后将其放入python列表中。程序实现：12345678910from numpy import *def loadDataSet(fileName): dataMat = [] fr = open(fileName) for line in fr.readlines(): curLine = line.strip().split('\\t') fltLine = list(map(float, curLine)) #将字符串转为浮点型 dataMat.append(fltLine) return dataMat 程序说明：&emsp;&emsp;map(function, iterable, ...)：将可迭代对象iterable执行函数function，即对可迭代对象中的每一个元素都进行一次函数调用，得到新的可迭代对象。python3中map()函数返回的是迭代器，所以要在前面调用list()函数将其转换为列表。&emsp;&emsp;函数首先打开原始数据文件，然后用制表符隔开数据并添加到列表中，因为后面需要对其进行数值计算，而readlines()函数返回的列表元素是字符串，所以要利用map()函数将其全部转换为浮点数类型。最后添加至返回值列表中。 随机生成质心&emsp;&emsp;k均值的核心就是不断的更新质心，但最开始的质心通常是随机生成的，且必须要在原始数据集的范围内，即要保证在最小值和最大值之间。程序实现：123456789def randCent(dataSet, k): n = shape(dataSet)[1] # 返回数据集的列数 centroids = mat(zeros((k, n))) # 初始化质心为0 for j in range(n): minJ = min(dataSet[:, j]) rangeJ = float(max(dataSet[:, j]) - minJ) centroids[:, j] = mat(minJ + rangeJ * random.rand(k, 1)) # 保证生成的质心坐标在边界内 return centroids 程序说明：&emsp;&emsp;mat()：将数据转为矩阵形式。array()：将数据转为数组形式。矩阵：二维数据，数组：多维数据。numpy中默认的数据形式为数组形式。&emsp;&emsp;首先计算出数据每列的最小和最大值，然后得到取值范围，从而确定随机数。k为质心的个数。12range = max - mini = min + range * (0,1) # 在(min,max)范围内 距离计算&emsp;&emsp;K均值算法需要将其数据集中的数据分配给距离最近的质心的类别中，常用的距离计算公式为平面内点之间的距离公式。图程序实现：12def distEclud(vecA, vecB): return sqrt(sum(power(vecA - vecB, 2))) &emsp;&emsp;当然也可以用其他的距离计算公式。 k均值算法程序实现：12345678910111213141516171819202122def kMeans(dataSet, k, distMeas=distEclud, createCent=randCent): m = shape(dataSet)[0] clusterAssment = mat(zeros((m, 2))) centroids = createCent(dataSet, k) clusterChanged = True while clusterChanged: clusterChanged = False for i in range(m): # 遍历数据集的每一行数据 minDist = inf minIndex = -1 for j in range(k): # 确定每一行数据的类别标签 distJI = distMeas(centroids[j, :], dataSet[i, :]) if distJI &lt; minDist: minDist = distJI minIndex = j if clusterAssment[i, 0] != minIndex: clusterChanged = True clusterAssment[i, :] = minIndex, minDist**2 for cent in range(k): ptsInClust = dataSet[nonzero(clusterAssment[:, 0].A == cent)[0]] centroids[cent, :] = mean(ptsInClust, axis=0) # 更新每个类别的质心 return centroids, clusterAssment 程序说明：&emsp;&emsp;该函数一共有4个输入参数，第一个为数据集dataSet，第二个为分类类别数目，第三个为距离计算公式，第四个为创建初始质心的函数。返回值为质心坐标和簇分配结果矩阵(类别标签结果和与质心的误差)。&emsp;&emsp;首先初始化簇分配结果矩阵为0并随机产生k个质心。函数主体一共有3层循环，第一层循环为while循环，其循环条件为：clusterChanged，即任一点的簇分配结果的类别标签是否改变，也就是每个数据的前后2次分类结果都是同一类就跳出while循环，否则需要继续分类。首先将其设为false，然后进入第二层的for循环判断，该层for循环会遍历数据集中的每一行数据，首先初始化距离和类别标签，然后进入第三层的for循环判断，该层for循环会判断每一行数据属于哪一类的类别标签，首先计算质心坐标和数据集中每一行数据的距离，并和minDist判断大小，一共判断k次，即有多少个类别就判断多少次，从而找到哪个类别和质心的距离最小，并设置为该类别。每做完一次第三层循环，都会判断一次终止条件是否满足，即如果之前判断的类别标签和现在的结果不是一致的，则仍需要继续分类，也就是现在的质心还不稳定，数据集中还存在不稳定的分类结果。&emsp;&emsp;每遍历完一次完整的数据集都需要重新计算每个类别的质心。 clusterAssment[:, 0]表示簇分配结果的第一列，即每行数据的类别标签，.A表示将结果转换为矩阵形式，然后判断是否等于相应的类别(k表示分类数目，也相当于类别标签，比如k为3，表示一共3类，类别为0，1，2)，nonzero()返回非0元素的索引，也就是返回是该类别的数据的索引，然后根据索引找到dateSet数据中的数据。也就是分别找到簇分配结果矩阵中的每个类别对应的原始数据集的数据。这里[0]表示的是nonzero()函数有很多返回值，我们需要的是其索引值，也就是第1个返回值。得到每一类的数据后，在进行均值计算，得到每一类的新的质心。 程序结果&emsp;&emsp;质心坐标：123[[ 2.93386365 3.12782785] [-2.94737575 3.3263781 ] [-0.45965615 -2.7782156 ]] # 每一类质心的坐标 &emsp;&emsp;簇分配结果矩阵：1234567[[0.00000000e+00 1.45461050e-01] [1.00000000e+00 6.80213825e-01] [2.00000000e+00 1.02184582e+00]... [0.00000000e+00 3.05416591e-03] [1.00000000e+00 3.16776316e+00] [2.00000000e+00 1.61040000e+00]] &emsp;&emsp;第一列为分类结果，0表示第一类，以此类推，第二列为每类数据与该类质心的误差。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://cxx0822.github.io/categories/机器学习/"}],"tags":[]},{"title":"将hexo博客转移到另一台电脑","slug":"将hexo博客转移到另一台电脑","date":"2019-01-05T08:41:23.000Z","updated":"2022-03-21T06:19:12.985Z","comments":true,"path":"2019/01/05/jiang-hexo-bo-ke-zhuan-yi-dao-ling-yi-tai-dian-nao/","link":"","permalink":"http://cxx0822.github.io/2019/01/05/jiang-hexo-bo-ke-zhuan-yi-dao-ling-yi-tai-dian-nao/","excerpt":"","text":"安装必要的软件&emsp;&emsp;有2个必须安装的软件：Git客户端和node JS。百度下载安装即可。 在Github官网添加新电脑产生的密钥&emsp;&emsp;安装完git客户端后，在桌面或者文件夹中右击选择git bash并输入以下命令：1ssh-keygen -t rsa -C \"邮箱地址\" &emsp;&emsp;邮箱为注册Github的邮箱地址，输入命令后一直按回车，然后会生成一个.ssh的文件夹，打开里面的.pub文件，就是新产生的密钥。然后登陆GitHub网站，找到setting设置，然后选择SSH and GPG keys，点击New SSH key，然后给密钥命名并将.pub文件中的&#39;ssh-ras....&#39;后面的内容复制到key中。 复制之前电脑的博客文件夹&emsp;&emsp;没有必要全部复制，只需要部分文件夹复制即可：12345_config.ymlpackage,jsonscaffolds/source/themes/ 安装hexo&emsp;&emsp;打开cmd，输入下面指令安装hexo：1npm install hexo-cli -g 配置博客相关模块&emsp;&emsp;进入到博客文件夹中，右击选择git bash1234npm config set registry https://registry.npm.taobao.org //换源npm info underscore (输出正常反馈信息则说明换源成功)npm installnpm install hexo-deployer-git --save // 文章部署到 git 的模块 &emsp;&emsp;如果博客中需要上传本地图片，首先将_config.yml文件中的 post_asset_folder字段设置为true，然后再安装图片模块：1npm install https://github.com/CodeFalling/hexo-asset-image --save 登陆账号&emsp;&emsp;第一次上传博客到服务器时，输入hexo d，会出现错误，并提示需要输入邮箱和用户名，指令在提示窗口中，重新输入指令并输入邮箱和用户名即可。 常用命令123hexo n \"文件名\" //新建一个md文件hexo g //生成网站静态文件到默认设置的 public 文件夹hexo d //自动生成网站静态文件，并部署到设定的仓库,即上传至服务器","categories":[{"name":"杂项","slug":"杂项","permalink":"http://cxx0822.github.io/categories/杂项/"}],"tags":[]},{"title":"基于python的NAO机器人开发01：安装python和naoqi库及有线和无线连接","slug":"基于python的NAO机器人开发01：安装python和naoqi库及有线和无线连接","date":"2019-01-02T06:26:10.000Z","updated":"2022-03-31T12:00:09.018Z","comments":true,"path":"2019/01/02/ji-yu-python-de-nao-ji-qi-ren-kai-fa-01-an-zhuang-python-he-naoqi-ku-ji-you-xian-he-wu-xian-lian-jie/","link":"","permalink":"http://cxx0822.github.io/2019/01/02/ji-yu-python-de-nao-ji-qi-ren-kai-fa-01-an-zhuang-python-he-naoqi-ku-ji-you-xian-he-wu-xian-lian-jie/","excerpt":"","text":"一、NAOqi APIs&emsp;&emsp;NAOqi OS是NAO机器人的核心操作系统，NAOqi API提供了访问机器人的各种传感器设备接口以及应用接口。通过NAOqi，可以在动作、视觉、音频等不同模块之间相互传递信息，也可以通过编程实现各种功能。 二、安装python和NAOqi库&emsp;&emsp;Windows环境下，NAO支持的python版本为32位的python2，可以在python官网中下载。选择Windows x86 MSI installer，并配置python2的环境变量，将C:\\Python27和C:\\Python27\\Scripts添加至PATH中。然后在软银机器人社区SoftBank Robotics Community中下载NAOqi库，选择Resources中的Software，找到Python 2.7 SDK 2.1.4 Win 32 Setup下载即可。&emsp;&emsp;下载链接：NAOqi python SDK &emsp;&emsp;检查python是否安装正确：同时按下win+R，并输入cmd，进入命令行程序，输入python，如果有提示信息则安装正确，否则检查环境变量是否添加正确。&emsp;&emsp;检查naoqi是否安装正确：接上面的命令行(输入python的前提下)，继续输入import naoqi，无任何显示则安装正确。 三、安装Choregraphe&emsp;&emsp;Choregraphe是一个图形化的多平台软件，编写完程序后可以在模拟机器人上测试，也可以运行在真实的机器人上。在软银机器人社区SoftBank Robotics Community中可以下载。选择Resources中的Software，找到Choregraphe 2.1.4 Win 32 Setup下载安装即可。&emsp;&emsp;注：安装路径不要出现在中文。&emsp;&emsp;下载链接：Choregraphe 四、NAO机器人的有线连接4.1 连接步骤&emsp;&emsp;首先将NAO和计算机通过网线连接，将计算机的网络设置为有线连接，然后打开浏览器，按下NAO机器人的胸部按钮，在浏览器中输入NAO报的IP地址。 &emsp;&emsp;输入用户名nao，密码nao(默认)即可登陆至nao机器人网页，在网络设置里面可以看到已经连接至有线。 4.2 测试&emsp;&emsp;打开Choregraph，选择连接-&gt;连接至，在弹出的对话框中选择IP为刚才的NAO机器人，并选择连接。 &emsp;&emsp;在Choregraph界面的左下角的指令盒内依次选择Motions中的Wake Up，Stand Up和Rest，并用信号线将其连接，即可实现简单的站立、休息的动作。在Choregraph界面的最上面单击绿色三角箭头按钮即可运行程序。 &emsp;&emsp; 当然也可以通过python编译器在里面输入相应的代码实现此功能。 12345678910111213141516171819202122232425262728# -*- encoding: UTF-8 -*-import argparsefrom naoqi import ALProxydef main(robotIP, PORT=9559): motionProxy = ALProxy(\"ALMotion\", robotIP, PORT) postureProxy = ALProxy(\"ALRobotPosture\", robotIP, PORT) # Wake up robot motionProxy.wakeUp() # Send robot to Stand Init postureProxy.goToPosture(\"StandInit\", 0.5) # Go to rest position motionProxy.rest()if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument(\"--ip\", type=str, default=\"169.254.67.213\", help=\"Robot ip address\") parser.add_argument(\"--port\", type=int, default=9559, help=\"Robot port number\") args = parser.parse_args() main(args.ip, args.port) &emsp;&emsp;注意，IP和端口号(port)一定要对，IP为按NAO胸口按钮后报出的IP，真实NAO的port默认为9559。&emsp;&emsp;最终效果如图所示： 五、NAO机器人的无线连接及测试5.1 连接步骤&emsp;&emsp;打开计算机的无线网络连接,连接一个无线网，然后在NAO网页界面的网络设置中选择和计算机相同的无线网络，并拔掉网线，即可实现无线连接。按下NAO胸口按钮，此时会报出无线网的IP地址。此时需要重新输入IP地址进入NAO网页界面。 5.2 测试&emsp;&emsp;此时，在Choregraph中的连接选项中，选择无线网的IP地址的NAO机器人，并执行刚才的程序。同理在python代码中更改相应的IP地址和端口号即可。 六、虚拟NAO机器人的连接及测试6.2 连接步骤&emsp;&emsp;Choregraph软件提供了可连接虚拟机器人的设置，也可以实现一些真实机器人的功能。先断开所有的真实机器人的连接，在连接选项中选择连接虚拟机器人即可连接至一个虚拟机器人。同时可以查看它的IP地址和端口号。（虚拟机器人默认的IP地址都为127.0.0.1）在视图选项中勾选上机器人视图即可查看虚拟机器人。 6.3 测试&emsp;&emsp;同理在python代码中更改相应的IP地址和端口号即可。","categories":[{"name":"NAO开发与应用","slug":"NAO开发与应用","permalink":"http://cxx0822.github.io/categories/NAO开发与应用/"}],"tags":[]},{"title":"基于python的NAO机器人开发02：多线程实现边唱歌边跳舞","slug":"基于python的NAO机器人开发02：多线程实现边跳舞边唱歌","date":"2019-01-02T06:19:47.000Z","updated":"2022-03-21T06:19:12.899Z","comments":true,"path":"2019/01/02/ji-yu-python-de-nao-ji-qi-ren-kai-fa-02-duo-xian-cheng-shi-xian-bian-tiao-wu-bian-chang-ge/","link":"","permalink":"http://cxx0822.github.io/2019/01/02/ji-yu-python-de-nao-ji-qi-ren-kai-fa-02-duo-xian-cheng-shi-xian-bian-tiao-wu-bian-chang-ge/","excerpt":"","text":"在NAO上播放音频&emsp;&emsp;在NAO机器人上播放音频文件常用的库为ALAudioPlayer，里面有2个可以播放音乐的函数：play()和playFile()。 play()&emsp;&emsp;该函数的C++函数头为：1void play(const int&amp; taskId, const float&amp; volume, const float&amp; pan) &emsp;&emsp;该函数有3个参数，其中第一个为必须的，后面2个是可选的。第一个参数为任务ID，即文件名，通常由ALAudioPlayer库里面的loadFile(&quot;文件名&quot;)函数产生的。第二个为音频的音量，其值为0.0-1.0，第三个为Stereo panorama requested (-1.0 : left / 1.0 : right)d。 123456from naoqi import ALProxy audio = ALProxy(\"ALAudioPlayer\", '169.254.67.213', 9559)fileId = audio.loadFile(\"文件名绝对路径\")audio.play(fileId) &emsp;&emsp;首先建立一个ALAudioPlayer库的实例，然后用loadFile()加载音频文件，最后使用play()函数进行播放。 playFile()&emsp;&emsp;该函数的C++函数头为：1void playFile(const std::string&amp; fileName, const float&amp; volume, const float&amp; pan) &emsp;&emsp;该函数基本和play()类似，只是第一个参数为文件名，即不需要在用loadFile()函数来转换。123456from naoqi import ALProxy audio = ALProxy(\"ALAudioPlayer\", '169.254.67.213', 9559)songfile = \"文件名绝对路径\" audio.playFile(songfile) 将音频文件传入到NAO中&emsp;&emsp;NAO机器人存储器中自带一些音频文件，同时也支持将本地音频文件上传至NAO中。NAO机器人本身相当于一个服务器，本地计算机相当于主机，只要输入正确的IP地址和端口号即可访问和文件操作。常用的方式为自带的Choregraph软件和其他文件传输软件。 Choregraph软件&emsp;&emsp;NAO机器人自带的Choregraph软件可以将本地文件上传到NAO机器人的存储内存中，其文件传输协议为FTP模式。&emsp;&emsp;首先将NAO机器人连接到Choregraph软件中，具体可以参考另一篇博客：基于python的NAO机器人开发01。然后在连接选项中，选择高级-&gt;文件传送，此时必须是连接真机，虚拟机器人没有此功能。&emsp;&emsp;然后输入用户名(nao)和密码(初始为nao)。&emsp;&emsp;在空白处右击，选择创建文件夹即可创建自己的文件夹，点击上传功能并选择相应的本地文件即可将文件上传至NAO机器人中，此时文件存放的路径为：/home/nao/...。&emsp;&emsp;例如新建一个test的文件夹，并将test_wav.wav音频文件上传至NAO机器人中，可以使用下面的代码播放音频。12345678from naoqi import ALProxydef playMusic(): audio = ALProxy(\"ALAudioPlayer\", '169.254.67.213', 9559) songfile = \"/home/nao/test/test_wav.wav\" audio.playFile(songfile)playMusic() &emsp;&emsp;注：NAO机器人中，只能识别wav格式的音频文件，不支持mp3等其他格式的。 WinSCP软件&emsp;&emsp;除了使用Choregraph软件可以传输文件外，还可以使用其他的文件传输软件，比如WinSCP。输入其对应的IP地址和端口号，即可访问其内部文件夹。&emsp;&emsp;打开WinSCP软件后，首先选择FTP文件传输模式，然后输入相应的NAO机器人IP地址，用户名和密码同Choregraph软件。输入正确后，即可进入到机器人的内部存储文件夹。&emsp;&emsp;在WinSCP中上传本地文件，直接选中文件拖拽到相应位置即可，右击选择属性也可以直接更改其文件夹或文件的访问权限。 将python文件传入NAO机器人中，并直接运行&emsp;&emsp;除了可以上传音频文件，其他任何文件都可以上传至NAO机器人中，而NAO机器人中自带python的解释器，所以可以将py文件上传到NAO中，并直接运行python文件。&emsp;&emsp;NAO机器人内部使用的是linux操作系统，使用PuTTY软件可以进入到该系统中。linux系统的命令也都适用于此，输入相应的命令即可直接运行python文件。 登陆NAO系统&emsp;&emsp;打开PuTTY软件后，选择SSH登陆方式，然后输入正确的IP地址和端口号即可登陆NAO系统，用户名和密码同之前。 NAO系统中常用的Linux命令 cd ~ :返回根目录 cd /.../...：进入某个文件夹，例：cd /home/nao/test/ （TAB键可以自动补全） cd .. ：返回上一级文件夹 pwd：查看当前所在目录 ls： 查看当前文件夹的内容（ls：list） ls -l：查看当前文件夹的内容和详细信息 rm file：删除名为file的文件（rm：remove） rmdir dir：删除名为dir的目录（dir：dictionary） chmod \\*** file：修改文件权限&emsp;&emsp;文件权限共分为3种，r：读权限，用数字4表示；w：写权限，用数字2表示；x：执行权限，用数字1表示。一共有3类用户：文件所有者，同组用户和其他用户。每种用户用1个数字表示。&emsp;&emsp;比如将文件所有者的权限改为可读可写可执行：chmod 700 file。将所有用户都改为可读可写可执行：chmod 777 file。&emsp;&emsp;7表示4+2+1，即3个权限之和，file为完整的文件路径名。 ifconfig：显示以太网信息 su：登陆超级用户，密码为root reboot：重启 shutdown -h now：现在关机（需要root权限） 在NAO中执行运行python文件&emsp;&emsp;NAO支持多种编程，其内部带有python的解释器，使用python \\*.py文件可以直接运行。&emsp;&emsp;例如在/home/nao/目录下新建一个test的文件夹，并将之前的python文本文件和音频文件放入该文件夹中。首先利用cd /home/nao/test/命令进入该文件夹，然后输入python test.py命令，就可以实现之前的功能。&emsp;&emsp;注：如果音频不能正确播放，可能需要权限设置，将文件权限改为可读可写可执行即可。NAO有2块网卡，即有线网卡和无线网卡。分别对应一个IP地址，其本身也有一个本地IP地址，即127.0.0.1。当运行NAO本地的python文件时，可以将IP地址设置为有线连接或无线连接的IP地址，也可以直接设置为本地IP地址。 NAO机器人跳舞&emsp;&emsp;NAO机器人全身有25个自由度，通过控制每个自由度的变化可以实现多种不同的运动动作。&emsp;&emsp;ALMotionProxy库中的angleInterpolation()函数可以控制每个关节的变化，其函数头为：1void angleInterpolation(const AL::ALValue&amp; names, const AL::ALValue&amp; angleLists, const AL::ALValue&amp; timeLists, const bool&amp; isAbsolute) &emsp;&emsp;函数的第一个参数为关节的名字，第二个参数为关节的角度(弧度制)，第三个参数为关节变化的时间(s)，第四个参数为是否为相对变化，即变化的角度是否跟随上一个变化。&emsp;&emsp;NAO中的每个关节的名称可以参考NAO的官方文档，通过给每个关节不同的角度值就可以实现不同的动作，所谓舞蹈就是一连串动作的结合。&emsp;&emsp;这里参考了别人的跳舞代码：&emsp;&emsp;Dance模板库dance.py：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class DancePart(object): \"\"\" DancePart for Nao dance includes lists of names, times, and keys for Python simplified dances exported from Choreographe\"\"\" def __init__(self, part_length, pause_length, names, times, keys): super(DancePart, self).__init__() self.part_length = part_length self.pause_length = pause_length self.names = names self.times = times self.keys = keys def get_part_length(self): return self.part_length def get_pause_length(self): return self.pause_length def get_names(self): return self.names def get_times(self): return self.times def get_keys(self): return self.keysclass Dance(object): \"\"\" Nao robot dance. The attribute num_parts is the number of parts in the dance. The parts attribute is a list of DanceParts\"\"\" def __init__(self, song_name, num_parts, parts): super(Dance, self).__init__() self.song_name = song_name self.num_parts = num_parts self.parts = parts def get_part(self, part_num): return self.parts[part_num] def get_song_name(self): return self.song_name def get_num_parts(self): return self.num_parts def get_parts(self): return self.parts &emsp;&emsp;waltzDance舞蹈代码waltzDance.py： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444# -*- encoding: UTF-8 -*-from dance import DancePart, Dancenames1 = list()times1 = list()keys1 = list()names1.append(\"HeadPitch\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([0.136484, -0.130432, -0.147306, 0.032172, 0.0720561, 0.0720561, 0.113474, 0.00455999])names1.append(\"HeadYaw\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([-0.00464392, 0.274544, 0.0122299, -0.316046, 0.00609398, 0.332836, -0.0153821, -0.43263])names1.append(\"LAnklePitch\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([0.0935321, 0.0935321, 0.0843279, 0.082794, 0.082794, 0.082794, 0.082794, 0.082794])names1.append(\"LAnkleRoll\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([-0.125746, -0.125746, -0.125746, -0.125746, -0.125746, -0.125746, -0.125746, -0.125746])names1.append(\"LElbowRoll\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([-1.38363, -1.32533, -1.41584, -1.36062, -1.38669, -1.3192, -1.32687, -1.33914])names1.append(\"LElbowYaw\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([-1.52484, -2.06634, -1.52944, -1.53711, -1.53711, -2.07248, -1.53864, -1.53864])names1.append(\"LHand\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([0.2932, 0.2932, 0.2852, 0.2932, 0.2932, 0.2932, 0.2932, 0.2932])names1.append(\"LHipPitch\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([0.139636, 0.139636, 0.131966, 0.139636, 0.139636, 0.139636, 0.139636, 0.139636])names1.append(\"LHipRoll\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([0.093616, 0.093616, 0.10282, 0.093616, 0.093616, 0.093616, 0.093616, 0.093616])names1.append(\"LHipYawPitch\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([-0.171766, -0.171766, -0.174835, -0.171766, -0.171766, -0.171766, -0.171766, -0.171766])names1.append(\"LKneePitch\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([-0.0782759, -0.0782759, -0.0890141, -0.0890141, -0.0890141, -0.0890141, -0.0890141, -0.0890141])names1.append(\"LShoulderPitch\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([1.50328, 1.59532, 1.50481, 1.55083, 1.54316, 1.59532, 1.47567, 1.54776])names1.append(\"LShoulderRoll\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([-0.0383921, 0.338972, -0.0982179, -0.04913, -0.0890141, 0.337438, -0.107422, -0.0521979])names1.append(\"LWristYaw\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([-1.49876, -1.68591, -1.5233, -1.53558, -1.53558, -1.67517, -1.52177, -1.52177])names1.append(\"RAnklePitch\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([0.093616, 0.093616, 0.0874801, 0.093616, 0.093616, 0.093616, 0.093616, 0.093616])names1.append(\"RAnkleRoll\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([0.135034, 0.135034, 0.127364, 0.135034, 0.135034, 0.135034, 0.135034, 0.135034])names1.append(\"RElbowRoll\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([1.47575, 1.45427, 1.5095, 1.27019, 1.48189, 1.45427, 1.48189, 1.27019])names1.append(\"RElbowYaw\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([1.54776, 1.56004, 1.5585, 1.33147, 1.54623, 1.5585, 1.5585, 1.32227])names1.append(\"RHand\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([0.2864, 0.2864, 0.288, 0.2864, 0.2864, 0.2864, 0.2864, 0.2864])names1.append(\"RHipPitch\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([0.122678, 0.122678, 0.131882, 0.133416, 0.133416, 0.133416, 0.133416, 0.133416])names1.append(\"RHipRoll\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([-0.10427, -0.10427, -0.10427, -0.10427, -0.10427, -0.10427, -0.10427, -0.10427])names1.append(\"RHipYawPitch\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([-0.171766, -0.171766, -0.174835, -0.171766, -0.171766, -0.171766, -0.171766, -0.171766])names1.append(\"RKneePitch\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([-0.0858622, -0.0858622, -0.0873961, -0.0858622, -0.0858622, -0.0858622, -0.0858622, -0.0858622])names1.append(\"RShoulderPitch\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([1.62455, 1.66597, 1.61534, 1.29781, 1.62762, 1.6629, 1.64756, 1.29781])names1.append(\"RShoulderRoll\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([0.00609398, 0.0720561, 0.0628521, -0.579894, 0.0613179, 0.0613179, 0.0613179, -0.57836])names1.append(\"RWristYaw\")times1.append([0.56, 1.76, 2.96, 4.24, 5.44, 6.48, 7.92, 9.56])keys1.append([1.53549, 1.53549, 1.53703, 1.59072, 1.57231, 1.57231, 1.57231, 1.58458])names2 = list()times2 = list()keys2 = list()names2.append(\"HeadPitch\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([-0.147306, -0.00771189, -0.00771189, -0.147306, -0.0322559, -0.147306, -0.147306])names2.append(\"HeadYaw\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([0.0122299, 0.54913, 0.54913, 0.0137641, -0.589098, 0.0137641, 0.0137641])names2.append(\"LAnklePitch\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([0.0843279, 0.082794, 0.082794, 0.0843279, 0.082794, 0.0843279, 0.0843279])names2.append(\"LAnkleRoll\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([-0.125746, -0.125746, -0.125746, -0.125746, -0.125746, -0.125746, -0.125746])names2.append(\"LElbowRoll\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([-1.38669, -0.87127, -0.87127, -0.952573, -0.937232, -1.04308, -1.04308])names2.append(\"LElbowYaw\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([-1.55245, -1.97123, -1.97123, -0.50166, -0.492456, -0.622845, -0.622845])names2.append(\"LHand\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([0.2852, 0.2932, 0.2932, 0.2852, 0.2932, 0.2852, 0.2852])names2.append(\"LHipPitch\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([0.131966, 0.139636, 0.139636, 0.131966, 0.139636, 0.131966, 0.131966])names2.append(\"LHipRoll\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([0.10282, 0.093616, 0.093616, 0.10282, 0.093616, 0.10282, 0.10282])names2.append(\"LHipYawPitch\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([-0.174835, -0.171766, -0.171766, -0.174835, -0.171766, -0.174835, -0.174835])names2.append(\"LKneePitch\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([-0.0890141, -0.0890141, -0.0890141, -0.0890141, -0.0890141, -0.0890141, -0.0890141])names2.append(\"LShoulderPitch\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([1.53242, 1.74872, 1.74872, -1.13827, -1.10145, 0.472429, 0.472429])names2.append(\"LShoulderRoll\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([-0.0245859, 0.700996, 0.700996, 0.29602, 0.314428, 0.118076, 0.118076])names2.append(\"LWristYaw\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([-1.54018, -1.42666, -1.42666, -1.12293, -1.14134, -0.785451, -0.785451])names2.append(\"RAnklePitch\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([0.0874801, 0.093616, 0.093616, 0.0874801, 0.093616, 0.0874801, 0.0874801])names2.append(\"RAnkleRoll\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([0.127364, 0.135034, 0.135034, 0.127364, 0.135034, 0.127364, 0.127364])names2.append(\"RElbowRoll\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([1.09992, 1.11679, 1.0585, 1.06771, 0.61671, 0.60904, 0.880559])names2.append(\"RElbowYaw\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([0.651908, 0.662646, 0.335904, 0.346642, 0.944902, 0.961776, 0.645772])names2.append(\"RHand\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([0.288, 0.2864, 0.2864, 0.288, 0.2864, 0.288, 0.288])names2.append(\"RHipPitch\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([0.131882, 0.133416, 0.133416, 0.131882, 0.133416, 0.131882, 0.131882])names2.append(\"RHipRoll\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([-0.10427, -0.10427, -0.10427, -0.10427, -0.10427, -0.10427, -0.10427])names2.append(\"RHipYawPitch\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([-0.174835, -0.171766, -0.171766, -0.174835, -0.171766, -0.174835, -0.174835])names2.append(\"RKneePitch\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([-0.0873961, -0.0858622, -0.0858622, -0.0873961, -0.0858622, -0.0873961, -0.0873961])names2.append(\"RShoulderPitch\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([-1.03081, -0.990922, 0.475582, 0.457173, 0.512398, 0.506262, 0.464844])names2.append(\"RShoulderRoll\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([-0.366667, -0.391212, -0.181054, -0.170316, -0.951122, -0.981802, -0.0353239])names2.append(\"RWristYaw\")times2.append([0.8, 1.76, 3.04, 4.24, 5.96, 6.76, 8.2])keys2.append([1.75025, 1.73031, 1.38976, 1.35755, 1.06609, 1.02927, 0.812978])names3 = list()times3 = list()keys3 = list()names3.append(\"HeadPitch\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([-0.142704, -0.1335, 0.0904641, -0.154976, -0.0629361, -0.142704, -0.115092, -0.142704, -0.115092, -0.142704, -0.142704, 0.00455999])names3.append(\"HeadYaw\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([-0.00310993, -0.00157595, 0.00609398, -0.00157595, -0.016916, 0.00762796, 0.377322, 0.00762796, -0.527738, 0.00762796, 0.00762796, 0.309826])names3.append(\"LAnklePitch\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([0.0858622, 0.082794, 0.0858622, 0.082794, 0.0858622, 0.0858622, -0.259288, 0.0858622, 0.105804, 0.0858622, 0.0858622, 0.0919981])names3.append(\"LAnkleRoll\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([-0.130348, -0.125746, -0.130348, -0.125746, -0.130348, -0.130348, -0.0935321, -0.130348, -0.128814, -0.131882, -0.131882, -0.128814])names3.append(\"LElbowRoll\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([-1.42965, -0.056716, -1.40357, -0.0689881, -1.52169, -0.961776, -0.0475121, -0.961776, -0.954106, -1.18114, -1.4772, -1.3959])names3.append(\"LElbowYaw\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([-0.506262, -0.53234, -0.495524, -1.13674, -0.329852, -0.704148, -0.757838, -0.704148, -0.68574, -1.37451, -1.49569, -2.07401])names3.append(\"LHand\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([0.2932, 0.2892, 0.2892, 0.2892, 0.2892, 0.2932, 0.2892, 0.2932, 0.2892, 0.2932, 0.2932, 0.2892])names3.append(\"LHipPitch\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([0.131966, 0.124296, 0.128898, 0.124296, 0.128898, 0.131966, 0.128898, 0.131966, 0.0813439, 0.130432, 0.130432, 0.121228])names3.append(\"LHipRoll\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([0.096684, 0.092082, 0.096684, 0.092082, 0.096684, 0.096684, 0.096684, 0.0966839, 0.096684, 0.090548, 0.090548, 0.096684])names3.append(\"LHipYawPitch\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([-0.1733, -0.179436, -0.171766, -0.179436, -0.171766, -0.1733, -0.171766, -0.1733, -0.228524, -0.171766, -0.171766, -0.170232])names3.append(\"LKneePitch\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([-0.0874801, -0.092082, -0.0859461, -0.092082, -0.0859461, -0.0874801, 0.283748, -0.0874801, -0.0828779, -0.0859461, -0.0859461, -0.0828779])names3.append(\"LShoulderPitch\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([1.53089, 1.55697, 1.53703, 1.48794, 0.506178, -1.0539, -0.949588, -1.0539, -1.01708, 1.37902, 1.49868, 1.53549])names3.append(\"LShoulderRoll\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([0.720938, 1.09063, 0.714802, 0.607422, 0.489304, 0.408002, 1.12131, 0.408002, 0.432546, 0.542994, -0.07214, 0.0383081])names3.append(\"LWristYaw\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([-1.11679, -1.1306, -1.12907, -1.8209, -1.29934, -1.11219, -1.24718, -1.11219, -1.126, -1.58006, -1.54785, -1.63835])names3.append(\"RAnklePitch\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([0.09515, 0.093616, 0.0874801, 0.093616, 0.0874801, 0.093616, 0.0567999, 0.093616, -0.0689881, 0.092082, 0.092082, 0.0890141])names3.append(\"RAnkleRoll\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([0.128898, 0.122762, 0.130432, 0.122762, 0.130432, 0.128898, 0.153442, 0.128898, 0.067538, 0.130432, 0.130432, 0.122762])names3.append(\"RElbowRoll\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([1.4282, 0.0844119, 1.40519, 0.0598679, 1.5187, 0.978734, 1.00021, 0.978734, 0.0583339, 0.975666, 1.4374, 1.40979])names3.append(\"RElbowYaw\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([0.179436, 0.19631, 0.1733, 0.872804, 0.207048, 0.573674, 0.561402, 0.573674, 0.573674, 1.10444, 1.49868, 1.48334])names3.append(\"RHand\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([0.2864, 0.2916, 0.2916, 0.2916, 0.2916, 0.2864, 0.2916, 0.2864, 0.2916, 0.2864, 0.2864, 0.2916])names3.append(\"RHipPitch\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([0.131882, 0.125746, 0.124212, 0.125746, 0.124212, 0.121144, 0.184038, 0.121144, -0.190258, 0.118076, 0.118076, 0.118076])names3.append(\"RHipRoll\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([-0.099668, -0.0966001, -0.10427, -0.0966001, -0.10427, -0.099668, -0.12728, -0.0996681, -0.0919981, -0.0950661, -0.0950661, -0.102736])names3.append(\"RHipYawPitch\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([-0.1733, -0.179436, -0.171766, -0.179436, -0.171766, -0.1733, -0.171766, -0.1733, -0.228524, -0.171766, -0.171766, -0.170232])names3.append(\"RKneePitch\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([-0.0858622, -0.0889301, -0.0858622, -0.0889301, -0.0858622, -0.0858622, -0.0858622, -0.0858622, 0.335988, -0.0923279, -0.0919981, -0.0889301])names3.append(\"RShoulderPitch\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([1.34843, 1.32388, 1.38064, 1.31008, 0.526204, -1.10137, -1.06916, -1.10137, -1.06916, 1.13674, 1.4466, 1.45888])names3.append(\"RShoulderRoll\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([-0.794654, -1.09072, -0.77778, -0.635118, -0.553816, -0.49399, -0.513932, -0.493989, -1.09225, -0.675002, -0.046062, -0.046062])names3.append(\"RWristYaw\")times3.append([0.48, 1, 1.48, 2, 3, 4.28, 5.48, 6.8, 8.08, 9.16, 10.68, 11.8])keys3.append([1.13665, 1.34834, 1.12438, 1.82387, 1.25784, 1.13512, 1.16887, 1.13512, 1.47567, 1.22716, 1.67969, 1.66588])names4 = list()times4 = list()keys4 = list()names4.append(\"HeadPitch\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([0.133416, 0.131882, -0.142704, -0.142704, -0.142704, 0.12728, -0.142704, -0.142704])names4.append(\"HeadYaw\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([0.0199001, -0.305308, 0.00916195, 0.00916195, 0.00916195, -0.0399261, 0.00916195, 0.00916195])names4.append(\"LAnklePitch\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([0.0919981, 0.08126, 0.0858622, 0.0858622, 0.0858622, 0.0919981, 0.0413761, 0.0858622])names4.append(\"LAnkleRoll\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([-0.128814, -0.128814, -0.131882, -0.131882, -0.131882, -0.128814, -0.121144, -0.131882])names4.append(\"LElbowRoll\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([-1.38363, -1.38363, -1.26551, -1.27471, -0.0904641, -0.0659201, -0.049046, -0.049046])names4.append(\"LElbowYaw\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([-1.3607, -1.3607, -2.07554, -2.07554, -2.08567, -0.446436, -0.42496, -0.441834])names4.append(\"LHand\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([0.2892, 0.2892, 0.2932, 0.2932, 0.2932, 0.2892, 0.2932, 0.2932])names4.append(\"LHipPitch\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([0.131966, 0.131966, 0.130432, 0.130432, 0.130432, 0.131966, -0.31903, 0.130432])names4.append(\"LHipRoll\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([0.096684, 0.096684, 0.090548, 0.090548, 0.090548, 0.0997519, 0.024586, 0.090548])names4.append(\"LHipYawPitch\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([-0.170232, -0.170232, -0.171766, -0.171766, -0.171766, -0.167164, -0.268408, -0.171766])names4.append(\"LKneePitch\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([-0.0828779, -0.0828779, -0.0859461, -0.0859461, -0.0859461, -0.0828779, -0.0859461, -0.0859461])names4.append(\"LShoulderPitch\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([1.49561, 1.49561, 1.50635, 0.662646, 0.673384, 1.44192, 1.36982, 1.43271])names4.append(\"LShoulderRoll\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([-0.131966, -0.131966, 0.285282, 1.12745, 1.0891, 0.099668, 0.161028, 0.107338])names4.append(\"LWristYaw\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([-1.7396, -1.7396, -1.67977, -1.67977, -1.68284, -1.39138, -1.37604, -1.40825])names4.append(\"RAnklePitch\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([0.0890141, 0.0890141, 0.092082, 0.092082, 0.092082, 0.09515, 0.093616, 0.092082])names4.append(\"RAnkleRoll\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([0.122762, 0.122762, 0.130432, 0.130432, 0.130432, 0.119694, 0.128898, 0.130432])names4.append(\"RElbowRoll\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([1.33922, 1.32849, 1.33616, 1.34843, 0.268492, 0.23321, 0.21787, 0.217869])names4.append(\"RElbowYaw\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([1.48334, 2.07086, 2.08567, 2.07546, 2.08567, 0.431012, 0.506178, 0.423342])names4.append(\"RHand\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([0.2916, 0.2916, 0.2864, 0.2864, 0.2864, 0.2916, 0.2864, 0.2864])names4.append(\"RHipPitch\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([0.118076, 0.118076, 0.118076, 0.118076, 0.118076, 0.124212, -0.415756, 0.118076])names4.append(\"RHipRoll\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([-0.102736, -0.102736, -0.0950661, -0.0950661, -0.0950661, -0.10427, -0.0674541, -0.095066])names4.append(\"RHipYawPitch\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([-0.170232, -0.170232, -0.171766, -0.171766, -0.171766, -0.167164, -0.268408, -0.171766])names4.append(\"RKneePitch\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([-0.0889301, -0.0889301, -0.0919981, -0.0919981, -0.0919981, -0.078192, -0.0919981, -0.0812599])names4.append(\"RShoulderPitch\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([1.47115, 1.49262, 1.48956, 0.89283, 0.89283, 1.50643, 1.32542, 1.5141])names4.append(\"RShoulderRoll\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([0.139552, -0.216336, -0.23321, -1.19963, -1.0539, -0.200996, -0.250084, -0.211735])names4.append(\"RWristYaw\")times4.append([1.36, 2.68, 4, 5.36, 6.8, 8.28, 9.6, 10.8])keys4.append([1.66588, 1.4726, 1.44038, 1.3913, 1.70883, 1.52475, 1.50941, 1.50941])part1 = DancePart(10, 3, names1, times1, keys1)part2 = DancePart(8, 2, names2, times2, keys2)part3 = DancePart(13, 4, names3, times3, keys3)part4 = DancePart(12, 0, names4, times4, keys4)parts = [part1, part2, part3, part4]waltz = Dance(\"Waltz\", 4, parts) &emsp;&emsp;具体调用：123456789101112131415from naoqi import ALProxyimport waltzDanceimport timemotion = ALProxy(\"ALMotion\", NaoIP, Port)def dance(danceName): for i in range(danceName.get_num_parts()): motion.angleInterpolation(danceName.get_part(i).get_names(), danceName.get_part(i).get_keys(), danceName.get_part(i).get_times(), True) # time.sleep(danceName.get_part(i).get_pause_length()) time.sleep(0.3)waltz = waltzDance.waltzdance(waltz) &emsp;&emsp;当然也可以设计其他的舞蹈动作。 多线程实现边唱歌边跳舞利用python实现&emsp;&emsp;python中有专门的多线程模块threading，我们可以把跳舞作为主线程，唱歌作为一个子线程，在跳舞的同时，开启一个线程专门来播放音频，即可实现边唱歌边跳舞。&emsp;&emsp;首先创建个线程的对象，然后用start()函数来开启该线程。123import threadingmythread = threading.Thread(target=function_name, args=(function_parameter1, ))mythread.start() &emsp;&emsp;创建对象时，第一个参数是目标函数的函数名(不是调用，不需要加括号)，第二个参数是目标函数的参数，是可选参数，用元组的形式将参数封装起来，如果只有1个参数，后面的逗号不可以省略。然后调用start()开启线程。1234t1 = threading.Thread(target=playMusic)t1.start()dance.dance(waltz) 利用模块的post属性实现&emsp;&emsp;除了python的多线程可以实现此功能之外，ALAudioPlayer类中的post属性也可以实现。&emsp;&emsp;在NAOqi模块的一些持续性动作的类中，比如播放音频的ALAudioPlayer类的playFile()，运动类ALMotion中的moveTo()，都有一个post属性。所谓post属性就是将这个持续性动作的进程挂起，NAO可以在执行这个进程的同时进行其他的操作。其调用方式为在playFile()函数前加上.post。123audio = ALProxy(\"ALAudioPlayer\", '169.254.67.213', 9559)songfile = \"/home/nao/test/test_wav.wav\" audio.post.playFile(songfile) &emsp;&emsp;在post语句下面可以添加其他的功能，此时NAO会一直播放音频文件，并执行下面的语句，直到音频文件播放完毕。例如实现边跳舞边唱歌，只需在playFile()函数前加上post，然后在下面调用dance()函数。123def danceAndSong(danceName, songName): audio.post.playFile(songName) dance() &emsp;&emsp;除了播放音频的库可以加post之外，行走库中的moveTo()也可以，即可以实现边行走边执行其他的模块，比如边行走边调用NAO的视觉系统，例如我的另一篇博客：NAO高尔夫比赛：python初级版。 开机自启动边跳舞边唱歌&emsp;&emsp;如果想实现开机自启动某个程序，需要更改NAO的开机启动配置文件，其文件路径为/home/nao/naoqi/preferences/autoload.ini。使用Choregraph软件或者WinSCP软件将其下载到本地计算机中，然后使用VScode或其他编译器软件打开，找到其中的[python]，然后将需要启动的py文件路径放在下一行，重新启动NAO机器人就会自动执行该文件。&emsp;&emsp;需要将python文件中的IP地址改为NAO的本地IP，即&quot;127.0.0.1&quot;。 附：Choregraph实现开机自启动&emsp;&emsp;首先新建一个项目文件，编写代码。例如我写了一个说“hello world”的程序，命名为hello。&emsp;&emsp;然后保存并上传到机器人系统中，上传功能在应用程序视图。&emsp;&emsp;在应用程序中找到你的文件，并右击设置为默认状态。会出现一个小旗子。最后重启机器人，就会进入你写的程序中。&emsp;&emsp;注：NAO机器人开机后会进入自主模式，即开机后会站立并来回晃动。这个好像去不掉，可以在你写的代码里面进行处理。我实际测试下来，需要等待一段时间才会进入到开机自启动的项目中。","categories":[{"name":"NAO开发与应用","slug":"NAO开发与应用","permalink":"http://cxx0822.github.io/categories/NAO开发与应用/"}],"tags":[]},{"title":"西瓜数据集的分类：贝叶斯，决策树","slug":"西瓜数据集的分类：贝叶斯，决策树","date":"2018-12-28T03:19:11.000Z","updated":"2022-03-21T06:19:13.101Z","comments":true,"path":"2018/12/28/xi-gua-shu-ju-ji-de-fen-lei-bei-xie-si-jue-ce-shu/","link":"","permalink":"http://cxx0822.github.io/2018/12/28/xi-gua-shu-ju-ji-de-fen-lei-bei-xie-si-jue-ce-shu/","excerpt":"","text":"原始数据集123456789101112131415161718色泽 根蒂 敲声 纹理 脐部 触感 好瓜青绿 蜷缩 浊响 清晰 凹陷 硬滑 是乌黑 蜷缩 沉闷 清晰 凹陷 硬滑 是乌黑 蜷缩 浊响 清晰 凹陷 硬滑 是青绿 蜷缩 沉闷 清晰 凹陷 硬滑 是浅白 蜷缩 浊响 清晰 凹陷 硬滑 是青绿 稍蜷 浊响 清晰 稍凹 软粘 是乌黑 稍蜷 浊响 稍糊 稍凹 软粘 是乌黑 稍蜷 浊响 清晰 稍凹 硬滑 是乌黑 稍蜷 沉闷 稍糊 稍凹 硬滑 否青绿 硬挺 清脆 清晰 平坦 软粘 否浅白 硬挺 清脆 模糊 平坦 硬滑 否浅白 蜷缩 浊响 模糊 平坦 软粘 否青绿 稍蜷 浊响 稍糊 凹陷 硬滑 否浅白 稍蜷 沉闷 稍糊 凹陷 硬滑 否乌黑 稍蜷 浊响 清晰 稍凹 软粘 否浅白 蜷缩 浊响 模糊 平坦 硬滑 否青绿 蜷缩 沉闷 稍糊 稍凹 硬滑 否 &emsp;&emsp;数据集的第一行为特征和分类标题。一共有6个特征，17组数据，分类标签为是否为好瓜。每个数据用空格隔开。 贝叶斯算法准备数据集&emsp;&emsp;由于贝叶斯算法需要计算类别概率，所以在原始数据集中需要将文字的’是’和’否’改写为’1’和’0’。程序实现：12345678910def file2dataSet(filename): postingList = [] classVec = [] with open(filename) as fr: next(fr) # 跳过第一行 for line in fr.readlines(): line = line.strip().split(' ') postingList.append(line[:-1]) classVec.append(eval(line[-1])) # 去掉字符串的双引号 return postingList, classVec &emsp;&emsp;首先创建一个存储特征和分类的空列表，然后使用with语句打开文件。由于第一行是标题，所以要跳过该行，next()函数返回可迭代对象的下一个值。&emsp;&emsp;然后用strip()函数将原始数据集中的空白，换行符等都删掉。原始数据集是用空格隔开的，所以可用split(‘ ‘)函数将其分隔开，然后将特征和分类标签分别添加到特征和分类的列表中。&emsp;&emsp;line[:-1]表示特征，line[-1]表示标签，因为字符串返回的标签值会带有单引号，不可进行求和运算，eval()函数会把字符串当成有效的表达式来求值并返回计算结果，即可以去掉字符串的引号。 测试数据&emsp;&emsp;假设有1组西瓜数据：’青绿’, ‘蜷缩’, ‘浊响’, ‘清晰’, ‘凹陷’, ‘硬滑’，利用贝叶斯进行分类预测。&emsp;&emsp;贝叶斯算法可参照之前的博客。程序实现：12345678910111213if __name__ == '__main__': data, labels = file2dataSet(\"xiguaData.txt\") myVocabList = createVocabList(data) trainMat = [] for doc in data: trainMat.append(setOfWords2Vec(myVocabList, doc)) p0V, p1V, pAb = trainNBO(trainMat, labels) testEntry = &#123;'青绿', '蜷缩', '浊响', '清晰', '凹陷', '硬滑'&#125; thisDoc = array(setOfWords2Vec(myVocabList, testEntry)) result = classifyNB(thisDoc, p0V, p1V, pAb) print(testEntry, \" is classified as :\", result) &emsp;&emsp;首先利用之前的训练算法得到贝叶斯概率模型，然后将输入的数据转换为分类算法所需要的特征个数列表，即thisDoc，然后将其和概率模型得到的特征概率列表进行运算预测，最终其结果为属于’1’分类，即’好瓜’分类。 决策树算法准备数据集&emsp;&emsp;决策树算法的数据集分为两部分，一部分为已知分类类别的数据，另一部分为所有的特征标题，即[‘色泽’, ‘根蒂’, ‘敲声’, ‘纹理’, ‘脐部’, ‘触感’]。程序实现：12345678910def file2dataSet(filename): dataSet = [] with open(filename) as fr: next(fr) # 跳过第一行 for line in fr.readlines(): line = line.strip().split(' ') dataSet.append(line) labels = ['色泽', '根蒂', '敲声', '纹理', '脐部', '触感'] return dataSet, labels &emsp;&emsp;将原始数据集中的每行数据添加到dataSet中。这里的label是特征标签，不是分类标签。决策树是根据特征的熵来选择最佳分类的。 测试数据集&emsp;&emsp;还是之前的测试数据’青绿’, ‘蜷缩’, ‘浊响’, ‘清晰’, ‘凹陷’, ‘硬滑’，利用决策树进行分类预测。&emsp;&emsp;决策树算法可参照之前的博客。&emsp;&emsp;首先编写一个预测函数：程序实现：1234567891011def classify(inputTree, featLabels, testVec): firstStr = list(inputTree.keys())[0] secondDict = inputTree[firstStr] featIndex = featLabels.index(firstStr) for key in secondDict.keys(): if testVec[featIndex] == key: if type(secondDict[key]).__name__ == 'dict': classLabel = classify(secondDict[key], featLabels, testVec) else: classLabel = secondDict[key] return classLabel &emsp;&emsp;函数有3个参数，生成好的决策树，特征值和待预测的数据。函数使用了递归调用的方法。&emsp;&emsp;首先获得已知决策树的第一个健的值，即决策树的第一个分类特征，然后获得基于该特征的子树，并对应的找到对于待预测数据的特征是什么值，即判断下面要进入到哪一个子树。然后在判断现在的子树是叶子节点还是仍然是一个决策树，如果仍然是一个决策数，则递归调用自己，直到是叶子节点为止，即往下一层层分类，直到找到最终的叶子节点，也就分类完成了。&emsp;&emsp;代入具体的测试数据验证：程序实现：1234567if __name__ == '__main__': dataSet, labels = file2dataSet(\"xiguaData.txt\") mytree = createTree(dataSet, labels) print(mytree) testVec = ['青绿', '蜷缩', '浊响', '清晰', '凹陷', '硬滑'] labels = ['色泽', '根蒂', '敲声', '纹理', '脐部', '触感'] classLabel = classify(mytree, labels, testVec) &emsp;&emsp;首先根据之前的决策树算法得到决策树模型，即{‘纹理’: {‘模糊’: ‘否’, ‘清晰’: {‘根蒂’: {‘稍蜷’: {‘色泽’: {‘乌黑’: {‘触感’: {‘软粘’: ‘否’, ‘硬滑’: ‘是’}}, ‘青绿’: ‘是’}}, ‘硬挺’: ‘否’, ‘蜷缩’: ‘是’}}, ‘稍糊’: {‘触感’: {‘软粘’: ‘是’, ‘硬滑’: ‘否’}}}} ，然后将待预测数据写出列表形式，并进行预测分类。此时需要将特征标签重新写一遍(之前训练决策树模型的时候删掉了一个特征)，然后代入之前的预测函数，最终得到的结果为”是”好瓜。和实际的结果也是一致的。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://cxx0822.github.io/categories/机器学习/"}],"tags":[]},{"title":"贝叶斯算法","slug":"贝叶斯算法","date":"2018-12-24T01:16:23.000Z","updated":"2022-03-31T11:43:53.378Z","comments":true,"path":"2018/12/24/bei-xie-si-suan-fa/","link":"","permalink":"http://cxx0822.github.io/2018/12/24/bei-xie-si-suan-fa/","excerpt":"","text":"贝叶斯算法一、基本原理&emsp;&emsp;贝叶斯算法属于有监督的学习算法，即原始数据集是已知的，其主要思想为根据在一定特征下属于哪个类别的条件概率大小来判断分类。&emsp;&emsp;条件概率是指事件A在另外一个事件B已经发生条件下的发生概率,记为P(A|B),B为条件，A为需要计算的概率。其计算公式为：P(A|B)=P(AB)/P(B),但一般来说A,B事件不是独立事件，即P(AB)不等于P(A)P(B)，所以一般用贝叶斯公式将其展开，即：&emsp;&emsp;对应于分类算法的意义，该公式可以表示为：&emsp;&emsp;P(类别|特征)：在一定特征下属于该类别的概率，即我们最终用来判断分类的概率。P(特征|类别)：在该类别下的特征概率。即在已知类别的情况下，每个特征出现的频数除以总的特征数。P(类别)：数据集中的每个类别的概率，即每个类别的次数除以数据集的总个数。P(特征)：特征的概率，由于数据集是一样的，其特征也一样，计算概率时，可忽略该项。&emsp;&emsp;哪个分类的条件概率大就判定为哪个类别，这也是贝叶斯算法的核心思想。其计算公式中最重要的部分就是每个特征的在对应类别下的概率。有多少个特征就要进行多少次计算，这里我们假设每个特征都是相互独立的，即任意2个特征都不相互影响分类结果，这也称为朴素贝叶斯算法。 二、算法实现（文本分类）&emsp;&emsp;对一个在线社区的留言板内容构建一个过滤器，如果某条留言使用了负面的语言，则将该留言标识为内容不当。&emsp;&emsp;首先需要将文本转换为数字向量以便为标识，然后基于这些向量来计算条件概率(贝叶斯算法)并在此基础上构建分类器。 准备数据&emsp;&emsp;首先将获得的每句话的文本数据存在于列表中，然后将所有的文本数据整合到一个列表中，此时列表中的所有单词元素应该是唯一的。最后创建一个文档向量，向量的每一个元素为1或0，分别表示词汇表中的单词在输入单词列表中是否存在。&emsp;&emsp;此时单词列表中的单词就是数据集的特征，即1个单词对应1个特征。程序实现：123456789def loadDataSet(): postingList = [['my', 'dog', 'has', 'flea', 'problems', 'help', 'please'], ['maybe', 'not', 'take', 'him', 'to', 'dog', 'park', 'stupid'], ['my', 'dalmation', 'is', 'so', 'cute', 'I', 'love', 'him'], ['stop', 'posting', 'stupid', 'worthless', 'garbage'], ['mr', 'licks', 'ate', 'my', 'steak', 'how', 'to', 'stop', 'him'], ['quit', 'buying', 'worthless', 'dog', 'food', 'stupid']] classVec = [0, 1, 0, 1, 0, 1] return postingList, classVec 程序说明：&emsp;&emsp;postingList为文本数据。首先将每句话存放在一个列表中，然后将每个单词用逗号隔开。classVec为已知的分类标签，即事先对每句话划分好的标签。0表示这句话是正面的，1表示负面的。 123456def createVocabList(dataSet): vocabSet = set([]) # 遍历输入数据集中的每一句话 for document in dataSet: vocabSet = vocabSet | set(document) return list(vocabSet) &emsp;&emsp;createVocabList()函数生成一个包含所有数据集的单词列表，且列表中的单词都是唯一的。&emsp;&emsp;首先创建一个空列表，set()函数保证了其唯一性，然后分别将此与数据集中每一句的单词列表进行’与’操作，即将数据集的每句话中不重复的单词添加到空列表中。123456789def setOfWords2Vec(vocabList, inputSet): returnVec = [0] * len(vocabList) for word in inputSet: # 如果输入数据集中的单词在单词列表中则记为1 if word in vocabList: returnVec[vocabList.index(word)] = 1 else: print(\"the word: %s is not in my Vocabulary!\" % word) return returnVec &emsp;&emsp;setOfWords2Vec()创建一个文档向量。该函数对输入的数据中的每个单词进行搜索，如果该单词在单词列表中，则记为1。1234listOPosts, listClasses = loadDataSet()myVocabList = createVocabList(listOPosts)returnVec_0 = setOfWords2Vec(myVocabList, listOPosts[0])returnVec_1 = setOfWords2Vec(myVocabList, listOPosts[1]) 程序输出为：123['to', 'how', 'dog', 'ate', 'park', 'is', 'food', 'my', 'steak', 'flea', 'take', 'problems', 'buying', 'I', 'mr', 'love', 'posting', 'not', 'garbage', 'maybe', 'licks', 'dalmation', 'cute', 'please', 'quit', 'stop', 'help', 'him', 'stupid', 'so', 'worthless', 'has'][0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1][1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0] &emsp;&emsp;myVocabList就是单词列表，也就是该数据集的所有特征。第1个文档向量的输入数据为第1句话，第1个元素’0’表示’to’这个单词没有在第1句话出现，第2个文档向量的输入数据为第2句话，第1个元素’1’表示’to’这个单词在第2句话中有出现。&emsp;&emsp;一共有6组数据列表，每个列表的长度即单词列表的长度，即不重复单词的个数，也就是数据集的特征总数。 训练算法&emsp;&emsp;得到数据集的每组特征后，便可以利用贝叶斯的条件概率公式训练算法。其计算公式可以改写为：&emsp;&emsp;w表示特征，c表示分类。对每个类别都进行计算，最后比较对应的概率值大小就可以判断其分类。&emsp;&emsp;p(c)表示类别出现的概率，即在原始数据集中每个类型出现的概率。例如在数据集的6句话中，负面评论共3次，则类别0的概率为3/6=0.5。&emsp;&emsp;p(w|c)表示在该类别下该特征的频率。即在已知类别的情况下，每个特征出现的概率。由于原始数据集不仅只有1个特征，所以需要对每个特征进行计算并求积。即：&emsp;&emsp;每个特征的概率计算方法为：每个特征在某个类别下出现的次数/该类别下的总特征数。程序实现：12345678910111213141516171819def trainNBO(trainMatrix, trainCategory): numTrainDocs = len(trainMatrix) # 输入文档的长度，即共有几组数据 numWords = len(trainMatrix[0]) # 单词的个数，即每组数据有多少个单词 pAbusive = sum(trainCategory) / float(numTrainDocs) # 是负面标签的概率 p0Num = ones(numWords) p1Num = ones(numWords) p0Denom = 0.0 p1Denom = 0.0 for i in range(numTrainDocs): if trainCategory[i] == 1: # 计算当类别标签为1时，各个单词出现的次数 p1Num += trainMatrix[i] # 标签为1的类别下，每个单词出现的次数+1 p1Denom += sum(trainMatrix[i]) # 标签为1的类别下，单词在单词表中出现的总次数 else: p0Num += trainMatrix[i] p0Denom += sum(trainMatrix[i]) p1Vect = p1Num / p1Denom p0Vect = p0Num / p0Denom return p0Vect, p1Vect, pAbusive 程序说明：&emsp;&emsp;首先对所有的标签进行求和，并除以总的文档长度，得到概率p(c)。因为负面的记1，正面记0，所以求得的和即是负面标签的总数。然后初始化类别概率为0。在计算每个特征的概率时，首先要对类别进行判断，当满足该类别时，对其特征进行求和，即单词在单词列表中出现的次数，因为是用’1’和’0’来标记的，所以直接求和即可，同时也需要计算总的特征数，即在类别下单词在单词列表中出现的总次数。最后计算出概率。程序验证：123456listOPosts, listClasses = loadDataSet()myVocabList = createVocabList(listOPosts)trainMat = []for postinDoc in listOPosts: trainMat.append(setOfWords2Vec(myVocabList, postinDoc))p0V, p1V, pAb = trainNBO(trainMat, listClasses) 1234567891011121314myVocabList ['flea', 'licks', 'please', 'garbage', 'love', 'how', 'cute', 'park', 'my', 'dalmation', 'dog', 'so', 'mr', 'posting', 'stop', 'has', 'steak', 'ate', 'not', 'buying', 'help', 'maybe', 'worthless', 'quit', 'to', 'I', 'him', 'stupid', 'food', 'problems', 'take', 'is']p0V [0.04166667 0.04166667 0.04166667 0. 0.04166667 0.04166667 0.04166667 0. 0.125 0.04166667 0.04166667 0.04166667 0.04166667 0. 0.04166667 0.04166667 0.04166667 0.04166667 1. 0. 0.04166667 0. 0. 0. 0.04166667 0.04166667 0.08333333 0. 0. 0.04166667 0. 0.04166667]p1V [0. 0. 0. 0.05263158 0. 0. 1. 0.05263158 0. 0. 0.10526316 0. 2. 0.05263158 0.05263158 0. 0. 0. 0.05263158 0.05263158 0. 0.05263158 0.10526316 0.05263158 0.05263158 0. 0.05263158 0.15789474 0.05263158 0. 0.05263158 0. ]pAb 0.5 &emsp;&emsp;例如在该数据集中，在已知的单词表中，’flea’在正面的评论中出现1次，正面评论的总特征数为24，所以概率为1/24=0.041，而在负面评论中出现0次，所以概率为0。负面评论中概率最大的单词为’stupid’，共出现3次，负面评论的总特征数为19，概率为3/19=0.15，即’stupid’是最能表征负面评论的特征。 测试算法&emsp;&emsp;对原始数据集进行贝叶斯算法训练得到其模型后，便可以根据实际的输入数据进行预测分类了。&emsp;&emsp;但现在会出现一个问题，当计算多个特征概率的乘积以获得某个类别的概率时，如果其中一个特征的概率为0，则最后的乘积也是0。为了解决这个问题，可以将所有特征出现的次数初始化为1，并将分母初始化为2。其次当多个特征的概率很小时，其乘积会越来越小，从而会影响数值的精度，为此，可以用取对数的方法，将乘积转换为求和。训练算法程序改写为：1234567p0Num = ones(numWords)p1Num = ones(numWords)p0Denom = 2.0p1Denom = 2.0...p1Vect = log(p1Num / p1Denom)p0Vect = log(p0Num / p0Denom) 测试算法程序123456789101112131415161718192021def classifyNB(vec2Classify, p0vec, p1Vec, pClass1): # 利用贝叶斯公式计算概率 p1 = sum(vec2Classify * p1Vec) + log(pClass1) p0 = sum(vec2Classify * p0vec) + log(1.0 - pClass1) if p1 &gt; p0: return 1 else: return 0def testingNB(): listOPosts, listClasses = loadDataSet() myVocabList = createVocabList(listOPosts) trainMat = [] for postinDoc in listOPosts: trainMat.append(setOfWords2Vec(myVocabList, postinDoc)) p0V, p1V, pAb = trainNBO(trainMat, listClasses) # 输入的新数据 testEntry = &#123;'love', 'my', 'dalmation'&#125; thisDoc = array(setOfWords2Vec(myVocabList, testEntry)) classifyNB(thisDoc, p0V, p1V, pAb) 程序说明：&emsp;&emsp;classifyNB()函数有4个输入，待输入的新数据在特征列表中每个特征出现的次数，训练模型得到的类别0和类别1的特征概率和类别0的概率。因为是二分类，所以类别1的概率=1-类别0的概率。&emsp;&emsp;首先按照类别，将新数据的每个特征出现的次数与其类别的特征概率进行相乘相加，然后加上对应类别的概率，最后根据总的概率大小来判断分类。 三、感悟 贝叶斯算法属于有监督的预测算法，根据原始数据集训练出概率模型，然后对新的数据集进行预测。 贝叶斯算法训练的概率模型是基于贝叶斯公式的，由于数据集存在多个特征，需要对每个类别下的特征进行概率计算。 计算每个类别的特征概率时，用该类别下每个特征出现的概率除以该类别下出现的总特征个数，而不是全部类别下的总特征个数，即存在有些特征是该类别没有的。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://cxx0822.github.io/categories/机器学习/"}],"tags":[]},{"title":"C++笔记","slug":"C++笔记","date":"2018-12-20T08:29:42.000Z","updated":"2022-03-31T11:39:40.029Z","comments":true,"path":"2018/12/20/c-bi-ji/","link":"","permalink":"http://cxx0822.github.io/2018/12/20/c-bi-ji/","excerpt":"","text":"第1章 预备知识 C++融合了3种不同的编程方式：C语言代表的过程性语言、C++在C语言基础上添加的类代表的面向对象语言、C++模板支持的泛型编程。 面向过程强调算法，面向对象强调数据。类是一种规范，它描述了这种新型数据格式，对象是根据这种规范构造的特定数据结构。即类是抽象的，对象是具体的。类是模板，对象是实例。 第2章 开始学习C++ C++能够使用printf()、scanf()和其他所有标准C输入和输出函数，只需要包含常规C语言的stdio.h文件。 namespace的使用方法：using namespace std;&emsp; 所有的名称都可以使用using std::cout; &emsp;&emsp;&emsp;&emsp;只使用std里面的cout。 类是用户定义的一种数据类型。 C++程序应当为程序中使用的每个函数提供原型。C++不允许将函数定义嵌套在另一个函数定义中。 main()函数的返回值返回给操作系统。即返回1则程序正确执行。 第3章 处理数据 面向对象编程(OOP)的本质是设计并扩展自己的数据类型。 基本类型：整数和浮点数； 复合类型：数组、字符串、指针和结构。 最小长度：short：16位；int：至少与short一样长；long：至少32位，且至少与int一样长；long long：至少64位，且至少与long一样长。（1个字节8位） 整数相加减时，如果超越了限制，其值将为范围另一端的取值。例：unsigned short类型的0-1将得到65535。 cin只接受输入流中的第一个字符，其余字符会继续存放在流中，后续可以使用。 浮点数在计算机中分成两部分存储，一部分表示值，另一部分用于对值进行放大和缩小。 浮点数的缺点： 浮点数运算的速度比整数的慢，并且精度会降低。例： 123float a = 2.34E+22f;float b = a + 1.0f;cout &lt;&lt; b - a &lt;&lt; endl; &emsp;&emsp;输出的结果应为1，但实际的输出值为0。因为a是一个小数点左边有23位的数字，加上1，即在第23位加1，而float类型只能表示数字中的前6位或前7位，即有效位为6或7，因此修改第23位对这个值并没有任何影响。&emsp;&emsp;对于float，C++只能保证6位有效位。 C++会自动执行很多类型转换，但当较大整型转换为较小的整型时，原来的值 可能超出目标类型的取值范围，通常只复制右边的字节，即高位将被截掉。例： 12int a = 7.2E12;cout &lt;&lt; a &lt;&lt; endl; &emsp;&emsp;由于a的值超过了int的最大取值范围，因此在某些操作系统上，得到的值为2147483647(int类型的最大值)。 C++类型转换：typeName(value) 第4章 复合类型 只有在定义数组时才能使用初始化，初始化时可以省略等号，不能将一个数组赋给另一个数组。如果只对数组的一部分初始化，则其他位置为0，如果初始化数组时，方括号内为空，则编译器会计算元素个数。例： 1short a[] = &#123;1, 2, 3, 4&#125;; &emsp;&emsp;编译器会计算short型数组包含4个元素。&emsp;&emsp;short指定了类型，a表示变量名，[]表明是一个数组。 字符串与字符数组 12char NJUT[4] = &#123;'n', 'j', 'u', 't'&#125;;char NJUT_2[5] = &#123;'n', 'j', 'u', 't', '\\0'&#125;; &emsp;&emsp;这2个数组都是char数组，但只有第2个是字符串。即字符串必须是以’\\0’结尾的字符数组。对于第2个字符数组，cout会打印’njut’，即遇到’\\0’则停止，但对于第1个，会一直打印，直到遇到内存中有’\\0’为止。&emsp;&emsp;还有1种更简单的方法是用一个引号将这些字符括起来，即1char NJUT[] = \"njut\"; &emsp;&emsp;这种称为字符串常量，编译器会自动将’\\0’加上。”njut”指的是字符串所在的内存地址。 123char name[10] = \"cxx\";cout &lt;&lt; strlen(name);cout &lt;&lt; sizeof(name); &emsp;&emsp;strlen()返回的是存储在数组中的字符串的个数，即可见的字符个数，因此该返回值为3，而sizeof()计算的是整个数组的长度。如果要存储一个字符串，则数组的长度至少是strlen(字符串)+1。 cin、cin.getline()和cin.get()cin：使用空白(空格，制表符和换行符)来确定字符串的结束位置。所以cin只能1次读取1个单词(遇到空格会结束)，剩下的部分会继续存放在cin流中，直到下次的读取。cin.getline(name,size)：函数读取整行，通过换行符确定字符串的结束位置，第1个参数为用来存储输入的数组名称，第2个为要读取的字符串的字符数，其值为size-1，即最后1位用于字符串结尾的空字符。cin.get()：其中一种形式get(name,size)和getline(name,size)类似，都读到行尾，但get()不会读取并丢弃换行符，而是会留在输入流中，这样就会存在一个问题，例：12cin.get(name1, 10);cin.get(name2, 10); &emsp;&emsp;当读完第1个名字后，由于get()并不会丢弃换行符，所以第2次读取的时候会直接读到换行符，从而会认为已经到达行尾，不会读取任何字符。为了避免这个问题，可以采用无参数的get()函数，即cin.get()，该函数读取下一个字符(换行符也可以)，即采用下面的方法：123cin.get(name1, 10);cin.get()cin.get(name2, 10); &emsp;&emsp;也可以将这2个函数拼在一起，即cin.get(name1, 10).get()。 string对象和字符数组之间的主要区别是：可以将string对象声明为简单变量，而不是数组。12string name;string name = \"cxx\"; &emsp;&emsp;string相当于一个类，字符串相当于类的实例化，不需要在string后面加上长度。 创建结构体时首先要创建一个模板。例 1234567891011struct inflatable&#123; char name[20]; float volume;&#125;;inflatable guest = &#123; \"Glorious Gloria\"; 1.88;&#125;; &emsp;&emsp;前一个为结构体的声明，后一个为结构体的赋值。结构体相当于用户自定义的一种结构类型。struct指定了类型为结构体，inflatable为这种新类型的名称。大括号的内容为结构体的成员。整体相当于一个对象的模板，后面的则是对象的实例化，guest为结构体的名称，其具体内容为大括号里面的内容。&emsp;&emsp;注意，不管是声明还是赋值，都是C++的语句，需要加分号结束。 可以创建多个值相同的枚举量 1enum number &#123;first, second, third = 1. forth = 100, fifth&#125;; &emsp;&emsp;first在默认情况下为0，second和third都为1，fifth为101。枚举也相当于一个数据类型，初始化相当于模板，使用时需要先实例化，在调用里面的枚举值，即：12number mynumber;mynumber = first; &emsp;&emsp;类似于const限定符。 只有初始化指针时，才会出现*=&amp;，其他情况，*指的是解除引用，即取出地址存放的值，&amp;指的是地址运算符，即获得变量存在的地址。 12int a = 5;int * pt = &amp;a; &emsp;&emsp;相当于12int * pt;pt = &amp;a; &emsp;&emsp;int指定了类型为整型，pt是变量名，*表明是指针，和数组，结构体类似，指针也是个复合类型，需要同基本类型同时使用，即pt是一个整型的指针类型。&emsp;&emsp;指针指的是地址，只有在初始化时才可以将*和&amp;同时使用，否则指针变量后面的赋值一定是某个地址。 在对指针变量使用解除引用运算符(*)之前，一定要将指针初始化为一个确定的，适当的地址。否则指针将找不到该地址，将错误的地址，甚至是正在运行的程序地址返回并执行操作。 一定要配对的使用new和delete，否则会发生内存泄漏。delete只能删除new创建的指针。 指针和字符串 12char flower[10] = \"rose\";cout &lt;&lt; flower &lt;&lt; \"s are red.\\n; &emsp;&emsp;如果给cout提供一个字符的地址，则将从这个字符开始打印，直到遇到空字符为止。 指针与数组、字符串、结构体123456789101112double wages[3] = &#123;100.0, 200.0, 300.0&#125;;double * p1 = wages;char animal[10] = \"bear\";char * p2 = animal;struct info&#123; int year;&#125;;info s01;info * p3 = &amp;s01; &emsp;&emsp;指针在初始化时，后面需要赋值一个地址，数组名和字符串常量都是地址，所以不需要再加上取地址符。 vector和array123456vector&lt;typename&gt; vt(n_elem);array&lt;typename, n_elem&gt; arr;double a1[4] = &#123;1.2, 2.3, 3.4, 4.5&#125;;vector&lt;double&gt; a2(4);array&lt;double, 4&gt; a3 = &#123;1.2, 2.3, 3.4, 4.5&#125;; &emsp;&emsp;使用vector和array，需要添加头文件#include和#include，且都可以使用标准的数组索引访问数组中的元素。 new创建指针1typeName * pointer_name = new typeName; 第5章 循环和关系表达式 for循环：1234for (初始化;测试语句;更新语句)&#123; 主体;&#125; &emsp;&emsp;测试语句可以是任意表达式，C++会将结果强制转换为bool类型。&emsp;&emsp;C++中，在for和括号之间加上一个空格，以区别函数名和括号。 1cout.setf(ios_base::boolalpha); &emsp;&emsp;设置显示为布尔值。 第6章 分支语句和逻辑运算符 c++有if - else if - else 结构 isalpha()：测试字符是否为字母字符，isdigits()：测试字符是否为数字字符，isspace()：测试字符是否为空白(换行符，空格和制表符)，ispunct()：测试字符是否为标点符号。 第7章 函数 如果声明的返回值类型为double，而函数返回一个int表达式，则该int值会将强制转换为double类型。 C++的返回值不可以是数组，但可以将数组作为结构或对象组成部分来返回。 在函数中使用指针来处理数组 12int sum_arr(int * arr, int n); //函数原型int sum = sum_arr(cookies, 10); //函数调用 &emsp;&emsp;这里的cookies为数组名，表示数组中第一个元素的地址，而函数原型中，* arr表示的也是地址，当然也可以用arr[]替换，因为在c++中，当且仅当用于函数头或函数原型中，* arr 和 arr[]的含义是相同的。&emsp;&emsp;在使用数组名作为参数时，并没有将数组的全部内容传递给函数，而是将数组的地址，包含的元素类型以及数目传递给函数，这样会大大减少内存空间。 指针常量和常量指针12const int * pt = &amp;age; //常量指针int * const finger = &amp;sloth; //指针常量 &emsp;&emsp;变量名左边是变量的类型，当有多个类型修饰时，看最近的。&emsp;&emsp;变量pt最左边是*，代表的是指针，再往左是int，表明基本类型为整型，最左边是const，表明其值是一个常量。所以pt首先是一个指针，其存放的内容是变量age的地址，地址指向的是一个整型数据，且该数据是个常量，即const int 是共同修饰*pt的。所以变量pt指向的值是不可以改变的，即地址不可变。&emsp;&emsp;而变量finger最左边是const,代表的是常量，再往左是 *,表明是一个指针，最左边是int，表明基本类型为整型。所以finger首先是一个常量，只是该常量指向的是一个int型的指针，所以其指向的变量不可以更改。12345678910int gorp = 16;int chips = 12;const int * p_snack = &amp;gorp;*p_snack = 20; //禁止修改p_snack = &amp;chips; //可以修改int * const p_snack = &amp;gorp;*p_snack = 20; //可以修改p_snack = &amp;chips; //禁止修改 &emsp;&emsp;第一个创建的是常量指针，所以指针指向的地址不可以修改，该例中，p_snack指针指向的是gorp的地址，而该地址存放的变量值是16，所以*p_snack的值只能是16，不能是其他值。但是指针指向的变量是可以更改的，即原来是指向gorp变量地址的，现在可以改为指向chips变量地址，但其值仍为16。虽然不能直接修改，但可以通过改变chips的值修改，比如将chips的值改为20，那么现在该常量指针的值就是20了。&emsp;&emsp;第二个创建的是指针常量，所以指针指向的变量是不可以修改的。也就是变量p_snack是一个常量，其值是不可以修改的，只不过这个变量是指针，而指针的值是地址，所以p_snack只能指向chips变量，其值等于chips的地址，但可以修改该地址对应的值，即本来存放chips变量的地址，其值是12，可以修改为20。 二维数组与指针 1arr[a][b] = *(*(arr +a) + b) 函数与字符串数组 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void show_char(const char * a[]);void show_string(string a[]);const char* Seasons_char[4] = &#123;\"Spring\", \"Summer\", \"Autumn\", \"winter\"&#125;;string Seasons_string[4] = &#123;\"Spring\", \"Summer\", \"Autumn\", \"winter\"&#125;;void show_char(const char * a[])&#123; for (int i = 0; i &lt; 4; i++) cout &lt;&lt; a[i] &lt;&lt; endl;&#125;void show_string(string a[])&#123; for (int i = 0; i &lt; 4; i++) cout &lt;&lt; a[i] &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123; show_char(Seasons_char); show_string(Seasons_string); return 0;&#125; &emsp;&emsp;创建字符串数组的两种形式。第一种形式时，必须要加const。相当于二维数组char Seasons_char[][4]。 函数与结构体/结构体指针1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;struct box&#123; char maker[40]; float height; float width; float length; float volume;&#125;;void show(box x)&#123; cout &lt;&lt; \"maker: \" &lt;&lt; x.maker &lt;&lt; endl; cout &lt;&lt; \"height: \" &lt;&lt; x.height &lt;&lt; endl; cout &lt;&lt; \"width: \" &lt;&lt; x.width &lt;&lt; endl; cout &lt;&lt; \"length: \" &lt;&lt; x.length &lt;&lt; endl; cout &lt;&lt; \"volume: \" &lt;&lt; x.volume &lt;&lt; endl;&#125;void show_pointer(box * x)&#123; x-&gt;volume = x-&gt;height * x-&gt;length * x-&gt;width; cout &lt;&lt; \"maker: \" &lt;&lt; x-&gt;maker &lt;&lt; endl; cout &lt;&lt; \"height: \" &lt;&lt; x-&gt;height &lt;&lt; endl; cout &lt;&lt; \"width: \" &lt;&lt; x-&gt;width &lt;&lt; endl; cout &lt;&lt; \"length: \" &lt;&lt; x-&gt;length &lt;&lt; endl; cout &lt;&lt; \"volume: \" &lt;&lt; x-&gt;volume &lt;&lt; endl;&#125;void show(box x);void show_pointer(box * x);int main(int argc, char const *argv[])&#123; box box1 = &#123;\"cxx\", 1, 1, 1.2&#125;; show(box1); show_pointer(&amp;box1); return 0;&#125; &emsp;&emsp;在C++中，结构体struct和整型int类似，也是一种数据类型，只不过是由用户自己定义的，所以可以将其看作是int型。&emsp;&emsp;上面代码创建了2个函数，一个是按值传递结构体，一个是按地址传递结构体。在使用结构体时要先定义一个结构体模板。&emsp;&emsp;按值传递的结构体中，函数头是void show(box x);表明其数据类型是box，而box就是定义好的结构体类型，相当于int x。在按值传递时，通过用点运算符访问成员变量，调用函数时，传递的参数为结构体的变量名，而按地址传递时，函数头是void show_pointer(box * x);表明其数据类型也是box，但是传递的是一个指针，也就是结构体变量的地址，在按地址传递时，需要用-&gt;运算符访问成员变量，调用函数时，传递的参数应该是结构体变量的地址，即在变量名前面加上取地址符。 函数调用时，传递的参数要么是变量名，要么是变量的地址，不需要加修饰符。 与普通的变量一样，函数也有地址。函数的地址是存储其机器语言代码的内存的开始地址。函数名即函数的地址，后面的括号表示调用，不需要加取地址符。这样就可以将函数名作为一个参数传递给另一个函数。 123double pam(int); //函数声明double (*pf)(int); //函数指针double * pf(int); //指针函数 &emsp;&emsp;声明一个函数pam，有1个参数为int，返回值为double。用一个指针(*pf)来替代函数名就可以声明一个函数指针，也就是必须要指针函数的参数类型和返回值类型。此时pam和*pf一样，都是函数名，而pf就是函数指针，即函数的地址。&emsp;&emsp;指针必须用括号括起来，否则pf会和后面的括号先结合，然后和*结合，变成指针函数，相当于创建一个pf(int)的函数，其返回值为double类型的指针。 未完待续…","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://cxx0822.github.io/categories/C-学习/"}],"tags":[]},{"title":"决策树算法","slug":"决策树算法","date":"2018-12-18T01:19:49.000Z","updated":"2022-03-21T06:19:12.737Z","comments":true,"path":"2018/12/18/jue-ce-shu-suan-fa/","link":"","permalink":"http://cxx0822.github.io/2018/12/18/jue-ce-shu-suan-fa/","excerpt":"","text":"决策树算法一、基本原理&emsp;&emsp;决策树类似于二叉树结构，按照数据集中的特征依次对其分类，直到所有的数据分类完毕。&emsp;&emsp;首先在已知数据集上确定哪个特征在划分数据分类时起决定性作用。为了找到决定性的特征，划分出最好的结果，必须要评估每个特征。此时，原始数据集就会被划分为几个子数据集分支。如果某个分支下的数据都属于同一类型，即该子集中的所有数据的特性均相同，则无需进一步对数据集进行划分。否则需要重复划分数据子集，直到所有具有相同类型的数据均在一个数据子集内。&emsp;&emsp;构造决策树最关键的是如何找到决定性的特征。是否划分的原则为子数据集中的所有数据是否均具有相同的特征。 二、算法实现&emsp;&emsp;伪代码函数decisionTree()：&emsp;&emsp;检测数据集中每个子项是否属于同一类：&emsp;&emsp;IF so&emsp;&emsp;&emsp;return 类标签&emsp;&emsp;Else&emsp;&emsp;&emsp;寻找划分数据集的最好特性&emsp;&emsp;&emsp;划分数据集&emsp;&emsp;&emsp;创建分支节点&emsp;&emsp;&emsp;&emsp;for 每个划分的子集&emsp;&emsp;&emsp;&emsp;&emsp;调用函数decisionTree()并将结果增加到分支节点中&emsp;&emsp;&emsp;return 分支节点 信息增益&emsp;&emsp;在划分数据集之前之后信息发生的变化称为信息增益。获得信息增益最高的特征就是最好的分类选择。计算信息增益常用的是香农熵(熵)。熵的定义为信息的期望值，表示数据的无序性。其计算公式为：python程序：1234567891011121314from math import logdef calcShannonEnt(dataSet): numEntries = len(dataSet) # 计算总数 labelCounts = &#123;&#125; for featVec in dataSet: currentLabel = featVec[-1] if currentLabel not in labelCounts.keys(): labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 # 计算每个分类的总数 shannonEnt = 0.0 for key in labelCounts: prob = float(labelCounts[key]) / numEntries shannonEnt -= prob * log(prob, 2) # 带入公式求和 return shannonEnt 程序说明：&emsp;&emsp;函数的输入为原始数据集，其中最后一列为分类标签。首先计算数据集的总个数，其次将数据集按照分类标签分类，并统计每个子类的总数。最后根据熵的计算公式，依次对每类的信息增益进行求和。 例：有一组已知分类标签的数据集，计算其香农熵。&emsp;&emsp;利用python创建数据集：1234def createDataSet(): dataSet = [[1, 1, 'yes'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']] labels = ['no surfacing', 'flippers'] return dataSet, labels &emsp;&emsp;根据公式其香农熵为：&emsp;&emsp;数据集一共有5组数据，其中分类标签为’yes’的有3个，分类标签为’no’的有2个。熵越高，则混合的数据也越多。 划分数据集&emsp;&emsp;除了计算整体数据的信息熵，还需要计算划分数据集的熵。对每个特征划分数据集的结果计算一次信息熵，然后判断按照哪个特征划分数据集是最好的划分方式。其计算公式为：&emsp;&emsp;首先按照每个特征划分数据集：python程序：12345678def splitDataSet(dataSet, axis, value): retDataSet = [] for featVec in dataSet: if featVec[axis] == value: reducedFeatVec = featVec[:axis] # 截取之前的数据到该特征 reducedFeatVec.extend(featVec[axis + 1:]) # 将该特征后的数据加入到列表中 retDataSet.append(reducedFeatVec) return retDataSet 程序说明：&emsp;&emsp;函数的三个输入分别为：待划分的数据集，数据集中的某个特征，该特征对应的特征值。例如splitDataSet(dataSet, 0, 1)表示划分出数据集dataSet中第0个特征为1的数据，即第1个特征为1的数据，python的列表索引从0开始。(dataSet即createDataSet()函数生成的数据集)&emsp;&emsp;首先利用for循环遍历整个数据集，当对应的特征等于给定的值后，先将该特征之前的数据添加到列表中，然后将之后的数据添加到列表中。&emsp;&emsp;splitDataSet(dataSet, 0, 1)的返回值为：[[1,’yes’], [1, ‘yes’], [0, ‘no’]] &emsp;&emsp;对每个特征划分完成后，需要计算每个数据子集的熵，从而选择最好的数据集划分方式。python程序：1234567891011121314151617181920def chooseBestFeatureToSplit(dataSet): numFeatures = len(dataSet[0]) - 1 # 减去数据集中的标签 baseEntropy = calcShannonEnt(dataSet) bestInfoGain = 0.0 bestFeature = -1 for i in range(numFeatures): featList = [example[i] for example in dataSet] # 获得数据集中某一列的值 uniqueVals = set(featList) # set():使数据为不重复的序列 newEntropy = 0.0 # 划分数据集，代入公式 for value in uniqueVals: subDataSet = splitDataSet(dataSet, i, value) prob = len(subDataSet) / float(len(dataSet)) newEntropy += prob * calcShannonEnt(subDataSet) infoGain = baseEntropy - newEntropy # 计算最大的熵，作为划分数据集的方式 if (infoGain &gt; bestInfoGain): bestInfoGain = infoGain bestFeature = i return bestFeature 程序说明：&emsp;&emsp;函数首先计算总的数据集的熵，然后将最好的熵和特征初始化为0和-1。然后需要将划分数据集，计算每个子集的熵，但首先要知道数据集中每个特征有多少特征值。函数首先获得每一个特征的所有特征值，然后利用set()将重复的值去掉。featList返回的就是每个特征对的所有特征值。createDataSet()生成的数据集的featList为：[1, 1, 1, 0, 0]和[1, 1, 0, 1, 1]。最后，对于划分好的每个数据集依次计算熵，并选择最大的熵作为最好的划分方式。&emsp;&emsp;H(1)、H(2)分别表示第1，2种分类结果，数据集中特征0，即第1个特征的分类结果为1和0。其中结果为1的数据集为：[[1,’yes’], [1, ‘yes’], [0, ‘no’]]，’yes’有2个，’no’有1个；结果为0的数据集为：[[1, ‘no’],[1, ‘no’]],’yes’有0个，’no’有2个。特征1的计算类似。 构建决策树&emsp;&emsp;划分好一次数据集之后，数据将被向下传递到下一个节点，然后在此节点上做进一步的划分。因此可用递归的原则处理原始数据集。&emsp;&emsp;递归的结束条件为：遍历完原始数据集的所有数据或者每个子集的数据特征均相同。 python程序实现： def createTree(dataSet, labels): classList = [example[-1] for example in dataSet] # 第一种终止条件 if classList.count(classList[0]) == len(classList): return classList[0] # 第二种终止条件 if len(dataSet[0]) == 1: return majorityCnt(classList) bestFeat = chooseBestFeatureToSplit(dataSet) # 划分数据集，选择最好的分类标签 bestFeatLabel = labels[bestFeat] myTree = {bestFeatLabel: {}} del(labels[bestFeat]) # 删除已分类好的标签 featValues = [example[bestFeat] for example in dataSet] uniqueVals = set(featValues) # 按之前最好的分类标签继续往下分类 for value in uniqueVals: subLabels = labels[:] myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels) # 列表的值为划分后的数据集 return myTree def majorityCnt(classList): classCount = {} for vote in classList: if vote not in classCount.keys(): classCount[vote] = 0 classCount[vote] += 1 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0] 程序说明：&emsp;&emsp;函数的输入参数为原始数据集和分类标签。首先判断该数据集是否能进行划分。其递归结束的条件有2个，一个是划分后的数据子集的所有特征属性均相同。即数据集中第一个特征的个数即该数据集的总特征个数。另一个是当遍历完所有的原始数据集的特征之后，仍然存在没有划分成包含唯一类别的子类，这时候采用出现出现次数最多的类别作为其返回值。然后计算数据集中的熵并选择最好的分类特征，再将此特征删除，得到数据子集，再依次对子集进行递归处理，直到分类完成。&emsp;&emsp;该程序最终的结果为：{‘no surfacing’: {0: ‘no’, 1: {‘flippers’: {0: ‘no’, 1: ‘yes’}}}}。即首先根据“不浮在水面是否可以生存”的特征分成“0”(否)和“1”(是)两类。其中“0”这一类的子数据集的特征均相同，不需要在划分。而“1”这一类再按照“是否有脚蹼”继续分类。 三、感悟3.1 python知识(1)extend和append的区别：extend:将一个序列添加到列表中；append：将一个对象添加到列表中；即append是将要添加的数据作为一个新的对象添加到列表中，不属于原来的列表，而extend添加后的数据仍然属于原来的列表。例:a = [1, 2], b = [3]a.extend(b) : [1, 2, 3]a.append(b) : [1, 3, [3]](2)set():使数据为不重复的序列 3.2 算法(1)决策树属于有监督的算法。因为其原始数据集的分类标签是已知的。(2)决策树类似于二叉数，将原始数据集按照每个特征的标签依次划分，直到所有的数据划分完成。(3)构建决策树主要分为两步，首先选择最好的划分类别，将原始数据集分成子数据集，其次判断递归的结束条件是否满足，即需不需要继续往下划分。(4)选择最好的划分类别时，常用的判断依据是计算每个特征的子数据集的熵，熵代表的是数据集的混乱程度，数据越混乱，熵越高，其分类标准也越好。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://cxx0822.github.io/categories/机器学习/"}],"tags":[]},{"title":"k-近邻算法","slug":"k-近邻算法","date":"2018-12-17T03:12:16.000Z","updated":"2022-03-31T11:41:23.960Z","comments":true,"path":"2018/12/17/k-jin-lin-suan-fa/","link":"","permalink":"http://cxx0822.github.io/2018/12/17/k-jin-lin-suan-fa/","excerpt":"","text":"k-近邻算法一、基本原理&emsp;&emsp;已知一个样本数据集合，包括每组数据及对应的标签，即数据集已经分类好。当再次输入一组数据时，将新数据的每个特征与样本集中的数据对应的特征进行比较，选择样本集中特征最相似（最近邻）的分类标签。&emsp;&emsp;我们只选择样本集中前k个最相似的数据，这也就是k-近邻算法的出处。最后选择k个最相似数据中出现次数最多的分类，作为新数据的分类，即判断这k个数据中在数据集中的分类标签各自是什么，最后判断最多的分类标签是什么，将此作为新数据的分类。 二、算法实现&emsp;&emsp;对未知类别属性的数据集中的每个点依次执行以下操作：(1)计算已知类别数据集中的点与当前点之前的距离；(特征比较)(2)按照距离递增次序排序；(3)选取与当前点距离最小的k个点；(最近邻)(4)确定前k个点所在的类别出现频率；(判断标签)(5)返回前k个点出现频率最高的类别作为当前点的预测分类。 python代码：123456789101112131415161718192021222324def classifyKNN(inputData, dateSet, labels, k): dataSetSize = dataSet.shape[0] # 返回dataSet的行数 # 计算距离，输入的数据与每一个数据集里面的数据求距离 diffMat = np.tile(inputData, (dataSetSize, 1)) - dataSet # tile()：将数据重复m行n列 sqDiffMat = diffMat ** 2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 # 返回距离中元素从小到大排序后的索引值，可理解为从小到大排序，返回是值对应的索引值 sortedDistIndices = distances.argsort() # argsort(): 返回数组值从小到大的索引值 classCount = &#123;&#125; for i in range(k): # 按照从小到大的顺序依次获得 对应距离的类别属于label的哪一类，并计数 voteLabel = labels[sortedDistIndices[i]] classCount[voteLabel] = classCount.get(voteLabel, 0) + 1 # 将字典按照对应键的值排序，即根据出现的频率次数排序 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0] 代码说明：&emsp;&emsp;函数有4个输入参数：输入数据inputData(1行m列)，原始数据集dateSet(m行n列)，分类标签label，即原始数据集中每行数据属于哪一类，分类基准k，即算法中的k。&emsp;&emsp;首先要计算输入数据与原始数据集中每行数据的距离。先将输入数据重复m行，在依次和数据集中的每行数据做距离运算。(最简单的距离为欧式距离。)&emsp;&emsp;其次对计算过的距离进行排序并计数，按照从小到大的顺序选取前k个。&emsp;&emsp;最后统计这前k个中出现频率最高的分类标签，并将此作为输入数据的分类标签。 三、项目实战——约会网站的配对效果&emsp;&emsp;项目流程：(1)收集数据：提供文本文件(2)准备数据：使用Python解析文本文件&emsp;&emsp;将收集到的原始数据转换为numpy数据，以便于后续分析(3)分析数据：使用matplotlib画二维散点图(4)训练算法：即编写KNN算法(5)测试算法：利用部分原始数据集中的数据作为测试样本，对于KNN算法进行测试(6)使用算法：输入一个新的数据进行预测python代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# 项目1：优化约会网站的配对效果import numpy as npimport operator# 将数据分为两部分，即特征矩阵和对应的分类标签向量def file2matrix(filename): # 获取特征矩阵的行（numberOfLines）和列（3） fr = open(filename) arrayOfLines = fr.readlines() numberOfLines = len(arrayOfLines) returnMat = np.zeros((numberOfLines, 3)) classLabelVector = [] index = 0 # 行的索引值 for line in arrayOfLines: line = line.strip() listFromLine = line.split('\\t') # 前3列为特征矩阵 returnMat[index, :] = listFromLine[0:3] # 最后1列为标签值 if listFromLine[-1] == 'didntLike': classLabelVector.append(1) elif listFromLine[-1] == 'smallDoses': classLabelVector.append(2) elif listFromLine[-1] == 'largeDoses': classLabelVector.append(3) index += 1 # 下一行 return returnMat, classLabelVector# 归一化处理公式： newValue = (oldValue - min) / (max - min)def autoNorm(dataSet): # min()获取矩阵每一行的最小值，min(0)获取矩阵每一列的最小值 minVals = dataSet.min(0) maxVals = dataSet.max(0) ranges = maxVals - minVals normDataSet = np.zeros(np.shape(dataSet)) m = dataSet.shape[0] # 每一行数据均需要归一化处理 # tile()：将数据重复m行n列 normDataSet = dataSet - np.tile(ranges, (m, 1)) normDataSet = normDataSet / np.tile(ranges, (m, 1)) return normDataSet, ranges, minValsdef classifyKNN(inputData, dataSet, labels, k): dataSetSize = dataSet.shape[0] # 返回dataSet的行数 # 计算距离，输入的数据与每一个数据集里面的数据求距离 diffMat = np.tile(inputData, (dataSetSize, 1)) - dataSet sqDiffMat = diffMat ** 2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 # 返回距离中元素从小到大排序后的索引值，可理解为从小到大排序，返回是值对应的索引值 sortedDistIndices = distances.argsort() classCount = &#123;&#125; for i in range(k): # 按照从小到大的顺序依次获得 对应距离的类别属于label的哪一类，并计数 voteLabel = labels[sortedDistIndices[i]] classCount[voteLabel] = classCount.get(voteLabel, 0) + 1 # 将字典按照对应键的值排序，即根据出现的频率次数排序 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]def datingClassTest(): hoRatio = 0.1 # 选取10%的数据集 datingDataMat, datingLabels = file2matrix(filename) normMat, ranges, minVals = autoNorm(datingDataMat) m = normMat.shape[0] numTestVecs = int(m * hoRatio) errorCount = 0.0 for i in range(numTestVecs): # 选取后10%作为测试数据：第numTestVecs行到第m行 classifierResult = classifyKNN(normMat[i, :], normMat[numTestVecs:m, :], datingLabels[numTestVecs:m], 3) if (classifierResult != datingLabels[i]): errorCount += 1.0 print(\"the total error rate is : %f\" % (errorCount / float(numTestVecs)))def classifyPerson(): percentTats = float(input(\"percentage of time spent playing video games?\")) ffMiles = float(input(\"frequent flier miles earned per year?\")) iceCream = float(input(\"liters of ice cream consumed per year?\")) datingDataMat, datingLabels = file2matrix(filename) normMat, ranges, minVals = autoNorm(datingDataMat) inputData = np.array([ffMiles, percentTats, iceCream]) classifierResult = classifyKNN((inputData - minVals) / ranges, normMat, datingLabels, 3) resultList = ['not at all', 'in small doses', 'in large doses'] print(\"You will probably like this person: \", resultList[classifierResult])if __name__ == '__main__': filename = \"datingTestSet.txt\" datingClassTest() classifyPerson() 四、感悟4.1 python知识(1)np.zero((m,n)):创建一个m*n的零矩阵(2)str.strip():删除字符串中的空白;str.split(‘\\t’):TAB键切分字符串(3)np.shape(A):返回A矩阵的行数和列数;A.shape[0]:返回A的行数;A.shape[1]:返回A的列数(4)np.title(a,(m,n)):将数据a重复m行n列 4.2 算法(1)k-近邻算法也称为KNN算法，属于有监督的算法。因为其原始数据集的分类标签是已知的。(2)k-近邻算法最重要的一部分为计算新数据与原始数据集的距离。其核心思想为距离越近越认为是该分类标签。(3)最后选择k个最相似数据中出现次数最多的分类，作为新数据的分类。这句话意思是，比如第1个距离最近的分类为好，第2个距离最近的分类为好，第3个距离最近的分类为坏，第4个距离最近的分类为好，那么前4个中，分类为好为3次，分类为坏为1次，则判定该新数据的分类为好。因此一般k的取值为奇数。(4)在k-近邻算法中，使用的距离为欧式距离，即平面内两点间的距离，在其他算法会使用其他的距离来判断。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://cxx0822.github.io/categories/机器学习/"}],"tags":[]},{"title":"NAO高尔夫比赛（python提高版）","slug":"NAO高尔夫比赛（python提高版）","date":"2018-12-17T02:29:29.000Z","updated":"2022-03-31T11:28:03.936Z","comments":true,"path":"2018/12/17/nao-gao-er-fu-bi-sai-python-ti-gao-ban/","link":"","permalink":"http://cxx0822.github.io/2018/12/17/nao-gao-er-fu-bi-sai-python-ti-gao-ban/","excerpt":"","text":"NAO高尔夫比赛（python提高版）比赛规则场地 图1 高尔夫比赛场地（白圈为球的起点，蓝圈为球洞） &emsp;&emsp;一共分为3个球洞，场地是一样的，只是球的起点位置不同。第一关起点离球洞3m处，第二关起点离场地左边界50cm处，第三关起点离场地下边界50cm处。 球洞 图2 球洞 &emsp;&emsp;球洞由黄杆和landmark组成。 比赛时间及要求&emsp;&emsp;总时长为23min，且击球总次数为10杆。球不可以出界，机器人可以出界。 比赛策略程序模块 图3 程序模块 &emsp;&emsp;高尔夫比赛主要用到了NAO机器人的视觉和运动模块。视觉模块包括红球、黄杆和landmark的识别。运动模块则包括步态、定位和击球等。 程序逻辑 图4 程序逻辑 &emsp;&emsp;主逻辑即：行走找球-&gt;球洞定位-&gt;击球。具体程序逻辑思想可参见python初级版的博客。 提高版的改进摇头找黄杆和找landmark的改进&emsp;&emsp;在初级版的程序设计中，采用的是先摇头找landmark，找不到则摇头找黄杆的策略。但在考虑到时间缩短的情况下，这样明显会浪费一些时间，因此在提高版的程序中，我们在一次摇头的动作中依次找landmark和黄杆。并将下一次定位时找黄杆或landmark的角度设置为上一个角度的大致范围，而不是从头开始找。 python代码：12345678910111213141516171819202122def moveheadToFindLandmarkandStick(self, yawAngles): ''' 摇头找Landmark和黄杆 返回值： 列表[targetDis, targetAngle, compensateAngle] ''' for yawAngle in yawAngles: isfindLandmark = self.findLandmark(pitchAngle=0, yawAngle=yawAngle) if isfindLandmark: targetDis = self.landmark_info[2] targetAngle = self.landmark_info[3] compensateAngle = 10 * rad break isfindStick = self.findStick(pitchAngle=0, yawAngle=yawAngle) if isfindStick: targetDis = -999 targetAngle = self.stickAngle compensateAngle = self.compensateAngle1(self.hitballtimes) break return [targetDis, targetAngle, compensateAngle] 程序说明：&emsp;&emsp;首先找landmark，因为landmark的识别精度和返回的信息比黄杆好，如果找到则返回距离和角度信息。由于黄杆无法返回距离信息，所以将其距离设置为很大的负值，以便于后面的球洞定位判断。 行走找球(walkToBall())的改进&emsp;&emsp;当NAO机器人在行走找球时，由于此时是动态的，或者当距离比较远时，摄像头会捕捉不到红球的信息，而初级版的代码是直接摇头再找一次，但此时机器人仍处于运动的状态，因此还是会出现找不到球的情况，甚至会出现走过红球的情况，所以当出现这种情况时，停下来再找一次是很有必要的。&emsp;&emsp;在改进的代码中，当出现这种情况时，首先停止行走，然后在原地找一下球，找到则继续，否则上下左右摇头找一下球。&emsp;&emsp;其次，由于之前的行走步态参数设置过大，当出现球的角度超过最大偏离角而校正时，由于步伐过大，导致机器人离球很近，从而出现球不在视野内的情况。所以我们将行走的步态参数改小了一点，并将最小接近球的距离放大一点，从而避免这种情况的发生。 python代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475def walkToBall(self, min_ball_d=0.4, max_ball_theta=0.15): ''' 行走到球附近，若没有找到球则往前走一点 参数： min_ball_d:最小接近球的距离 max_ball_theta:最大偏离角 ''' # 如果没有找到球则摇头找球 isfindBall = self.findBall() if isfindBall is False: while True: isfindBall = self.moveheadToFindball() if isfindBall is False: self.motionProxy.moveInit() self.motionProxy.moveTo(0.5, 0, 0, self.walkconfiguration.WalkLineMiddle_blue()) else: break self.motionProxy.moveTo(0, 0, self.ball_info[2], self.walkconfiguration.WalkCircleLittle_blue()) self.motionProxy.angleInterpolationWithSpeed(\"HeadYaw\", 0, 0.1) # 头部回正 moveTask_1 = self.motionProxy.post.moveTo(1.5 * self.ball_info[0], 0, 0, self.walkconfiguration.WalkLineMiddle_blue()) while True: isfindBall = self.findBall(self.pitchAngle, 0) if isfindBall is False: # 行走过程中没有找到球，则停下来找球 self.motionProxy.stop(moveTask_1) time.sleep(0.5) self.motionProxy.moveInit() isfindBall_2 = self.moveheadToFindball(pitchAngles=[self.pitchAngle, self.pitchAngle + 10, self.pitchAngle - 10], yawAngles=[-15, 15]) if isfindBall_2: moveTask_1 = self.motionProxy.post.moveTo(1.5 * self.ball_info[0], 0, 0, self.walkconfiguration.WalkLineMiddle_blue()) ball_d = ((self.ball_info[0] ** 2 + self.ball_info[1] ** 2) ** 0.5) ball_theta = abs(self.ball_info[2]) time.sleep(0.5) # 头不断往下低,防止看不到球 Names = [\"HeadPitch\"] if ball_d &gt; 0.6: self.pitchAngle = 0 elif 0.4 &lt; ball_d &lt; 0.6: self.pitchAngle = 10 elif 0.02 &lt; ball_d &lt; 0.4: self.pitchAngle = 20 self.motionProxy.angleInterpolationWithSpeed(Names, self.pitchAngle * rad, 0.1) # 到达最小距离内，停止 if min_ball_d / 3 &lt; ball_d &lt; min_ball_d: self.tts.say(\"I am right.\") self.motionProxy.stop(moveTask_1) time.sleep(0.5) self.motionProxy.moveInit() break # 偏差在范围内，继续走 elif 0.02 &lt; abs(ball_theta) &lt; max_ball_theta: # 到达最小接近球的距离 if min_ball_d / 3 &lt; ball_d &lt; min_ball_d: self.tts.say(\"I am right.\") self.motionProxy.stop(moveTask_1) time.sleep(0.5) self.motionProxy.moveInit() break else: continue # 超过最大偏离角 elif abs(ball_theta) &gt; max_ball_theta: self.tts.say(\"I am wrong.\") self.motionProxy.stop(moveTask_1) time.sleep(0.5) self.motionProxy.moveInit() self.motionProxy.moveTo(0, 0, self.ball_info[2], self.walkconfiguration.WalkLineMiddle_blue()) moveTask_1 = self.motionProxy.post.moveTo(1.5 * self.ball_info[0], 0, 0, self.walkconfiguration.WalkLineMiddle_blue()) 球洞定位的改进&emsp;&emsp;提高版在球洞定位上面仍然采用初级版的三角定位策略，具体可参见python初级版的博客。但较之前的策略，提高版将依次同时识别landmark和黄杆，即在一次摇头的过程中，先识别landmark，如果识别到，则进入landmark的三角定位，否则识别黄杆，进入黄杆的三角定位。 仍然存在的问题(1)识别黄杆后，仍然不能返回有效的距离信息，这不利于确定击球的力度。(2)击球力度应由距离来确定。应对力度和距离进行数据拟合，得到两者的关系，以确保每次击球的有效距离能达到预期值。(3)应尽量避免反手击球，如果不能在路径规划上解决，可以考虑绕着红球转一个大的圆弧。(4)设计一个切换比赛关数的函数。","categories":[{"name":"NAO高尔夫比赛","slug":"NAO高尔夫比赛","permalink":"http://cxx0822.github.io/categories/NAO高尔夫比赛/"}],"tags":[]},{"title":"MATLAB的GUI小游戏：你话我猜","slug":"MATLAB的GUI小游戏：你话我猜","date":"2018-11-09T09:20:25.000Z","updated":"2022-03-31T11:26:54.621Z","comments":true,"path":"2018/11/09/matlab-de-gui-xiao-you-xi-ni-hua-wo-cai/","link":"","permalink":"http://cxx0822.github.io/2018/11/09/matlab-de-gui-xiao-you-xi-ni-hua-wo-cai/","excerpt":"","text":"&emsp;&emsp;使用MATLAB中的GUI设计一个小游戏——你话我猜，最终效果如图所示：&emsp;&emsp;这是主界面，有四个选项，单击文字前面的图标即可跳转至子界面，如图所示： 这是子界面，有3个选项，单击Start倒计时开始，单击Right则答对个数+1，单击Next则调至下一题，直到倒计时为0。 一、创建GUI&emsp;&emsp;打开MATLAB（本游戏编译环境为2014a），选择HOME-&gt;New-&gt;GUI，在弹出的窗口中选择Blank GUI，点击OK，即可创建空白GUI。&emsp;&emsp;将新建的GUI命名为Games_1。在MATLAB左侧的Current Folder中可以看到有2个文件，一个为Games_1.m和Games_1.jpg，其中.m为MATLAB编译文件，.jpg为GUI文件。右击Games_1.jpg并选择Open in GUIDE即可看到GUI界面。&emsp;&emsp;左侧为控件栏，拖动至中间空白区域即可创建，中间区域为GUI界面，运行对应的.m文件即可显示界面。 二、在主界面添加背景图片和文字&emsp;&emsp;MATLAB中在GUI添加背景图片的常用做法是：创建一个坐标系，将图片添加至坐标系中，然后将坐标系的坐标轴设置为不可见，为了将文字写在图片上，可将该坐标系设置为下一层。打开Games_1.m，在function Games_1_OpeningFcn函数中输入代码。 123456Games.ax = axes('units','normalized', 'position',[0 0 1 1]); %单位化uistack(Games.ax,'down'); %把新创建的坐标系在下移一层Games.img = imread('Games1.jpg'); %打开图片Games.IH = image(Games.img); % 显示图片colormap gray % 设置窗口的调色板为灰色set(Games.ax,'handlevisibility','off','visible','off');%把创建的坐标系句柄设为不可见 &emsp;&emsp;其次，需要在图片上面打印文字。同样的创建一个坐标系并将其坐标轴设置为不可见，利用text()函数即可打印文字。 123456789Games2.ax=axes('units','normalized','pos',[0 0 1 1]); text(0.2,0.9,'游戏环节之你话我猜','fontsize',80) %第一个数横坐标，第二个数纵坐标text(0.5,0.8,'请任选一项，开始你的表演！','fontsize',40,'color','b') text(0.1,0.48,'成语','fontsize',80,'color','b')text(0.1,0.18,'体育','fontsize',80,'color','b')text(0.66,0.48,'演技王','fontsize',80,'color','b')text(0.63,0.18,'知识百科','fontsize',80,'color','b')text(0.80,0.04,'Copyright@cxx','fontsize',30)set(Games2.ax,'handlevisibility','off','visible','off'); &emsp;&emsp;最终效果如图所示： 三、添加控件和控件图标，实现单击图标即可跳转至子界面3.1 添加控件并实现单击控件跳转至子界面&emsp;&emsp;右击Games_1.fig，选择open in GUIDE，在控件栏中拖动Push Button至中间空白区域，双击控件即可更改属性。首先设置其Tag属性，将其更改为chengyu，以便区别，并将String属性去掉，不显示控件上的文字，并调整位置和大小，和文字位置相匹配。此时点击Games_1.m或Games_1.fig的运行即可看到控件，在Games_1.m中会出现该控件的回调函数，即function chengyu_Callback()，在GUI界面中右击控件选择View Callbacks中Callback也可跳转至该函数。回调函数用于响应控件时执行的操作。比如新建一个子界面Games_2，并在回调函数中添加run(‘Games_2’)，即可实现跳转。 3.2 设置控件的背景图片&emsp;&emsp;利用set()函数设置对应控件中的CData属性为读取的图片即可实现。设置前需要对图片的像素进行修改，以便能符合控件的大小。12345A=imread('button_start.jpg'); %读取图片 set(handles.chengyu,'CData',A); %将按钮的背景图片设置成Aset(handles.tiyu,'CData',A); set(handles.yanjiwang,'CData',A); set(handles.zhishibaike,'CData',A); &emsp;&emsp;最终效果如图所示： 四、子界面的界面设计和控件的回调函数4.1 子界面的界面设计&emsp;&emsp;子界面的背景和控件添加方法和主界面类似，为了提高程序的运行效率，可将所有的读取操作放在主界面中执行，即添加全局变量，将图片存储在全局变量中，然后在子界面相应的函数中调用该全局变量。（MATLAB中的全局变量需要先用global声明，每次调用前也需要声明。）然后创建3个edit text控件，分别用于显示词语、倒计时的时间和答对个数。最终效果如图所示： 4.2 读取文件并显示&emsp;&emsp;本游戏的玩法为：点击Start，显示框显示词语同时倒计时开始，当回答正确时点击Right，此时答对个数+1并读取下一个词语，当点击Next时，会直接读取下一个词语，但答对个数不变。在这过程中，倒计时一直在进行，直到倒计时显示为0，当所有词语都显示完后，点击Next和Right均无效。&emsp;&emsp;所以首先要从excel表中读取词语，为了提高程序运行效率，将读取操作写在主界面的函数中，并设置其为全局变量。123456789101112131415function Games_1_OpeningFcn(hObject, eventdata, handles, varargin)handles.output = hObject;guidata(hObject, handles);global Time;global class1_i; global class2_i; global class3_i; global class4_i;global class1_Len; global class2_Len; global class3_Len; global class4_Len;global questions1; global questions2; global questions3; global questions4; class1_Len=length(questions1);class2_Len=length(questions2); %词语变量长度class3_Len=length(questions3);class4_Len=length(questions4);class1_i=0;class2_i=0;class3_i=0;class4_i=0; %词语循环变量Time=90; %倒计时时间[~,questions1,~] = xlsread('question1.xlsx');%读取表格，并将其数据放在questions1中[~,questions2,~] = xlsread('question2.xlsx');[~,questions3,~] = xlsread('question3.xlsx');[~,questions4,~] = xlsread('question4.xlsx'); 4.3 Start控件&emsp;&emsp;然后在子界面的Start控件的回调函数中编写代码。12345678910111213141516171819202122232425function Start_Callback(hObject, eventdata, handles)set(handles.Question1,'string','');%清空Question1global Count_Right; global questions1;global class1_i ;global class1_Len;global Time;Count_Right=0; set(handles.Count_Right,'string',0);class1_i=class1_i+1;if class1_i &gt;0 &amp;&amp; class1_i&lt; class1_Len+1 questions_number = class1_i; question_select = questions1(questions_number); set(handles.Question1,'string',question_select);endif class1_i&gt;=class1_Len+1 set(handles.Question1,'string','没有了哦~');endt=clock; %记录开始的时间NowSecond=etime(clock,t); PrSecond=NowSecond;while NowSecond&lt;=Time; if ishandle(handles.second) set(handles.second,'string',num2str(floor(Time-NowSecond))); end pause(0.01) NowSecond=etime(clock,t); %计算当前流逝的时间(秒) end &emsp;&emsp;首先清空词语文本中的内容，即用set()函数将Question1文本控件的String属性设置为空。然后初始化答对个数为0。当词语变量大于0且小于词语数组总长度+1的时候，首先选择词语变量值对应的数组索引中的数据，然后在显示出来，当大于词语数组总长度+1的时候，则显示没有。&emsp;&emsp;第二段是对倒计时的设置。首先将当前时间放在变量t中，clock记录当前的时间，etime()表示现在时间和t之间的差值。当时间差小于指定的倒计时时间时，会一直倒计时。（不加if判断，当倒计时为0时会有警告，不加暂停程序会一直卡住。） 4.4 Right控件1234567891011121314function Right_Callback(hObject, eventdata, handles)set(handles.Question1,'string','');global questions1;global Count_Right ; global class1_i ;global class1_Len;Count_Right=Count_Right+1;set(handles.Count_Right,'string',Count_Right);class1_i=class1_i+1;if class1_i &gt;0 &amp;&amp; class1_i&lt; class1_Len+1 questions_number = class1_i; question_select = questions1(questions_number); set(handles.Question1,'string',question_select);endif class1_i&gt;=class1_Len+1 set(handles.Question1,'string','没有了哦~');end &emsp;&emsp;单击该控件，则答对个数文本值+1，其余和Start控件类似。 4.5 Next控件123456789101112function Next_Question1_Callback(hObject, eventdata, handles)set(handles.Question1,'string','');global questions1; global class1_i ;global class1_Len;class1_i=class1_i+1;if class1_i &gt;0 &amp;&amp; class1_i&lt; class1_Len+1 questions_number = class1_i; question_select = questions1(questions_number); set(handles.Question1,'string',question_select);endif class1_i&gt;=class1_Len+1 set(handles.Question1,'string','没有了哦~');end &emsp;&emsp;单击该控件，词语变量+1，和Start控件第一部分类似。 五、添加游戏背景音乐，当跳转至子界面时停止123[Y,FS]=audioread('Games1.mp3'); %播放歌曲Song_Current = audioplayer(Y,FS); %存储当前播放的歌曲play(Song_Current); &emsp;&emsp;将当前音乐存储在Song_Current变量中，并设置其为全局变量（方便子函数调用）。并且在每次调用子界面时添加stop(Song_Current)以终止音乐。当退出子界面时，需要重新打开该音乐。这是退出界面的回调函数，在GUI界面中，右击空白处可看到该回调函数，即CloseRequestFcn()。 123456function figure1_CloseRequestFcn(hObject, eventdata, handles) global Song_Current; [Y,FS]=audioread('Games1.mp3'); %播放歌曲 Song_Current = audioplayer(Y,FS); %存储当前播放的歌曲 play(Song_Current); delete(hObject); &emsp;&emsp;最后一步删除整个对象以结束。 六、总结&emsp;&emsp;本游戏整体比较简单，代码共享在这里，你话我猜。还望大佬们指点改进。","categories":[{"name":"MATLAB","slug":"MATLAB","permalink":"http://cxx0822.github.io/categories/MATLAB/"}],"tags":[]},{"title":"NAO高尔夫比赛（python初级版）","slug":"NAO高尔夫比赛（python初级版）","date":"2018-11-08T11:45:07.000Z","updated":"2022-03-31T11:24:39.569Z","comments":true,"path":"2018/11/08/nao-gao-er-fu-bi-sai-python-chu-ji-ban/","link":"","permalink":"http://cxx0822.github.io/2018/11/08/nao-gao-er-fu-bi-sai-python-chu-ji-ban/","excerpt":"","text":"主逻辑 &emsp;&emsp;主逻辑为：找球——&gt;定位——&gt;击球。 找球基本思想&emsp;&emsp;找球的过程可分为两步，即在场地找球和找到球之后走到球附近。&emsp;&emsp;初级版采用地毯式搜索在场地找球，即走一段停下来然后在原地摇头找球，找到则调整身体，使身体正对着球，并走到球附近，否则继续往前走。&emsp;&emsp;找到球后的行走过程中，机器人会不断的看球确认，一旦发现其身体方向并没有正对着球，则停止行走，并再次调整身体，直到走到指定位置。 python程序实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869def walkToBall(self, min_ball_d=0.35, max_ball_theta=0.15): ''' 行走到球附近，若没有找到球则往前走一点 参数： min_ball_d:最小接近球的距离 max_ball_theta:最大偏离角 ''' isfindBall = self.findBall() # 如果没有找到球则摇头找球 if isfindBall is False: while True: isfindBall = self.moveheadToFindball() if isfindBall is False: self.motionProxy.moveInit() self.motionProxy.moveTo(0.5, 0, 0) else: break # 否则找到球，调整机器人身体，使其正对着球 self.motionProxy.moveTo(0, 0, self.ball_info[2]) self.motionProxy.angleInterpolationWithSpeed(\"HeadYaw\", 0, 0.1) # 头部回正 moveTask_1 = self.motionProxy.post.moveTo(1.5 * self.ball_info[0], 0, 0) while True: isfindBall = self.findBall(self.pitchAngle, 0) if isfindBall is False: self.moveheadToFindball(pitchAngles=[-10], yawAngles=[-15, 15]) ball_d = ((self.ball_info[0] ** 2 + self.ball_info[1] ** 2) ** 0.5) ball_theta = abs(self.ball_info[2]) time.sleep(0.5) # 头不断往下低,防止看不到球 Names = [\"HeadPitch\"] if ball_d &gt; 0.4: self.pitchAngle = 0 elif 0.3 &lt; ball_d &lt; 0.4: self.pitchAngle = (-100 * ball_d + 40) elif 0.02 &lt; ball_d &lt; 0.3: self.pitchAngle = 20 self.motionProxy.angleInterpolationWithSpeed(Names, self.pitchAngle * rad, 0.1) # 到达最小距离内，停止 if min_ball_d / 3 &lt; ball_d &lt; min_ball_d: self.tts.say(\"I am right.\") self.motionProxy.stop(moveTask_1) time.sleep(0.5) self.motionProxy.moveInit() break # 偏差在范围内，继续走 elif 0.02 &lt; abs(ball_theta) &lt; max_ball_theta: # 到达最小接近球的距离 if min_ball_d / 3 &lt; ball_d &lt; min_ball_d: self.tts.say(\"I am right.\") self.motionProxy.stop(moveTask_1) time.sleep(0.5) self.motionProxy.moveInit() break else: continue # 超过最大偏离角 elif abs(ball_theta) &gt; max_ball_theta: self.tts.say(\"I am wrong.\") self.motionProxy.stop(moveTask_1) time.sleep(0.5) self.motionProxy.moveInit() self.motionProxy.moveTo(0, 0, self.ball_info[2]) moveTask_1 = self.motionProxy.post.moveTo(1.5 * self.ball_info[0], 0, 0) 程序说明&emsp;&emsp;首先调用看球函数findBall()进行一次找球，如果找到则跳到下面的If判断，否则返回False，进入If结构，即调用摇头找球函数moveheadTofindBall()进行摇头找球，如果还未找到则继续往前走。&emsp;&emsp;找到球后，首先根据返回的ball_Info属性（ball_info = [ball_x, ball_y, ball_theta]）的第3个值，调整身体位置，然后进入While True循环。&emsp;&emsp;进入该循环前，首先调用moveTo()函数，并调用其post属性使其进程挂起，即在行走的过程中，可以做其他事情。为了防止机器人的行走有误差，可将moveTo()函数的x参数加入一个系数，以确保机器人一定能走到球附近。&emsp;&emsp;在行走的过程中，机器人会每隔0.5s看一次球，并通过返回的ball_Info信息来判断是否到达指定位置和身体是否偏移球的位置。&emsp;&emsp;由于到达指定位置的优先级大于是否偏离球的位置，所以将是否到达指定位置的判断放在前面，即不管身体是否偏移，到达位置即可，（后续会再看一次球，调整回来）。&emsp;&emsp;如果未到达指定位置，但身体没有偏离到最大偏差角，即继续执行，一旦偏离最大偏差角，则停止行走，并立即调整身体位姿，并重新调用之前的moveTo()函数。&emsp;&emsp;注：在距离球越近时，机器人应根据距离调整低头的角度，以确定球在视野范围内。在进入走到球附近的程序中，如果没看到球，会进行一次小范围摇头找球，以确定机器人是以看到球的基础上进行校正。 定位三角定位基本思想&emsp;&emsp;定位的主要目的即让机器人调整至最佳击球位置。由于我们采用的是右手握杆击球，即球杆，球和球洞在同一条水平线上。 图1 机器人最佳击球位置 由于机器人到达球的附近时，并不一定是最佳击球位置，所以定位是高尔夫比赛中必不可少的一个环节。初级版采用的是三角定位的方式，即调整机器人的位姿，使得机器人、球和球洞之间的三角形为直角三角形。 图2 三角定位(反手锐角)&emsp;&emsp;如图2所示，红色圆点为球的位置，蓝色圆点为机器人的位置，黄色为黄杆(球洞)。机器人-球-球洞之间的夹角为α,机器人-球洞-球之间的夹角为β,球-机器人-球洞之间的夹角为γ（已知），机器人和球的距离为d（已知），球和球洞的距离为l。&emsp;&emsp;此时由于α为锐角，而最佳击球位置为直角，所以机器人应该向左绕一个以球为圆心，夹角为θ(θ = 0.5 * pi - α)的圆弧。并且此时应用反手击球。同理可得，如果α为钝角，θ = α - 0.5 * pi，机器人向右绕圆弧。&emsp;&emsp;如果机器人在另一侧，方法同上，但击球方式应为正手击球。&emsp;&emsp;但此时存在一个问题，只有黄杆上面的landmark（如图1所示），机器人才能识别出距离，但只有在1米的有效距离内识别出，而机器人可以在很远的距离内识别出黄杆，但无法返回距离。&emsp;&emsp;所以，在远距离时，只能利用黄杆来定位，但在机器人、球和黄杆组成的三角形中，由于已知的信息较少，无法正确解出三角形，因此我们必须假设一个信息是已知的。&emsp;&emsp;我们假设β是已知的，并且球和球洞的距离越远，该角度越小。利用这个假设，我们便可以让机器人通过moveTo()函数，使得到达最佳位置，即机器人-球-球洞的夹角为0.5pi。 python程序实现12345678910111213141516171819202122232425262728293031323334353637383940414243def moveCircle_stick(self, stickAngle, ball_d, compensateAngle1): ''' 绕球走半径为机器人与球的距离的圆弧，分正反手 参数: stickAngle:黄杆与机器人的角度 ball_d:机器人与球的距离 compensateAngle1:补偿角(机器人-杆-球的角度) ''' # 杆-球-机器人的夹角(分锐角和钝角) stick_ball_robotAngle = math.pi - compensateAngle1 * rad - abs(stickAngle) # 正手打 if stickAngle &gt;= 0: self.isbackhandFlag = False if 0 &lt;= stick_ball_robotAngle &lt; 0.5 * math.pi: moveAngle = 0.5 * math.pi - stick_ball_robotAngle move_d = (ball_d ** 2 + ball_d ** 2 - 2 * ball_d * ball_d * math.cos(moveAngle)) ** 0.5 self.motionProxy.moveInit() self.motionProxy.moveTo(0, -move_d, moveAngle) else: moveAngle = stick_ball_robotAngle - 0.5 * math.pi move_d = (ball_d ** 2 + ball_d ** 2 - 2 * ball_d * ball_d * math.cos(moveAngle)) ** 0.5 self.motionProxy.moveInit() self.motionProxy.moveTo(0, move_d, -moveAngle) # 反手打 else: self.isbackhandFlag = True stickAngle = abs(stickAngle) if 0 &lt;= stick_ball_robotAngle &lt; 0.5 * math.pi: moveAngle = 0.5 * math.pi - stick_ball_robotAngle move_d = (ball_d ** 2 + ball_d ** 2 - 2 * ball_d * ball_d * math.cos(0.5 * math.pi - stick_ball_robotAngle)) ** 0.5 self.motionProxy.moveInit() self.motionProxy.moveTo(0, move_d, -moveAngle) else: moveAngle = stick_ball_robotAngle - 0.5 * math.pi move_d = (ball_d ** 2 + ball_d ** 2 - 2 * ball_d * ball_d * math.cos(stick_ball_robotAngle - 0.5 * math.pi)) ** 0.5 self.motionProxy.moveInit() self.motionProxy.moveTo(0, -move_d, moveAngle) 程序说明&emsp;&emsp;首先计算出图2的α，用来判断是锐角还是钝角，其次需要判断机器人和黄杆的角度，如果为正值，应该为正手击球，否则应为反手击球。&emsp;&emsp;在moveTo()的函数中，需要给定的参数为y和θ的值。其中y的值可以用余弦定理求得，而θ为0.5pi与α的差值的绝对值。&emsp;&emsp;注:机器人以左手为y坐标系正半轴，正前方为x坐标系正半轴，设置moveTo()函数的参数时，要注意正负号。 图像定位基本思想&emsp;&emsp;经过三角定位后，机器人基本上到达最佳击球位置，但是我们的最佳击球位置不是(0,0),而是(0.20,-0.05),所以经过三角定位后，还需要左右和上下平移。&emsp;&emsp;之前的方法为利用看球后返回的x和y轴的信息，然后调用moveTo()函数，不断的调整，但实际测试下来，效果并不理想，主要有2个原因。&emsp;&emsp;第一如果机器人不是正对着球，看球的信息会不太准确，而且由于此时要求精度较高，该误差较大。第二机器人本身精度也有误差，特别是此时只是微小移动，很难快速收敛。&emsp;&emsp;针对以上问题，我们决定直接利用球在图像中的信息进行调整，即不需要在进行球的返回信息(x和y)计算，而且此时球在图像中的像素值很大，加入一个比例控制系数就会很快的收敛。 python程序实现123456789101112131415161718192021222324252627def locateWithImage(self, best_ball_x=400, best_ball_y=320, best_ball_radius=28): self.motionProxy.angleInterpolationWithSpeed([\"HeadPitch\", \"HeadYaw\"], [20 * rad, 0 * rad], 0.1) self.ballDetect.updateBallData(client=\"cx\", fitting=True) centerX, centerY, radius = self.ballDetect.getBallInfoInImage() bias_x = centerY - best_ball_y bias_y = centerX - best_ball_x Kp = 0.0008 if abs(radius - best_ball_radius) &lt; 15: if (abs(bias_x) &lt; 40 and abs(bias_y) &lt; 20): self.tts.say(\"I am OK\") return True else: self.motionProxy.moveInit() move_x = Kp * bias_x move_x = -1.0 / 100 if (move_x &lt; 0 and move_x &gt; -1.0 / 100) else move_x move_x = 1.0 / 100 if (move_x &gt; 0 and move_x &lt; 1.0 / 100) else move_x if abs(bias_x) &gt; 15: self.motionProxy.moveTo(-move_x, 0, 0) time.sleep(0.5) move_y = Kp * bias_y move_y = -1.0 / 100 if (move_y &lt; 0 and move_y &gt; -1.0 / 100) else move_y move_y = 1.0 / 100 if (move_y &gt; 0 and move_y &lt; 1.0 / 100) else move_y if abs(bias_y) &gt; 15: self.motionProxy.moveTo(0, -move_y, 0) time.sleep(0.5) 程序说明&emsp;&emsp;首先要测得最佳击球位置在图像中的像素位置，然后根据实际值与期望值的差得到误差，注意此时图像和机器人的坐标系不一样，然后每次调整位置时，加入一个比例系数Kp，实验测得，经过3-4次调整即可快速的收敛，到达最佳击球位置。&emsp;&emsp;注：三角定位要和图像定位结合使用，三角定位是为了调整机器人与球洞的角度，而图像定位是为了让其到达指定的(x,y)位置，为了更精准的到达指定位置，每次循环进行1次三角定位和2次图像定位。实验测得，经过3次左右的循环，便可完成定位，而且其效果也比较理想。 击球基本思想&emsp;&emsp;考虑到机器人与球洞的位置，我们设计了2种击球方式，即正手击球和反手击球。&emsp;&emsp;其方向可以通过黄杆或landmark的角度来判断。当角度为正值时，说明球洞在机器人的左手边，由于我们采用右手击球，所以应为正手击球，否则应为反手击球。 python程序实现12345678910111213141516171819202122232425262728293031323334353637383940414243def forehandToHitball(self, hitSpeed): ''' 正手击球 参数： hitSpeed:击球的力度 ''' # 手回正 names = [\"RShoulderPitch\", \"RShoulderRoll\", \"RElbowRoll\", \"RElbowYaw\", \"RWristYaw\"] maxSpeedFraction = 0.1 targetAngles = [[90 * rad, -20 * rad, 5 * rad, 90 * rad, 0 * rad], [80 * rad, -40 * rad, 5 * rad, 90 * rad, 0 * rad], [50 * rad, -45 * rad, 50 * rad, 90 * rad, -37 * rad], [50 * rad, 5 * rad, 50 * rad, 90 * rad, 20 * rad]] # 击球 for targetAngle in targetAngles: if targetAngle == targetAngles[-1]: maxSpeedFraction = hitSpeed self.motionProxy.angleInterpolationWithSpeed(names, targetAngle, maxSpeedFraction) time.sleep(0.5)def backhandToHitball(self, hitSpeed): ''' 反手击球 参数： hitSpeed：击球的力度 ''' names = [\"RShoulderPitch\", \"RShoulderRoll\", \"RElbowRoll\", \"RElbowYaw\", \"RWristYaw\"] maxSpeedFraction = 0.1 targetAngles = [[90 * rad, -20 * rad, 5 * rad, 90 * rad, 0 * rad], # 手回正 [80 * rad, -40 * rad, 5 * rad, 90 * rad, 0 * rad], [50 * rad, -45 * rad, 50 * rad, 90 * rad, 0 * rad], [50 * rad, 0 * rad, 70 * rad, 90 * rad, 40 * rad], [60 * rad, 2 * rad, 60 * rad, 90 * rad, 40 * rad], [60 * rad, -20 * rad, 60 * rad, 90 * rad, -20 * rad]] for targetAngle in targetAngles: if targetAngle == targetAngles[-1]: maxSpeedFraction = hitSpeed self.motionProxy.angleInterpolationWithSpeed(names, targetAngle, maxSpeedFraction) time.sleep(0.5) 程序说明&emsp;&emsp;无论正手还是反手，都是机器人手臂的一系列关节角变化，通过连续的给每个关节不同的角度，即可实现击球动作。&emsp;&emsp;注：最后一个关节角的速度是击球时的力度，所以其值应不同于其余值，应该给定一个较大的值。 存在的问题和不足&emsp;&emsp;初级版的程序虽然整体上可以实现功能，但都是基于理想的情况下，实际测试下来，程序仍存在一些未知的bug，所以在高级版的程序中，我们要对其进行优化，主要包括以下几个方面。 逻辑思想： 所有的找球，看黄杆/landmark的程序必须考虑完整，即分为看到和没看到2种情况，后续的动作一定要基于之前是找到的情况。 当机器人一直往前走仍找不到球，或因为没看到球而认为没有球一直往前走，这种情况下该怎么办？ 定位时没有看到球，或者看球错误导致球超出视野范围外，需要让机器人摇头找下球，重新定位。 击球的力度能和距离关联，实现不同的距离给定不同的力度。 当球的位置超过球洞，即机器人需绕道球洞后面进行击球，此时应考虑如何避开球洞。 python程序： 每次摇头找球或找黄杆/landmark时，第一次需要摇头，后面则不需要摇头，调用之前的值即可。 利用try-except对程序进行异常处理，防止实际比赛时，程序报错。 注：本博客采用的视觉算法是我师兄的一篇博客：NAO机器人高尔夫中的视觉系统设计","categories":[{"name":"NAO高尔夫比赛","slug":"NAO高尔夫比赛","permalink":"http://cxx0822.github.io/categories/NAO高尔夫比赛/"}],"tags":[]},{"title":"仿人气动手臂：硬件连接图","slug":"仿人气动手臂：硬件连接图","date":"2018-11-08T09:18:07.000Z","updated":"2022-03-31T11:22:58.114Z","comments":true,"path":"2018/11/08/fang-ren-qi-dong-shou-bi-ying-jian-lian-jie-tu/","link":"","permalink":"http://cxx0822.github.io/2018/11/08/fang-ren-qi-dong-shou-bi-ying-jian-lian-jie-tu/","excerpt":"","text":"硬件总图 LabVIEW数据采集卡&emsp;&emsp;LabVIEW数据采集卡插到PC机的PCI插槽中。并用连接线与LabVIEW接线盒连接。 LabVIEW接线盒模拟输入端&emsp;&emsp;模拟输入端和气压传感器相连。接线盒的输入端采用单端接入，即连接AI+和GND。气压传感器的白色接线端为信号线，棕色接线端为正极，蓝色接线端为负极。&emsp;&emsp;连接方式：将AI+(接线盒中的任意一个模拟输入端)与气压传感器的白色接线端相接，GND和下一个待接的GND相接(保证接线盒内的所有的地线都连通即可)。气压传感器的棕色接线端和蓝色接线端分别接入电源接线盒的正极和负极，给气压传感器供电。&emsp;&emsp;注：每个LabVIEW接线盒内要有1根地线与电源接线盒的地线(-V)相接。 模拟输出端&emsp;&emsp;模拟输出端和气动比例阀相连。气动比例阀的白色接线端为信号线，棕色接线端为正极，蓝色接线端为负极。&emsp;&emsp;连接方式：将AO(接线盒中的任意一个模拟输出端)与气动比例阀的白色接线端相接，GND和下一个待接的GND相接(保证接线盒内的所有的地线都连通即可)。气动比例阀的棕色接线端和蓝色接线端分别接入电源接线盒的正极和负极，给气动比例阀供电。 气缸使用&emsp;&emsp;开启：①将抽气开关按下，阀门开关闭合。②接通电源。③打开抽气开关(提上去)，气缸开始充气，待气压显示表到达指定气压值时(0.6MPa)，按下开关。④打开阀门开关，即可出气。&emsp;&emsp;关闭：①关闭阀门开关，停止出气。②拔掉电源，气缸每隔一段时间自动漏气。","categories":[{"name":"毕业论文","slug":"毕业论文","permalink":"http://cxx0822.github.io/categories/毕业论文/"}],"tags":[]}]}