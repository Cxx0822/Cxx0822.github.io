<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="true">








  <meta name="baidu-site-verification" content="LmRKxmt2tr">







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="概述&amp;emsp;&amp;emsp;之前初级版的视觉系统设计只是通过opnecv简单处理了NAO获得的图像，然后再加上一些判断条件（主要是颜色条件），最后如果满足条件则认为是该目标。虽然总体上可以实现目标的识别，但很容易受到现场环境的影响，不是特别稳定。&amp;emsp;&amp;emsp;在高级版的设计中，我们采用了机器学习中的分类算法。首先根据opencv中的检测算法得到候选区域，然后通过对候选区域的特征提取获得其">
<meta property="og:type" content="article">
<meta property="og:title" content="NAO比赛视觉系统设计（python高级版）">
<meta property="og:url" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）/index.html">
<meta property="og:site_name" content="NJTECH_cxx">
<meta property="og:description" content="概述&amp;emsp;&amp;emsp;之前初级版的视觉系统设计只是通过opnecv简单处理了NAO获得的图像，然后再加上一些判断条件（主要是颜色条件），最后如果满足条件则认为是该目标。虽然总体上可以实现目标的识别，但很容易受到现场环境的影响，不是特别稳定。&amp;emsp;&amp;emsp;在高级版的设计中，我们采用了机器学习中的分类算法。首先根据opencv中的检测算法得到候选区域，然后通过对候选区域的特征提取获得其">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//HSV空间表.jpg">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//redball二值化.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//football二值化.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//stick二值化.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//hougtRedball.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//hougtFootball.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//code.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//counterStick.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//HOG特征.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//logist公式.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//参数更新.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//标注1.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//标注2.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//特征向量.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//足球检测结果.png">
<meta property="og:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//等分黄杆.png">
<meta property="og:updated_time" content="2019-05-23T05:30:29.687Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NAO比赛视觉系统设计（python高级版）">
<meta name="twitter:description" content="概述&amp;emsp;&amp;emsp;之前初级版的视觉系统设计只是通过opnecv简单处理了NAO获得的图像，然后再加上一些判断条件（主要是颜色条件），最后如果满足条件则认为是该目标。虽然总体上可以实现目标的识别，但很容易受到现场环境的影响，不是特别稳定。&amp;emsp;&amp;emsp;在高级版的设计中，我们采用了机器学习中的分类算法。首先根据opencv中的检测算法得到候选区域，然后通过对候选区域的特征提取获得其">
<meta name="twitter:image" content="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）//HSV空间表.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）/">





  <title>NAO比赛视觉系统设计（python高级版） | NJTECH_cxx</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">NJTECH_cxx</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不要因为别人5%的负面评价而否定自己100%的努力。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.chenxiuxiang.site/2019/04/27/NAO比赛视觉系统设计（python高级版）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cxx">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NJTECH_cxx">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">NAO比赛视觉系统设计（python高级版）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-27T15:18:47+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NAO高尔夫比赛/" itemprop="url" rel="index">
                    <span itemprop="name">NAO高尔夫比赛</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 阅读数
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,693 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  39 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;之前初级版的视觉系统设计只是通过<code>opnecv</code>简单处理了NAO获得的图像，然后再加上一些判断条件（主要是颜色条件），最后如果满足条件则认为是该目标。虽然总体上可以实现目标的识别，但很容易受到现场环境的影响，不是特别稳定。<br>&emsp;&emsp;在高级版的设计中，我们采用了机器学习中的分类算法。首先根据<code>opencv</code>中的检测算法得到候选区域，然后通过对候选区域的特征提取获得其特征向量，最后通过这些特征向量离线训练分类器模型，从而得到一个较好的分类器。而且该方法适用于任何目标的检测。   </p>
<h1 id="候选区域"><a href="#候选区域" class="headerlink" title="候选区域"></a>候选区域</h1><p>&emsp;&emsp;候选区域的提取是传统图像处理的第一步，能否正确提取到候选区域直接决定着能否检测到目标，现在的机器学习分类算法在分类结果上基本上都能达到很好效果，正确率也能满足要求，但往往在特征区域的提取上会出现偏差甚至检测不到。所以特征提取这一步至关重要。<br>&emsp;&emsp;下面创建一个通用的目标检测类<code>TargetDetection</code>，想用什么方法获得候选区域，就在类中封装成一个方法即可，最后统一返回候选区域(矩形)的左上角和右下角坐标，以便后续的处理。       </p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>&emsp;&emsp;之前初级版并没有对原图进行过多的预处理，虽然在比赛时，背景颜色比较单一，不加预处理也可以得到理想的效果，但是为了提高检测的精确度和应用的广泛性，这里稍微加了几个图像处理的方法。<br>&emsp;&emsp;首先介绍几个常见的预处理方法。    </p>
<ol>
<li><p>灰度化<br>&emsp;&emsp;将彩色图像转化成为灰度图像的过程称为图像的灰度化处理。彩色图像中的每个像素的颜色有<code>R、G、B</code>三个分量决定，而每个分量的取值为<code>[0, 255]</code>，每个像素一共有<code>255*255*255</code>种情况。而灰度图像是<code>R、G、B</code>三个分量相同的一种特殊的彩色图像，所以每个像素一共只有<code>255</code>种情况，所以在数字图像处理种一般先将各种格式的图像转变成灰度图像以使后续的图像的计算量变得少一些。<br>&emsp;&emsp;灰度图像的描述与彩色图像一样仍然反映了整幅图像的整体和局部的色度和亮度等级的分布和特征。图像的灰度化处理可用两种方法来实现。<br>&emsp;&emsp;第一种方法是求出每个像素点的<code>R、G、B</code>三个分量的<code>平均值</code>，然后将这个平均值赋予给这个像素的三个分量。第二种方法是根据<code>YUV</code>的颜色空间中，<code>Y</code>的分量的物理意义是点的亮度，由该值反映亮度等级，根据<code>RGB</code>和<code>YUV</code>颜色空间的变化关系可建立亮度<code>Y</code>与<code>R、G、B</code>三个颜色分量的对应：<code>Y=0.3R+0.59G+0.11B</code>，以这个亮度值表达图像的灰度值。(一般采用第二种方法。)<br>&emsp;&emsp;<code>opencv</code>中实现：<code>cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</code></p>
</li>
<li><p>二值化<br>&emsp;&emsp;将图像上点的灰度置为0或255的过程称为二值化处理，也就是将整个图像呈现出明显的黑白效果(非黑即白)。<br>&emsp;&emsp;所有灰度大于或等于阀值的像素被判定为属于特定物体，其灰度值为<code>255</code>表示，否则这些像素点被排除在物体区域以外，灰度值为<code>0</code>，表示背景或者例外的物体区域。<br>&emsp;&emsp;<code>opencv</code>中实现：<code>cv2.threshold(src, threshold, maxValue, method)</code>  </p>
</li>
<li><p>图像滤波<br>&emsp;&emsp;图像滤波，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。<br>&emsp;&emsp;高斯滤波是一种线性平滑滤波，可以消除高斯噪声。每一个像素点的值，都由其本身和领域内的其他像素值经过加权平均(高斯函数)后得到。<br>&emsp;&emsp;<code>opencv</code>中实现：<code>cv2.GaussianBlur(img, ksize, sigmaX)</code>    </p>
</li>
</ol>
<h3 id="HSV空间的二值化"><a href="#HSV空间的二值化" class="headerlink" title="HSV空间的二值化"></a>HSV空间的二值化</h3><p>&emsp;&emsp;预处理的主要思想是，先将颜色通道转换为<code>HSV</code>空间，当然也可以转到其他的颜色空间，只是实际测试下来发现，<code>HSV</code>空间更加稳定，适合比赛的环境。其次根据<code>HSV</code>空间颜色分布表，设置相应的阈值，将符合的颜色区间二值化，得到一个只有目标区域的图像分布，最后加上几个简单的滤波算法去除噪声。<br><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\HSV空间表.jpg" alt="data"><br>&emsp;&emsp;上表为<code>HSV</code>颜色空间表，即每个颜色对应的三个通道的范围。<code>HSV</code>即色相(Hue)、饱和度(Saturation)和明度(Value)。根据其范围，我们就可以将我们需要的颜色提取出来，并二值化处理。    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> cv2.cv <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetDetection</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        Target Detection：目标检测基类，主要用于图像的预处理，以便后续检测更加精确</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, img)</span>:</span></span><br><span class="line">        self.img = img</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preProcess</span><span class="params">(self, img, object)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Pre Process：预处理</span></span><br><span class="line"><span class="string">        Arguments: </span></span><br><span class="line"><span class="string">            img：图像</span></span><br><span class="line"><span class="string">            object：红球(redball)/足球(football)/黄杆(stick)</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            binImg：二值化后的图像</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> object == <span class="string">"redball"</span>:</span><br><span class="line">            HSVImg = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)       <span class="comment"># 转到HSV空间</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># HSV空间颜色判断，具体参见表格</span></span><br><span class="line">            smin1, vmin1, hmax1, hmin2 = <span class="number">9</span>, <span class="number">21</span>, <span class="number">39</span>, <span class="number">153</span>         <span class="comment"># 调用滑动条函数（sliderObjectHSV）得到理想值</span></span><br><span class="line"></span><br><span class="line">            minHSV1 = np.array([<span class="number">0</span>, smin1, vmin1])</span><br><span class="line">            maxHSV1 = np.array([hmax1, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">            minHSV2 = np.array([hmin2, smin1, vmin1])</span><br><span class="line">            maxHSV2 = np.array([<span class="number">180</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 二值化处理</span></span><br><span class="line">            binImg1 = cv2.inRange(HSVImg, minHSV1, maxHSV1)</span><br><span class="line">            binImg2 = cv2.inRange(HSVImg, minHSV2, maxHSV2)</span><br><span class="line">            binImg = np.maximum(binImg1, binImg2)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 图像滤波处理（腐蚀，膨胀，高斯）</span></span><br><span class="line">            binImg = self.filter(binImg))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'''Please input "redball" or "football" or "stick" in preProcess()'''</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> binImg  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter</span><span class="params">(self, img)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        图像滤波处理（腐蚀，膨胀，高斯）</span></span><br><span class="line"><span class="string">        Arguments: </span></span><br><span class="line"><span class="string">            img：图像</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            resImg：处理后的图像</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        kernelErosion = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">        kernelDilation = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">        resImg = cv2.erode(img, kernelErosion, iterations=<span class="number">2</span>)</span><br><span class="line">        resImg = cv2.dilate(resImg, kernelDilation, iterations=<span class="number">3</span>)    </span><br><span class="line">        resImg = cv2.GaussianBlur(resImg, (<span class="number">9</span>, <span class="number">9</span>), <span class="number">1.5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resImg</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先利用<code>cvtColor()</code>将其转换为<code>HSV</code>空间，然后由表可知目标的颜色范围，从而得到其上限和下限(红色有2个区间)，最后利用<code>inRange()</code>将其二值化。<code>inRange()</code>：将在两个阈值内的像素值设置为白色<code>(255)</code>，而不在阈值区间内的像素值设置为黑色<code>(0)</code>。 最后加个几个简单的滤波处理算法。这里给出了红球的二值化代码，足球和黄杆的代码读者可以先自行考虑。         </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    srcImg = cv2.imread(<span class="string">"./redball_1/5.jpg"</span>)          <span class="comment"># 红球</span></span><br><span class="line">    tarDet = TargetDetection(srcImg)</span><br><span class="line">    binImg = tarDet.preProcess(srcImg, <span class="string">"redball"</span>)     <span class="comment"># 红球</span></span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">"srcImg"</span>, srcImg)</span><br><span class="line">    cv2.imshow(<span class="string">"binImg"</span>, binImg)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\redball二值化.png" alt="data"><br><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\football二值化.png" alt="data"><br><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\stick二值化.png" alt="data"><br>&emsp;&emsp;为了克服比赛时场地和光线的干扰，这里的阈值参数可以通过滑动条函数来获得。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sliderObjectHSV</span><span class="params">(self, object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    HSV滑动条函数，为了获得理想的HSV阈值</span></span><br><span class="line"><span class="string">    Arguments: </span></span><br><span class="line"><span class="string">        object：红球(redball)/足球(football)/黄杆(stick)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> object == <span class="string">"redball"</span>:</span><br><span class="line">        cv2.namedWindow(<span class="string">"redball"</span>)</span><br><span class="line">        <span class="comment"># 创建滑动条</span></span><br><span class="line">        cv2.createTrackbar(<span class="string">"hmax1"</span>, <span class="string">"redball"</span>, <span class="number">1</span>, <span class="number">20</span>, self.nothing)</span><br><span class="line">        cv2.createTrackbar(<span class="string">"smin1"</span>, <span class="string">"redball"</span>, <span class="number">30</span>, <span class="number">60</span>, self.nothing)</span><br><span class="line">        cv2.createTrackbar(<span class="string">"vmin1"</span>, <span class="string">"redball"</span>, <span class="number">30</span>, <span class="number">60</span>, self.nothing)           </span><br><span class="line">        cv2.createTrackbar(<span class="string">"hmin2"</span>, <span class="string">"redball"</span>, <span class="number">156</span>, <span class="number">175</span>, self.nothing)</span><br><span class="line"></span><br><span class="line">        img = self.img.copy()</span><br><span class="line">        HSVImg = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            srcImg = img.copy()</span><br><span class="line">            <span class="comment"># 获取滑动条的值</span></span><br><span class="line">            hmax1 = cv2.getTrackbarPos(<span class="string">"hmax1"</span>, <span class="string">"redball"</span>)</span><br><span class="line">            smin1 = cv2.getTrackbarPos(<span class="string">"smin1"</span>, <span class="string">"redball"</span>)</span><br><span class="line">            vmin1 = cv2.getTrackbarPos(<span class="string">"vmin1"</span>, <span class="string">"redball"</span>)</span><br><span class="line">            hmin2 = cv2.getTrackbarPos(<span class="string">"hmin2"</span>, <span class="string">"redball"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># HSV空间颜色判断</span></span><br><span class="line">            minHSV1 = np.array([<span class="number">0</span>, smin1, vmin1])</span><br><span class="line">            maxHSV1 = np.array([hmax1, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line"></span><br><span class="line">            minHSV2 = np.array([hmin2, smin1, vmin1])</span><br><span class="line">            maxHSV2 = np.array([<span class="number">180</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line"></span><br><span class="line">            binImg1 = cv2.inRange(HSVImg, minHSV1, maxHSV1)</span><br><span class="line">            binImg2 = cv2.inRange(HSVImg, minHSV2, maxHSV2)</span><br><span class="line">            binImg = np.maximum(binImg1, binImg2)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 图像滤波处理</span></span><br><span class="line">            binImg = self.filter(binImg)</span><br><span class="line"></span><br><span class="line">            cv2.imshow(<span class="string">"srcImg"</span>, img)</span><br><span class="line">            cv2.imshow(<span class="string">"redball"</span>, binImg)</span><br><span class="line">            cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">        cv2.destroyAllWindows() </span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'''Please input "redball" or "football" or "stick" in sliderObjectHSV()'''</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothing</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将其<code>HSV</code>空间的临界值设置为滑动条参数即可。现场调试时，根据实际情况选择一个最优的参数。这里同样只给出红球的代码实例。       </p>
<h2 id="霍夫圆检测"><a href="#霍夫圆检测" class="headerlink" title="霍夫圆检测"></a>霍夫圆检测</h2><p>&emsp;&emsp;针对NAO比赛中的<code>红球和足球</code>，我们可以采用<code>opencv</code>中的霍夫圆检测技术将其检测出来。其函数声明为：<code>HoughCircles(img, method, dp, minDist, param1=100, param2=100, minRadius=0, maxRadius=0)</code>，其中<code>method</code>一般为霍夫梯度法，即<code>cv2.cv.CV_HOUGH_GRADIENT</code>，<code>dp=1</code>, <code>param1=100, param2=20</code>，比较重要的参数是圆之间的距离<code>minDist</code>，圆的最小和最大半径<code>minRadius</code>和<code>maxRadius</code>。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoughDetection</span><span class="params">(TargetDetection)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Hough Detection：霍夫圆检测</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, img)</span>:</span></span><br><span class="line">        super(HoughDetection, self).__init__(img)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">houghDetection</span><span class="params">(self, img, minDist=<span class="number">100</span>, minRadius=<span class="number">25</span>, maxRadius=<span class="number">80</span>, isShow=False)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        霍夫圆检测</span></span><br><span class="line"><span class="string">        Arguments: </span></span><br><span class="line"><span class="string">            img：图像</span></span><br><span class="line"><span class="string">            minDist：两圆之间最小间距</span></span><br><span class="line"><span class="string">            minRadius：圆的最小半径</span></span><br><span class="line"><span class="string">            maxRadius：圆的最大半径</span></span><br><span class="line"><span class="string">            isShow：是否显示结果</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            circles：检测出来的圆</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        srcImg = self.img.copy()</span><br><span class="line">        circles = cv2.HoughCircles(img, cv.CV_HOUGH_GRADIENT, <span class="number">1</span>, minDist, </span><br><span class="line">                                   param1=<span class="number">100</span>, param2=<span class="number">20</span>, minRadius=minRadius, maxRadius=maxRadius)    </span><br><span class="line">        <span class="keyword">if</span> circles <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            circles = []</span><br><span class="line">            print(<span class="string">"no circle"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            circles = circles[<span class="number">0</span>, ]</span><br><span class="line">            <span class="keyword">if</span> isShow <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                self.showHoughResult(srcImg, circles)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> circles</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">circle2Rect</span><span class="params">(self, circle, k=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        圆的信息转换为矩阵信息，以便后续处理</span></span><br><span class="line"><span class="string">        Arguments: </span></span><br><span class="line"><span class="string">            circle：圆的信息：圆心坐标，半径</span></span><br><span class="line"><span class="string">            k：放缩因子</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            rect：矩阵信息：左上角和右下角的坐标</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        rect = []</span><br><span class="line">        x, y, r = int(circle[<span class="number">0</span>]), int(circle[<span class="number">1</span>]), int(circle[<span class="number">2</span>])</span><br><span class="line">        initX, initY = x - k * r, y - k * r</span><br><span class="line">        endX, endY = x + k * r, y + k * r</span><br><span class="line">        rect = [initX, initY, endX, endY]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rect</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showHoughResult</span><span class="params">(self, img, circles, timeMs=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        显示霍夫圆检测结果</span></span><br><span class="line"><span class="string">        Arguments: </span></span><br><span class="line"><span class="string">            img：图像</span></span><br><span class="line"><span class="string">            circles：圆</span></span><br><span class="line"><span class="string">            timeMs：延迟时间，0表示一直显示</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> circle <span class="keyword">in</span> circles:</span><br><span class="line">            rect = self.circle2Rect(circle)</span><br><span class="line">            initX, initY = rect[<span class="number">0</span>], rect[<span class="number">1</span>]</span><br><span class="line">            endX, endY = rect[<span class="number">2</span>], rect[<span class="number">3</span>]</span><br><span class="line">            cv2.rectangle(img, (initX, initY), (endX, endY), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)    <span class="comment"># 画矩形</span></span><br><span class="line"></span><br><span class="line">            x, y, r = int(circle[<span class="number">0</span>]), int(circle[<span class="number">1</span>]), int(circle[<span class="number">2</span>])</span><br><span class="line">            cv2.circle(img, (x, y), r, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)                          <span class="comment"># 画圆</span></span><br><span class="line"></span><br><span class="line">        cv2.imshow(<span class="string">"Hough Result"</span>, img)</span><br><span class="line">        cv2.waitKey(timeMs)</span><br><span class="line">        cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在调用霍夫圆检测时，首先要将图片进行预处理。这里将比较重要的3个参数作为函数的参数，以便后续的红球和足球的处理。<code>circle2Rect</code>函数的作用是将圆的信息转换为矩阵的信息，并提供一个比例的参数接口，以便后续的矩形区域的调整，<code>showHoughResult</code>函数的作用是在原图中画出圆和矩阵。<br>&emsp;&emsp;下面进行简单的测试，首选读取一张带有红球/足球的图片，然后创建对象并调用预处理方法和霍夫圆检测方法，并将<code>isShow</code>的参数设置为<code>True</code>将其结果显示出来。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    srcImg = cv2.imread(<span class="string">"./redball_1/5.jpg"</span>)            <span class="comment"># 红球</span></span><br><span class="line">    <span class="comment"># srcImg = cv2.imread("./img_1/5.jpg")              # 足球</span></span><br><span class="line">    hogDet = HoughDetection(srcImg)</span><br><span class="line">    binImg = hogDet.preProcess(srcImg, <span class="string">"redball"</span>)      <span class="comment"># 红球</span></span><br><span class="line">    <span class="comment"># binImg = hogDet.preProcess(srcImg, "football")   # 足球</span></span><br><span class="line">    hogDet.houghDetection(binImg, minDist=<span class="number">100</span>, minRadius=<span class="number">10</span>, maxRadius=<span class="number">50</span>, isShow=<span class="literal">True</span>)   <span class="comment"># 红球</span></span><br><span class="line">    <span class="comment"># hogDet.houghDetection(binImg, minDist=100, minRadius=25, maxRadius=80, isShow=True)  # 足球</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\hougtRedball.png" alt="data"><br><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\hougtFootball.png" alt="data"><br>&emsp;&emsp;实际测试发现，经过二值化处理后再用霍夫圆检测的效果要比之前直接霍夫圆检测好很多，基本上每次都能选中目标区域。<br>&emsp;&emsp;注：实际测试发现，足球用霍夫圆检测效果并不是太好，轮廓检测(见下文分析)对于足球效果更好。可能因为红球是纯色，二值化后圆的特征比较明显，而足球呈黑白色，圆的特征不是太明显。    </p>
<h2 id="轮廓检测"><a href="#轮廓检测" class="headerlink" title="轮廓检测"></a>轮廓检测</h2><p>&emsp;&emsp;而对于NAO比赛中的<code>黄杆</code>，我们可以采用<code>opencv</code>中的轮廓检测算法。其函数声明为：<code>cv2.findContours(image, mode, method[, contours[, hierarchy[, offset ]]])</code>，其中<code>mode</code>表示轮廓的检索模式，这里选择<code>cv2.RETR_EXTERNAL</code>，即只检测外轮廓，<code>method</code>表示轮廓的近似办法，这里选择<code>cv2.CHAIN_APPROX_NONE</code>，即存储所有的轮廓点。其返回值有2个，<code>contours</code>和<code>hierarchy</code>，分别表示轮廓本身和每条轮廓对应的属性。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContoursDetection</span><span class="params">(TargetDetection)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, img)</span>:</span></span><br><span class="line">        super(ContoursDetection, self).__init__(img)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">contoursDetection</span><span class="params">(self, img, minPerimeter=<span class="number">300</span>, mink=<span class="number">2</span>, isShow=False)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        轮廓检测</span></span><br><span class="line"><span class="string">        Arguments: </span></span><br><span class="line"><span class="string">            img：图像</span></span><br><span class="line"><span class="string">            minPerimeter：轮廓最小周长</span></span><br><span class="line"><span class="string">            isShow：是否显示结果</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            resultContours：检测出来的轮廓</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        srcImg = self.img.copy()</span><br><span class="line">        rects = []</span><br><span class="line">        contours, _ = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)</span><br><span class="line"></span><br><span class="line">        resultContours = []</span><br><span class="line">        <span class="comment"># 简单的轮廓周长及长宽比判断</span></span><br><span class="line">        <span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">            x, y, w, h = cv2.boundingRect(contour)</span><br><span class="line">            k = h / w</span><br><span class="line">            perimeter = cv2.arcLength(contour, <span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">if</span> perimeter &gt; minPerimeter <span class="keyword">and</span> k &gt;= mink:</span><br><span class="line">                resultContours.append(contour)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> resultContours == []:</span><br><span class="line">            print(<span class="string">"no contours"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> isShow <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                self.showContourResult(srcImg, resultContours)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultContours</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showContourResult</span><span class="params">(self, img, contours, timeMs=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        显示轮廓检测结果</span></span><br><span class="line"><span class="string">        Arguments: </span></span><br><span class="line"><span class="string">            img：图像</span></span><br><span class="line"><span class="string">            contours：轮廓</span></span><br><span class="line"><span class="string">            timeMs：延迟时间，0表示一直显示</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        cv2.drawContours(img, contours, <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 画出轮廓的外接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">            rect = self.contour2Rect(contour)     </span><br><span class="line">            cv2.rectangle(img, (rect[<span class="number">0</span>], rect[<span class="number">1</span>]), (rect[<span class="number">2</span>], rect[<span class="number">3</span>]), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        cv2.imshow(<span class="string">"Contour_result"</span>, img)</span><br><span class="line">        cv2.waitKey(timeMs)</span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">contour2Rect</span><span class="params">(self, contour)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        轮廓的信息转换为矩阵信息，以便后续处理</span></span><br><span class="line"><span class="string">        Arguments: </span></span><br><span class="line"><span class="string">            contour：轮廓的信息：若干个点组成的轮廓</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            rect：矩阵信息：左上角和右下角的坐标</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        rect = []</span><br><span class="line">        x, y, w, h = cv2.boundingRect(contour)      <span class="comment"># 返回值为外接矩阵的顶点坐标和长宽</span></span><br><span class="line"></span><br><span class="line">        rect = [x, y, x + w, y + h]</span><br><span class="line">        <span class="keyword">return</span> rect</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该轮廓算法是将所有的轮廓都检测出来，但其中有些结果并不是我们所需要的，所以我们可以采用一些简单的判断条件进行筛选，比如轮廓的周长和轮廓矩形的长宽比等，并将其作为函数的参数以便实际比赛时候的调整。<code>contour2Rect</code>函数的作用是将轮廓的信息转换为矩阵的信息，<code>showContourResult</code>函数的作用是在原图中画出轮廓和矩阵。<br>&emsp;&emsp;下面进行简单的测试，首选读取一张带有黄杆的图片，然后创建对象并调用预处理方法和轮廓检测方法，并将<code>isShow</code>的参数设置为<code>True</code>将其结果显示出来。<br><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\code.png" alt="data">   </p>
<p><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\counterStick.png" alt="data">    </p>
<h1 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h1><p>&emsp;&emsp;检测到目标后，下面就要对其进行特征的提取，从而获得分类器的输入向量。和之前候选区域的提取一样，将所有的特征提取方法封装成一个类，并统一返回向量(列表)的形式。     </p>
<h2 id="球类目标颜色特征"><a href="#球类目标颜色特征" class="headerlink" title="球类目标颜色特征"></a>球类目标颜色特征</h2><p>&emsp;&emsp;首先对于足球和红球最容易想到的就是其颜色特征，之前初级版的设计只是简单的判断颜色所占比例，这并不是一个非常好的标准，因为受到光线等其他因素的影响，在图像中实际的颜色并非我们想象的那样，所以我们采用另一种判断标准。<br>&emsp;&emsp;将每个通道的颜色区间分为若干份，即将<code>[0, 255]</code>区间分成若干个子区间，一般取<code>16</code>比较适中，然后分别统计每个通道的每个像素点属于哪一个子区间，最后统计每个子区间有多少个像素点。例如，<code>R</code>通道的第1个像素点的值为<code>46</code>，属于<code>[32, 47]</code>这个区间，则该区间就<code>+1</code>。这样一共有<code>3*16=48</code>个特征向量，<code>3</code>表示3个通道，<code>16</code>表示16个区间，当然也可以取其他值。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorFeature</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, img, number=<span class="number">16</span>)</span>:</span></span><br><span class="line">        self.img = img</span><br><span class="line">        self.number = number</span><br><span class="line">        <span class="keyword">assert</span> type(self.number % <span class="number">16</span>) == int, <span class="string">"number should be divided by 16."</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitChannal</span><span class="params">(self, img)</span>:</span></span><br><span class="line">        <span class="comment"># 分离通道</span></span><br><span class="line">        Channel1, Channel2, Channel3 = cv2.split(img)</span><br><span class="line">        Channel1, Channel2, Channel3 = Channel1.flatten(), Channel2.flatten(), Channel3.flatten()</span><br><span class="line">        Channels = [Channel1, Channel2, Channel3]</span><br><span class="line">        <span class="keyword">return</span> Channels</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">colorExtract</span><span class="params">(self, img)</span>:</span></span><br><span class="line">        <span class="comment"># 颜色提取</span></span><br><span class="line">        Channels = self.splitChannal(img)</span><br><span class="line">        size = Channels[<span class="number">0</span>].shape[<span class="number">0</span>]    </span><br><span class="line">        colorVector = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> Channel <span class="keyword">in</span> Channels:          </span><br><span class="line">            Channel = Channel / self.number    <span class="comment"># 商即为分类类别</span></span><br><span class="line">            Channel = np.append(Channel, <span class="number">15</span>)</span><br><span class="line">            colorVector.extend(np.round((<span class="number">1.0</span> * np.bincount(Channel) / size), <span class="number">4</span>))   <span class="comment"># 统计个数，并计算概率</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> colorVector</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先通过<code>opencv</code>中的<code>split()</code>方法将图像分成3个通道，然后对每个通道进行颜色特征提取。<code>Channel</code>是一个列表，包含了该通道的每个像素点的值，将其除以总区间个数就可以知道属于第几个区间。例如刚才的像素值<code>46</code>，因为<code>46/16=2</code>，所以属于第<code>2</code>个区间(区间从<code>0</code>开始计)，也就是<code>[32, 47]</code>这个区间，即之前的像素点<code>46</code>转换为现在的区间类别<code>2</code>。然后在利用<code>numpy</code>中的<code>bincount()</code>统计方法计算每个区间有多少个像素，注意这里最好在<code>Channel</code>中添加一个元素<code>15</code>，因为图像中不一定存在第16个区间内的像素值，如果不存在，则特征向量的个数就会不同，影响后续的分类器训练，最后在除以总像素个数得到归一化的结果并保留4位小数。<br>&emsp;&emsp;注：<code>python3</code>中需要用<code>//</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    img = cv2.imread(<span class="string">"./img_3/1.jpg"</span>)</span><br><span class="line">    colorFeature = ColorFeature(img)</span><br><span class="line">    colorVector = colorFeature.colorExtract(img)</span><br><span class="line">    print(len(colorVector), colorVector)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">48</span>, [<span class="number">0.0158</span>, <span class="number">0.0035</span>, <span class="number">0.0037</span>, <span class="number">0.0083</span>, <span class="number">0.0254</span>, <span class="number">0.1115</span>, <span class="number">0.226</span>, <span class="number">0.2418</span>, <span class="number">0.1169</span>, <span class="number">0.065</span>, <span class="number">0.0429</span>, <span class="number">0.0272</span>, <span class="number">0.0223</span>, <span class="number">0.026</span>, <span class="number">0.0227</span>, <span class="number">0.0411</span>, <span class="number">0.0186</span>, <span class="number">0.0036</span>, <span class="number">0.0065</span>, <span class="number">0.0177</span>, <span class="number">0.0486</span>, <span class="number">0.1404</span>, <span class="number">0.1927</span>, <span class="number">0.2202</span>, <span class="number">0.1531</span>, <span class="number">0.0649</span>, <span class="number">0.028</span>, <span class="number">0.0242</span>, <span class="number">0.0265</span>, <span class="number">0.0203</span>, <span class="number">0.0125</span>, <span class="number">0.0223</span>, <span class="number">0.0201</span>, <span class="number">0.0038</span>, <span class="number">0.0057</span>, <span class="number">0.0158</span>, <span class="number">0.0486</span>, <span class="number">0.1376</span>, <span class="number">0.1863</span>, <span class="number">0.2099</span>, <span class="number">0.172</span>, <span class="number">0.0964</span>, <span class="number">0.0419</span>, <span class="number">0.0261</span>, <span class="number">0.0145</span>, <span class="number">0.0107</span>, <span class="number">0.0067</span>, <span class="number">0.0039</span>])</span><br></pre></td></tr></table></figure></p>
<h2 id="HOG特征"><a href="#HOG特征" class="headerlink" title="HOG特征"></a>HOG特征</h2><p>&emsp;&emsp;HOG特征指的是梯度方向直方图，顾名思义，就是选用梯度方向的分布作为特征。一张图像的梯度（x和y方向的导数）在边缘和拐角（强度变化剧烈的区域）处的梯度幅值很大，而且边缘和拐角比其他平坦的区域包含更多关于物体形状的信息。<br>&emsp;&emsp;首先需要将图像分成小的连通区域，称之为细胞单元。然后采集细胞单元中各像素点的梯度或边缘的方向直方图。最后把这些直方图组合起来就可以构成特征描述器。<br>&emsp;&emsp;这里主要参考了以下两篇博客的：<a href="https://blog.csdn.net/sinat_34474705/article/details/80219617" target="_blank" rel="noopener">梯度方向直方图</a>，<a href="https://blog.csdn.net/ppp8300885/article/details/71078555" target="_blank" rel="noopener">80行Python实现-HOG梯度特征提取</a>。    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HogFeature</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, img, cell_size=<span class="number">4</span>, bin_size=<span class="number">8</span>)</span>:</span></span><br><span class="line">        self.img = img</span><br><span class="line">        self.img = np.sqrt(img / float(np.max(img)))</span><br><span class="line">        self.img = self.img * <span class="number">255</span></span><br><span class="line">        self.cell_size = cell_size</span><br><span class="line">        self.bin_size = bin_size</span><br><span class="line">        self.angle_unit = <span class="number">360</span> / self.bin_size</span><br><span class="line">        <span class="keyword">assert</span> type(self.bin_size) == int, <span class="string">"bin_size should be integer,"</span></span><br><span class="line">        <span class="keyword">assert</span> type(self.cell_size) == int, <span class="string">"cell_size should be integer,"</span></span><br><span class="line">        <span class="keyword">assert</span> type(self.angle_unit) == int, <span class="string">"bin_size should be divisible by 360"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hog_extract</span><span class="params">(self)</span>:</span></span><br><span class="line">        height, width = self.img.shape</span><br><span class="line">        gradient_magnitude, gradient_angle = self.global_gradient()</span><br><span class="line">        gradient_magnitude = abs(gradient_magnitude)</span><br><span class="line">        cell_gradient_vector = np.zeros((int(round(<span class="number">1.0</span> * height / self.cell_size)), </span><br><span class="line">                                         int(round(<span class="number">1.0</span> * width / self.cell_size)), self.bin_size))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(cell_gradient_vector.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cell_gradient_vector.shape[<span class="number">1</span>]):</span><br><span class="line">                cell_magnitude = gradient_magnitude[i * self.cell_size:(i + <span class="number">1</span>) * self.cell_size,</span><br><span class="line">                                 j * self.cell_size:(j + <span class="number">1</span>) * self.cell_size]</span><br><span class="line">                cell_angle = gradient_angle[i * self.cell_size:(i + <span class="number">1</span>) * self.cell_size,</span><br><span class="line">                             j * self.cell_size:(j + <span class="number">1</span>) * self.cell_size]</span><br><span class="line">                cell_gradient_vector[i][j] = self.cell_gradient(cell_magnitude, cell_angle)</span><br><span class="line"></span><br><span class="line">        hog_image = self.render_gradient(np.zeros([height, width]), cell_gradient_vector)</span><br><span class="line">        hog_vector = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(cell_gradient_vector.shape[<span class="number">0</span>] - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cell_gradient_vector.shape[<span class="number">1</span>] - <span class="number">1</span>):</span><br><span class="line">                block_vector = []</span><br><span class="line">                block_vector.extend(cell_gradient_vector[i][j])</span><br><span class="line">                block_vector.extend(cell_gradient_vector[i][j + <span class="number">1</span>])</span><br><span class="line">                block_vector.extend(cell_gradient_vector[i + <span class="number">1</span>][j])</span><br><span class="line">                block_vector.extend(cell_gradient_vector[i + <span class="number">1</span>][j + <span class="number">1</span>])</span><br><span class="line">                mag = <span class="keyword">lambda</span> vector: math.sqrt(sum(i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> vector))</span><br><span class="line">                magnitude = mag(block_vector)</span><br><span class="line">                <span class="keyword">if</span> magnitude != <span class="number">0</span>:</span><br><span class="line">                    normalize = <span class="keyword">lambda</span> block_vector, magnitude: [element / magnitude <span class="keyword">for</span> element <span class="keyword">in</span> block_vector]</span><br><span class="line">                    block_vector = normalize(block_vector, magnitude)</span><br><span class="line">                hog_vector.append(block_vector)</span><br><span class="line">        <span class="keyword">return</span> hog_vector, hog_image</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">global_gradient</span><span class="params">(self)</span>:</span></span><br><span class="line">        gradient_values_x = cv2.Sobel(self.img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">5</span>)</span><br><span class="line">        gradient_values_y = cv2.Sobel(self.img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">5</span>)</span><br><span class="line">        gradient_magnitude = cv2.addWeighted(gradient_values_x, <span class="number">0.5</span>, gradient_values_y, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">        gradient_angle = cv2.phase(gradient_values_x, gradient_values_y, angleInDegrees=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> gradient_magnitude, gradient_angle</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cell_gradient</span><span class="params">(self, cell_magnitude, cell_angle)</span>:</span></span><br><span class="line">        orientation_centers = [<span class="number">0</span>] * self.bin_size</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(cell_magnitude.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cell_magnitude.shape[<span class="number">1</span>]):</span><br><span class="line">                gradient_strength = cell_magnitude[i][j]</span><br><span class="line">                gradient_angle = cell_angle[i][j]</span><br><span class="line">                min_angle, max_angle, mod = self.get_closest_bins(gradient_angle)</span><br><span class="line">                orientation_centers[min_angle] += (gradient_strength * (<span class="number">1</span> - (mod / self.angle_unit)))</span><br><span class="line">                orientation_centers[max_angle] += (gradient_strength * (mod / self.angle_unit))</span><br><span class="line">        <span class="keyword">return</span> orientation_centers</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_closest_bins</span><span class="params">(self, gradient_angle)</span>:</span></span><br><span class="line">        idx = int(gradient_angle / self.angle_unit)</span><br><span class="line">        mod = gradient_angle % self.angle_unit</span><br><span class="line">        <span class="keyword">if</span> idx == self.bin_size:</span><br><span class="line">            <span class="keyword">return</span> idx - <span class="number">1</span>, (idx) % self.bin_size, mod</span><br><span class="line">        <span class="keyword">return</span> idx, (idx + <span class="number">1</span>) % self.bin_size, mod</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render_gradient</span><span class="params">(self, image, cell_gradient)</span>:</span></span><br><span class="line">        cell_width = self.cell_size / <span class="number">2</span></span><br><span class="line">        max_mag = np.array(cell_gradient).max()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(cell_gradient.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(cell_gradient.shape[<span class="number">1</span>]):</span><br><span class="line">                cell_grad = cell_gradient[x][y]</span><br><span class="line">                cell_grad /= max_mag</span><br><span class="line">                angle = <span class="number">0</span></span><br><span class="line">                angle_gap = self.angle_unit</span><br><span class="line">                <span class="keyword">for</span> magnitude <span class="keyword">in</span> cell_grad:</span><br><span class="line">                    angle_radian = math.radians(angle)</span><br><span class="line">                    x1 = int(x * self.cell_size + magnitude * cell_width * math.cos(angle_radian))</span><br><span class="line">                    y1 = int(y * self.cell_size + magnitude * cell_width * math.sin(angle_radian))</span><br><span class="line">                    x2 = int(x * self.cell_size - magnitude * cell_width * math.cos(angle_radian))</span><br><span class="line">                    y2 = int(y * self.cell_size - magnitude * cell_width * math.sin(angle_radian))</span><br><span class="line">                    cv2.line(image, (y1, x1), (y2, x2), int(<span class="number">255</span> * math.sqrt(magnitude)))</span><br><span class="line">                    angle += angle_gap</span><br><span class="line">        <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\HOG特征.png" alt="data"><br>&emsp;&emsp;首先在一幅图中选取若干像素组合成一个<code>cell</code>，例如<code>8*8</code>个像素，然后选取<code>2*2</code>个<code>cell</code>，即<code>16*16</code>个像素，组合成一个<code>block</code>。然后将<code>0°-360°</code>划分为若干个区间，比如<code>8</code>个区间，在这8个区间内，统计每个<code>block</code>中的每个<code>cell</code>中的梯度方向直方图(具体见博客)，所以一个<code>block</code>有<code>4*8=32</code>个特征向量(因为一个<code>block</code>有<code>4</code>个<code>cell</code>，<code>1</code>个<code>cell</code>有<code>8</code>个直方图特征)，然后按照<code>step</code>的大小在图像中移动<code>block</code>，通常<code>step</code>设置为一个<code>cell</code>的大小，即下次移动的时候会和之前的有重复。最后统计一幅图中有多少个<code>block</code>即可算出所有的特征向量个数。例如一个<code>640*480</code>的原始图，其横向有<code>640/8-1=79</code>个<code>block</code>，纵向有<code>480/8-1=59</code>个<code>block</code>,那么其特征向量一个有<code>79*59=4661</code>个，每一个都是一个<code>32</code>维的向量。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    img = cv2.imread(<span class="string">"./img_3/1.jpg"</span>)</span><br><span class="line">    img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    </span><br><span class="line">    hogFeature = HogFeature(img)        </span><br><span class="line">    hogVector, _ = hogFeature.hog_extract()  </span><br><span class="line">    print(np.array(hogVector).shape)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输出结果为<code>(4661, 32)</code>。当然了，这是整幅图的特征向量，实际的特征提取中，只是针对候选区域的(不会太大)，所以我们可以将整个候选区域当作一个<code>block</code>，这样特征向量的个数就缩减为<code>32</code>个。    </p>
<h1 id="分类器"><a href="#分类器" class="headerlink" title="分类器"></a>分类器</h1><p>&emsp;&emsp;有了特征向量后，我们就可以选择分类器来训练模型。   </p>
<h2 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h2><p>&emsp;&emsp;Logistic回归是一个简单的线性二分类的分类算法，其基本原理就是在每个特征上都乘以一个回归系数，然后把所有的结果相加，将这个总和代入到<code>Sigmoid</code>函数中，进而得到一个范围在<code>0~1</code>之间的数值，最后判断当大于<code>0.5</code>的时候就被分为<code>1</code>类，小于<code>0.5</code>就被分为<code>0</code>类。<br><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\logist公式.png" alt="data"><br>&emsp;&emsp;<code>x</code>即输入的特征向量，<code>w</code>即回归系数。下面的问题就是如何找到<code>w</code>的最优解。这里我们采用的优化算法是<code>梯度上升法</code>。其<code>w</code>的更新公式为：<br><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\参数更新.png" alt="data"><br>&emsp;&emsp;程序实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding uft-8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logistic</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename, maxCycle)</span>:</span></span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.maxCycle = maxCycle</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadDateSet</span><span class="params">(self)</span>:</span></span><br><span class="line">        data = np.loadtxt(self.filename)</span><br><span class="line">        dataMat = data[:, <span class="number">0</span>: <span class="number">-1</span>]</span><br><span class="line">        classLabels = data[:, <span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># dataMat = np.insert(dataMat, 0, 1, axis=1)</span></span><br><span class="line">        <span class="keyword">return</span> dataMat, classLabels</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gradDescent</span><span class="params">(self, dataMat, classLabels)</span>:</span></span><br><span class="line">        dataMatrix = np.mat(dataMat)  </span><br><span class="line">        labelMat = np.mat(classLabels).transpose()</span><br><span class="line">        m, n = np.shape(dataMatrix)</span><br><span class="line">        weights = np.ones((n, <span class="number">1</span>))  </span><br><span class="line">        alpha = <span class="number">0.001</span>    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.maxCycle):</span><br><span class="line">            h = self.sigmoid(dataMatrix * weights)  </span><br><span class="line">            error = labelMat - h</span><br><span class="line">            weights = weights + alpha * dataMatrix.transpose() * error </span><br><span class="line">        <span class="keyword">return</span> np.round(weights, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">classifyVector</span><span class="params">(self, inX, weights)</span>:</span></span><br><span class="line">        prob = self.sigmoid(sum(np.dot(inX, weights)))</span><br><span class="line">        <span class="keyword">return</span> prob</span><br></pre></td></tr></table></figure></p>
<h1 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h1><p>&emsp;&emsp;有了特征向量和分类器，我们就可以训练模型了。模型中分为正样本和负样本，其训练方法也是不同的。   </p>
<h2 id="球类目标"><a href="#球类目标" class="headerlink" title="球类目标"></a>球类目标</h2><h3 id="正样本"><a href="#正样本" class="headerlink" title="正样本"></a>正样本</h3><p>&emsp;&emsp;对于正样本来说，通常的做法是利用数据标注来获得候选区域。常用的数据标注软件有<code>labelImg</code>。该软件不用安装，且使用方法十分简单(自行百度下载)。<br>&emsp;&emsp;打开软件后，首先选择<code>Open Dir</code>打开图像文件夹，然后选择<code>Change Save Dir</code>选择要保存的<code>xml</code>文件的文件路径（标注完成后会生成一个<code>xml</code>文件存放标注信息），然后点击<code>Create RectBox</code>创建矩形，<br><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\标注1.png" alt="data"><br>&emsp;&emsp;在需要的区域拖拽鼠标即可，然后在弹出的对话框中选择类别的名称，最后点击<code>save</code>保存，并选择<code>Next Image</code>切换到下一张。<br><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\标注2.png" alt="data"><br>&emsp;&emsp;下面就要从生成的<code>xml</code>文件中提取出我们需要的信息。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">annotation</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">folder</span>&gt;</span>img_2<span class="tag">&lt;/<span class="name">folder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filename</span>&gt;</span>0.jpg<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">path</span>&gt;</span>D:\NAO\visual_cxx\img_2\0.jpg<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">database</span>&gt;</span>Unknown<span class="tag">&lt;/<span class="name">database</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">size</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">width</span>&gt;</span>640<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">height</span>&gt;</span>480<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">depth</span>&gt;</span>3<span class="tag">&lt;/<span class="name">depth</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">segmented</span>&gt;</span>0<span class="tag">&lt;/<span class="name">segmented</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">object</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>ball<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">pose</span>&gt;</span>Unspecified<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">truncated</span>&gt;</span>0<span class="tag">&lt;/<span class="name">truncated</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">difficult</span>&gt;</span>0<span class="tag">&lt;/<span class="name">difficult</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bndbox</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xmin</span>&gt;</span>47<span class="tag">&lt;/<span class="name">xmin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ymin</span>&gt;</span>315<span class="tag">&lt;/<span class="name">ymin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xmax</span>&gt;</span>189<span class="tag">&lt;/<span class="name">xmax</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ymax</span>&gt;</span>454<span class="tag">&lt;/<span class="name">ymax</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bndbox</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">annotation</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这是其中的一个<code>xml</code>文件，可以看出我们想要的信息在<code>object</code>项中的第1个和第4个中，即<code>name</code>和<code>bndbox</code>中。利用python内置的<code>ElementTree</code>库就可以解析出我们想要的结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding uft-8</span></span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseXml</span><span class="params">(xml_file)</span>:</span></span><br><span class="line">    classes_num = &#123;<span class="string">"ball"</span>: <span class="number">1</span>, <span class="string">"noball"</span>: <span class="number">0</span>&#125;</span><br><span class="line">    labels = []</span><br><span class="line">    tree = ET.parse(xml_file)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> root:</span><br><span class="line">        <span class="keyword">if</span> item.tag == <span class="string">"object"</span>:</span><br><span class="line">            obj_name = item[<span class="number">0</span>].text  </span><br><span class="line">            obj_num = classes_num[obj_name]</span><br><span class="line">            xmin = int(item[<span class="number">4</span>][<span class="number">0</span>].text)</span><br><span class="line">            ymin = int(item[<span class="number">4</span>][<span class="number">1</span>].text)</span><br><span class="line">            xmax = int(item[<span class="number">4</span>][<span class="number">2</span>].text)</span><br><span class="line">            ymax = int(item[<span class="number">4</span>][<span class="number">3</span>].text)</span><br><span class="line">            labels.append([xmin, ymin, xmax, ymax, obj_num])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> labels</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;返回的<code>labels</code>列表就包括了候选矩形区域的2个顶点坐标及类别。   </p>
<p>&emsp;&emsp;接下来就是使用之前的特征提取和分类器进行离线训练，在训练之前，我们针对模型进行小小的改进。将整个候选区域分成若干份，比如分成4份，每份都执行同样的特征提取，这样既增加了特征向量的个数，也提高了模型的鲁棒性。<br>&emsp;&emsp;候选区域一般为矩形，所以直接上下等分即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reshapeBallRect</span><span class="params">(rawRect, numbers)</span>:</span></span><br><span class="line">    n = int(math.sqrt(numbers)) + <span class="number">1</span></span><br><span class="line">    newPoint = np.zeros((n, n, <span class="number">2</span>))</span><br><span class="line">    newRect = np.zeros((n - <span class="number">1</span>, n - <span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line">    initX, initY, endX, endY = rawRect[<span class="number">0</span>], rawRect[<span class="number">1</span>], rawRect[<span class="number">2</span>], rawRect[<span class="number">3</span>]    <span class="comment"># 初始化参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找出每个小矩阵的顶点坐标</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            newPoint[i][j][<span class="number">0</span>] = int(initX + ((endX - initX) / (n - <span class="number">1</span>) * j))</span><br><span class="line">            newPoint[i][j][<span class="number">1</span>] = int(initY + ((endY - initY) / (n - <span class="number">1</span>) * i))     </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据坐标构造新矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            newInitX, newInitY = int(newPoint[<span class="number">0</span> + i][<span class="number">0</span> + j][<span class="number">0</span>]), int(newPoint[<span class="number">0</span> + i][<span class="number">0</span> + j][<span class="number">1</span>])</span><br><span class="line">            newEndX, newEndY = int(newPoint[<span class="number">1</span> + i][<span class="number">1</span> + j][<span class="number">0</span>]), int(newPoint[<span class="number">1</span> + i][<span class="number">1</span> + j][<span class="number">1</span>])</span><br><span class="line">            newRect[i][j][<span class="number">0</span>], newRect[i][j][<span class="number">1</span>], newRect[i][j][<span class="number">2</span>], newRect[i][j][<span class="number">3</span>] = newInitX, newInitY, newEndX, newEndY</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRect</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;针对球类目标，我们选择颜色和HOG特征提取：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calColorFeature</span><span class="params">(img, number=<span class="number">16</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 计算颜色特征</span></span><br><span class="line">    color = ColorFeature(img, number)</span><br><span class="line">    result = color.colorExtract(img)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.round(result, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calHOGFeature</span><span class="params">(img, cell_size)</span>:</span></span><br><span class="line">    <span class="comment"># 计算HOG特征</span></span><br><span class="line">    rectBallArea = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    </span><br><span class="line">    hog = HogFeature(rectBallArea, cell_size)        </span><br><span class="line">    vector, image = hog.hog_extract() </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.round(vector[<span class="number">0</span>], <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;最后统一保留4位小数。   </p>
<p>&emsp;&emsp;然后就是采集大量的正样本图片(越多越好，至少上百张)，最后将这些特征向量全部合并到一个列表中，并保存到<code>txt</code>文件里，以便后续分类器的处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calPosVector</span><span class="params">(writeFilename, labelNumbers)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(writeFilename, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(labelNumbers):</span><br><span class="line">            print(<span class="string">'test '</span> + str(i))</span><br><span class="line">            resultTotal = []</span><br><span class="line">            xmlFile = <span class="string">"./label_2/"</span> + str(i) + <span class="string">".xml"</span></span><br><span class="line">            labels = parseXml(xmlFile)</span><br><span class="line"></span><br><span class="line">            img = cv2.imread(<span class="string">"./img_2/"</span> + str(i) + <span class="string">".jpg"</span>) </span><br><span class="line"></span><br><span class="line">            initX, initY, endX, endY = labels[<span class="number">0</span>][<span class="number">0</span>], labels[<span class="number">0</span>][<span class="number">1</span>], labels[<span class="number">0</span>][<span class="number">2</span>], labels[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">            Rect = [initX, initY, endX, endY]     </span><br><span class="line">            newRects = reshapeHoughRect(Rect, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> newRectRow <span class="keyword">in</span> newRects:</span><br><span class="line">                <span class="keyword">for</span> newRect <span class="keyword">in</span> newRectRow:</span><br><span class="line">                    newInitX, newInitY = int(newRect[<span class="number">0</span>]), int(newRect[<span class="number">1</span>])</span><br><span class="line">                    newEndX, newEndY = int(newRect[<span class="number">2</span>]), int(newRect[<span class="number">3</span>])</span><br><span class="line">                    rectBallArea = img[newInitY:newEndY, newInitX:newEndX, :]   <span class="comment"># 矩形区域(宽，高，通道)                    </span></span><br><span class="line">                    cv2.rectangle(img, (newInitX, newInitY), (newEndX, newEndY), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)  <span class="comment"># 画矩形               </span></span><br><span class="line"></span><br><span class="line">                    resultColor = calColorFeature(rectBallArea, <span class="number">16</span>)  </span><br><span class="line">                    cellSize = min(newEndX - newInitX, newEndY - newInitY)</span><br><span class="line">                    result_HOG = calHOGFeature(rectBallArea, cellSize / <span class="number">2</span>)              </span><br><span class="line">                    resultTotal.extend(resultColor)</span><br><span class="line">                    resultTotal.extend(result_HOG)   </span><br><span class="line">            print(<span class="string">'resultTotal'</span>, len(resultTotal)) </span><br><span class="line"></span><br><span class="line">            cv2.imshow(<span class="string">"Original"</span>, img)</span><br><span class="line">            cv2.waitKey(<span class="number">0</span>)      </span><br><span class="line">            row = <span class="string">' '</span>.join(list(map(str, resultTotal))) + <span class="string">' '</span> + str(labels[<span class="number">0</span>][<span class="number">4</span>]) + <span class="string">'\n'</span></span><br><span class="line">            f.write(row)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;首先从标注文件<code>xml</code>中获得<code>lables</code>信息，然后依次打开正样本图片，并根据信息获得其中的候选区域，再对其<code>4</code>等分处理，对每一个等分矩阵进行<code>颜色</code>和<code>HOG</code>特征的提取，注意此时的<code>HOG</code>特征中的<code>block</code>区域为整个等分矩阵区域，所以其<code>cell_size</code>大小的选取应为长宽中的最小值的一半。（<code>cell_size</code>一般为<code>block</code>的一半）。所以单个等分矩阵的HOG特征的特征向量一共有<code>4*8=32</code>个，颜色特征的特征向量个数为<code>16*3=48</code>个，即总的候选区域的特征向量个数为<code>80*4=320</code>个。<br><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\特征向量.png" alt="data"><br>&emsp;&emsp;单张图片的实验结果，特征向量太多了，这里就不显示了。  </p>
<h3 id="负样本"><a href="#负样本" class="headerlink" title="负样本"></a>负样本</h3><p>&emsp;&emsp;而对于负样本的训练，就不能采用标注的方法了，而是直接调用之前的霍夫圆检测算法检测原图，当然了，原图不应该包含我们的球类目标，而且二值化的阈值范围要放大一点，以防止检测不出足球/红球。这里我们直接只使用灰度化处理，不进行二值化处理。其算法检测出来多少个圆就当作多少个负样本，最后在对其特征向量的提取并存放在<code>txt</code>文件中，以便后续的分类器训练。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calNegVector</span><span class="params">(writeFilename, labelNumbers)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(writeFilename, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(labelNumbers):</span><br><span class="line">            print(<span class="string">'test '</span> + str(i))         </span><br><span class="line">            srcImg = cv2.imread(<span class="string">"./img_3/"</span> + str(i) + <span class="string">".jpg"</span>) </span><br><span class="line">            hogDec = HoughDetection(srcImg)</span><br><span class="line">            preImg = cv2.cvtColor(srcImg, cv2.COLOR_BGR2GRAY) </span><br><span class="line">            circles = hogDec.houghDetection(preImg, minDist=<span class="number">100</span>, minRadius=<span class="number">25</span>, maxRadius=<span class="number">80</span>)</span><br><span class="line">            <span class="keyword">for</span> circle <span class="keyword">in</span> circles:</span><br><span class="line">                resultTotal = []</span><br><span class="line">                rect = hogDec.circle2Rect(circle)</span><br><span class="line">                <span class="keyword">if</span> rect[<span class="number">0</span>] &lt; <span class="number">0</span> <span class="keyword">or</span> rect[<span class="number">1</span>] &lt; <span class="number">0</span> <span class="keyword">or</span> rect[<span class="number">2</span>] &gt; <span class="number">640</span> <span class="keyword">or</span> rect[<span class="number">3</span>] &gt; <span class="number">480</span>:</span><br><span class="line">                    <span class="keyword">continue</span> </span><br><span class="line">                newRects = reshapeHoughRect(rect, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> newRectRow <span class="keyword">in</span> newRects:</span><br><span class="line">                    <span class="keyword">for</span> newRect <span class="keyword">in</span> newRectRow:</span><br><span class="line">                        newInitX, newInitY = int(newRect[<span class="number">0</span>]), int(newRect[<span class="number">1</span>])</span><br><span class="line">                        newEndX, newEndY = int(newRect[<span class="number">2</span>]), int(newRect[<span class="number">3</span>])</span><br><span class="line">                        rectBallArea = srcImg[newInitY:newEndY, newInitX:newEndX, :]   <span class="comment"># 矩形区域(宽，高，通道)                    </span></span><br><span class="line">                        cv2.rectangle(srcImg, (newInitX, newInitY), (newEndX, newEndY), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)  <span class="comment"># 画矩形    </span></span><br><span class="line"></span><br><span class="line">                        resultColor = calColorFeature(rectBallArea, <span class="number">16</span>)  </span><br><span class="line">                        cellSize = min(newEndX - newInitX, newEndY - newInitY)</span><br><span class="line">                        result_HOG = calHOGFeature(rectBallArea, cellSize / <span class="number">2</span>)             </span><br><span class="line">                        resultTotal.extend(resultColor)</span><br><span class="line">                        resultTotal.extend(result_HOG)   </span><br><span class="line">                print(<span class="string">'resultTotal'</span>, len(resultTotal))  </span><br><span class="line"></span><br><span class="line">                cv2.imshow(<span class="string">"Original"</span>, srcImg)</span><br><span class="line">                cv2.waitKey(<span class="number">0</span>)  </span><br><span class="line">                row = <span class="string">' '</span>.join(list(map(str, resultTotal))) + <span class="string">' '</span> + str(<span class="number">0</span>) + <span class="string">'\n'</span></span><br><span class="line">                f.write(row)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;最后一行的<code>label</code>标签需要更改为<code>0</code>。  </p>
<h3 id="结果测试"><a href="#结果测试" class="headerlink" title="结果测试"></a>结果测试</h3><p>&emsp;&emsp;有了正负样本的特征向量后，就可以放入到分类器里面去训练参数了，这里将所有的特征向量都合并到一个<code>txt</code>文件里面。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resultTest</span><span class="params">(method)</span>:</span> </span><br><span class="line">    trainingSet = []</span><br><span class="line">    trainingLabels = []</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"data.txt"</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            currLine = line.strip().split()</span><br><span class="line">            lineArr = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">320</span>):</span><br><span class="line">                lineArr.append(float(currLine[i]))</span><br><span class="line">            trainingSet.append(lineArr)</span><br><span class="line">            trainingLabels.append(float(currLine[<span class="number">320</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">"Logistic"</span>:</span><br><span class="line">        log = Logistic(<span class="string">"data.txt"</span>, <span class="number">500</span>)</span><br><span class="line">        trainingWeights = log.gradDescent(trainingSet, trainingLabels)</span><br><span class="line">        numbers = <span class="number">39</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numbers):</span><br><span class="line">            print(<span class="string">"test"</span> + str(i))</span><br><span class="line">            srcImg = cv2.imread(<span class="string">"./images/"</span> + str(i) + <span class="string">".jpg"</span>) </span><br><span class="line"></span><br><span class="line">            conDet = ContoursDetection(srcImg)</span><br><span class="line">            preImg = conDet.preProcess(srcImg, <span class="string">"football"</span>)</span><br><span class="line">            rects = conDet.contoursDetection(preImg, minPerimeter=<span class="number">200</span>, minK=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> rects == []:</span><br><span class="line">                print(<span class="string">"test"</span> + str(i) + <span class="string">" no rects"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> rect <span class="keyword">in</span> rects:</span><br><span class="line">                resultTotal = []</span><br><span class="line">                rect = conDet.contour2Rect(rect)</span><br><span class="line">                <span class="keyword">if</span> rect[<span class="number">0</span>] &lt; <span class="number">0</span> <span class="keyword">or</span> rect[<span class="number">1</span>] &lt; <span class="number">0</span> <span class="keyword">or</span> rect[<span class="number">2</span>] &gt; <span class="number">640</span> <span class="keyword">or</span> rect[<span class="number">3</span>] &gt; <span class="number">480</span>:</span><br><span class="line">                    print(<span class="string">"out of bound"</span>)</span><br><span class="line">                    <span class="keyword">continue</span> </span><br><span class="line">                newRects = reshapeHoughRect(rect, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> newRectRow <span class="keyword">in</span> newRects:</span><br><span class="line">                    <span class="keyword">for</span> newRect <span class="keyword">in</span> newRectRow:</span><br><span class="line">                        newInitX, newInitY = int(newRect[<span class="number">0</span>]), int(newRect[<span class="number">1</span>])</span><br><span class="line">                        newEndX, newEndY = int(newRect[<span class="number">2</span>]), int(newRect[<span class="number">3</span>])</span><br><span class="line">                        rectBallArea = srcImg[newInitY:newEndY, newInitX:newEndX, :]                                   </span><br><span class="line"></span><br><span class="line">                        resultColor = calColorFeature(rectBallArea, <span class="number">16</span>)  </span><br><span class="line">                        cellSize = min(newEndX - newInitX, newEndY - newInitY)</span><br><span class="line">                        resultHOG = calHOGFeature(rectBallArea, cellSize / <span class="number">2</span>)             </span><br><span class="line">                        resultTotal.extend(resultColor)</span><br><span class="line">                        resultTotal.extend(resultHOG)       </span><br><span class="line"></span><br><span class="line">                resultTotal = np.array(resultTotal).reshape(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">                classify = log.classifyVector(resultTotal, trainingWeights)   </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> classify &gt; <span class="number">0.5</span>:</span><br><span class="line">                    classifyResult = <span class="string">"yes"</span></span><br><span class="line">                    cv2.rectangle(srcImg, (rect[<span class="number">0</span>], rect[<span class="number">1</span>]), (rect[<span class="number">2</span>], rect[<span class="number">3</span>]), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)             </span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    classifyResult = <span class="string">"no"</span></span><br><span class="line">                    cv2.rectangle(srcImg, (rect[<span class="number">0</span>], rect[<span class="number">1</span>]), (rect[<span class="number">2</span>], rect[<span class="number">3</span>]), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)  </span><br><span class="line"></span><br><span class="line">                print(<span class="string">'classify'</span>, classifyResult)</span><br><span class="line">            cv2.imshow(<span class="string">"test "</span> + str(i), srcImg)          </span><br><span class="line">            cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;首先打开特征向量的文本文件，将所有的特征向量和标签分布放到2个列表中，然后放到分类器里面得到权重参数，然后对每一张图片进行目标检测，并获得该目标区域的特征向量，在放到分类器里面得到预测的结果，最后如果概率大于0.5，则认为是，否则为不是。<br>&emsp;&emsp;下图为其中一张的测试结果：<br><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\足球检测结果.png" alt="data"><br>&emsp;&emsp;其中红色为正确的目标，黄色为错误的目标。实际测试下来，几乎可以达到实时检测，正确率也达到了比赛的标准。          </p>
<h2 id="黄杆类目标"><a href="#黄杆类目标" class="headerlink" title="黄杆类目标"></a>黄杆类目标</h2><p>&emsp;&emsp;黄杆类目标的模型训练和球类目标基本上一致，重复性的工作这里就不再叙述，读者可以自行考虑代码设计。<br>&emsp;&emsp;这里同样对模型进行一点改进，由于黄杆是细条型的矩形框，所以不能采用之前的均分方法。这里采用一种新的等分方法：首先找到黄杆的矩形框，然后将其左右延申，将<code>landmark</code>标记也框在矩形框内，然后为了克服随机性，将矩形框上下延申至图像的顶部和底部，最后再将其四等分。如图所示：<br><img src="/2019/04/27/NAO比赛视觉系统设计（python高级版）/\等分黄杆.png" alt="data"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reshapeStickRect</span><span class="params">(rawRect, numbers)</span>:</span></span><br><span class="line">    newRect = np.zeros((numbers, <span class="number">4</span>))</span><br><span class="line">    initX, initY, endX, endY = rawRect[<span class="number">0</span>], rawRect[<span class="number">1</span>], rawRect[<span class="number">2</span>], rawRect[<span class="number">3</span>]    <span class="comment"># 初始化参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找出每个小矩阵的顶点坐标</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numbers):</span><br><span class="line">        newRect[i][<span class="number">0</span>] = initX</span><br><span class="line">        newRect[i][<span class="number">1</span>] = initY + ((endY - initY) / numbers) * i</span><br><span class="line">        newRect[i][<span class="number">2</span>] = endX</span><br><span class="line">        newRect[i][<span class="number">3</span>] = initY + ((endY - initY) / numbers) * (i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRect</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;特征向量的提取和之前的球类目标类似，这样总的特征向量仍然为320个。   </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;高级版的设计其实也就是传统的目标检测方法，一般分为三个阶段：首先在给定的图像上选择一些候选的区域，然后对这些区域提取特征，最后使用训练的分类器进行分类。<br>&emsp;&emsp;随着技术的发展，现在目标检测的普遍做法是利用深度学习来训练模型，得到的分类器更具体一般性，效果也更好。这里就不再过多的叙述了，以后有机会也会发布深度学习版的NAO比赛目标检测。     </p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>谢谢老板！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Cxx 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Cxx 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/25/python高级编程/" rel="next" title="python高级编程">
                <i class="fa fa-chevron-left"></i> python高级编程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/04/基于卷积神经网络的猫狗分类器/" rel="prev" title="基于卷积神经网络的猫狗分类器">
                基于卷积神经网络的猫狗分类器 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MjAyMi8xODU2OQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Cxx</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#候选区域"><span class="nav-number">2.</span> <span class="nav-text">候选区域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#预处理"><span class="nav-number">2.1.</span> <span class="nav-text">预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HSV空间的二值化"><span class="nav-number">2.1.1.</span> <span class="nav-text">HSV空间的二值化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#霍夫圆检测"><span class="nav-number">2.2.</span> <span class="nav-text">霍夫圆检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#轮廓检测"><span class="nav-number">2.3.</span> <span class="nav-text">轮廓检测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#特征提取"><span class="nav-number">3.</span> <span class="nav-text">特征提取</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#球类目标颜色特征"><span class="nav-number">3.1.</span> <span class="nav-text">球类目标颜色特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HOG特征"><span class="nav-number">3.2.</span> <span class="nav-text">HOG特征</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分类器"><span class="nav-number">4.</span> <span class="nav-text">分类器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Logistic回归"><span class="nav-number">4.1.</span> <span class="nav-text">Logistic回归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模型训练"><span class="nav-number">5.</span> <span class="nav-text">模型训练</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#球类目标"><span class="nav-number">5.1.</span> <span class="nav-text">球类目标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#正样本"><span class="nav-number">5.1.1.</span> <span class="nav-text">正样本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#负样本"><span class="nav-number">5.1.2.</span> <span class="nav-text">负样本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结果测试"><span class="nav-number">5.1.3.</span> <span class="nav-text">结果测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#黄杆类目标"><span class="nav-number">5.2.</span> <span class="nav-text">黄杆类目标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cxx</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">100.0k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共100.0k字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  
  

  
  


  

  

</body>
</html>
